<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sun's Home</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="homepage.html">Happy Hacking</a></li><li><a href="distributed/index.html"><strong aria-hidden="true">1.</strong> 分布式基础</a></li><li><ol class="section"><li><a href="distributed/byzantine_generals_problem.html"><strong aria-hidden="true">1.1.</strong> 拜占庭将军问题（BGP）</a></li><li><a href="distributed/byzantine_agreement.html"><strong aria-hidden="true">1.2.</strong> 拜占庭协定（BA）与拜占庭容错（BFT）</a></li><li><a href="distributed/binary_byzantine_agreement.html"><strong aria-hidden="true">1.3.</strong> 二元拜占庭协定（BBA）</a></li><li><a href="distributed/time_state_order.html"><strong aria-hidden="true">1.4.</strong> 时钟，状态与顺序</a></li><li><a href="distributed/flp.html"><strong aria-hidden="true">1.5.</strong> FLP</a></li><li><a href="distributed/cap.html"><strong aria-hidden="true">1.6.</strong> CAP</a></li><li><a href="distributed/crdt.html"><strong aria-hidden="true">1.7.</strong> CRDT</a></li><li><a href="distributed/merklix-tree.html"><strong aria-hidden="true">1.8.</strong> Merklix-Merkle-Radix Tree</a></li><li><a href="distributed/distributed_system.html"><strong aria-hidden="true">1.9.</strong> 书: 分布式系统（概念与设计）</a></li></ol></li><li><a href="consensus/hashgraph.html"><strong aria-hidden="true">2.</strong> 共识算法</a></li><li><ol class="section"><li><a href="consensus/hashgraph.html"><strong aria-hidden="true">2.1.</strong> Hashgraph-DAG共识算法</a></li><li><a href="consensus/gossip.html"><strong aria-hidden="true">2.2.</strong> Gossip-消息交互方式</a></li><li><a href="consensus/spectre.html"><strong aria-hidden="true">2.3.</strong> Spectre-DAG共识算法</a></li><li><a href="consensus/phantom.html"><strong aria-hidden="true">2.4.</strong> Phantom-DAG共识算法</a></li><li><a href="consensus/disjoint.html"><strong aria-hidden="true">2.5.</strong> Disjoint-分组算法</a></li><li><a href="consensus/meshcash.html"><strong aria-hidden="true">2.6.</strong> Meshcash-分层拜占庭协议</a></li><li><a href="consensus/algorand.html"><strong aria-hidden="true">2.7.</strong> Algorand-分层拜占庭协议</a></li><li><a href="consensus/dfinity.html"><strong aria-hidden="true">2.8.</strong> Dfinity-密码学共识算法</a></li><li><a href="consensus/pbft.html"><strong aria-hidden="true">2.9.</strong> PBFT-实用拜占庭协议</a></li><li><a href="consensus/bft2f.html"><strong aria-hidden="true">2.10.</strong> BFT2F-1/2容错的拜占庭协议</a></li><li><a href="consensus/binary-multivalued-BA.html"><strong aria-hidden="true">2.11.</strong> B2MBA-二元至多值拜占庭协议</a></li><li><a href="consensus/eth-sharding.html"><strong aria-hidden="true">2.12.</strong> 以太坊分片技术</a></li><li><a href="consensus/zilliqa.html"><strong aria-hidden="true">2.13.</strong> Zilliqa-分片技术</a></li><li><a href="consensus/bitcoin-ng.html"><strong aria-hidden="true">2.14.</strong> Bitcoin-NG-扩展方案</a></li><li><a href="consensus/off-chain.html"><strong aria-hidden="true">2.15.</strong> Off-Chain-链下方案</a></li><li><a href="consensus/mimblewimble.html"><strong aria-hidden="true">2.16.</strong> Mimblewimble-密码学方案</a></li><li><a href="consensus/plasma.html"><strong aria-hidden="true">2.17.</strong> Plasma-侧链方案</a></li><li><a href="consensus/conflux.html"><strong aria-hidden="true">2.18.</strong> Conflux-链与DAG组合技术</a></li><li><a href="consensus/polkadot.html"><strong aria-hidden="true">2.19.</strong> Polkadot-跨链技术</a></li><li><a href="consensus/parsec.html"><strong aria-hidden="true">2.20.</strong> Parsec-DAG共识算法</a></li><li><a href="consensus/hal_signature_free.html"><strong aria-hidden="true">2.21.</strong> SFAB-免签名的异步拜占庭共识</a></li><li><a href="consensus/made_trivial.html"><strong aria-hidden="true">2.22.</strong> Made Trivial-拜占庭协议</a></li><li><a href="consensus/honey_badger_bft.html"><strong aria-hidden="true">2.23.</strong> Honey Badger BFT-拜占庭协议</a></li><li><a href="consensus/snowflake_avalanche.html"><strong aria-hidden="true">2.24.</strong> Snowflake Avalanche-共识协议</a></li></ol></li><li><a href="cryptography/sodium.html"><strong aria-hidden="true">3.</strong> 密码学</a></li><li><ol class="section"><li><a href="cryptography/verifiable_random_functions.html"><strong aria-hidden="true">3.1.</strong> VRF</a></li><li><a href="cryptography/verifiable_delay_functions.html"><strong aria-hidden="true">3.2.</strong> VDF</a></li><li><a href="cryptography/threshold_signature.html"><strong aria-hidden="true">3.3.</strong> 门限签名</a></li><li><a href="cryptography/ring_signature.html"><strong aria-hidden="true">3.4.</strong> 环签名</a></li><li><a href="cryptography/homomorphic_encryption.html"><strong aria-hidden="true">3.5.</strong> 同态加密</a></li><li><a href="cryptography/homomorphic_encryption.html"><strong aria-hidden="true">3.6.</strong> 格加密</a></li><li><a href="cryptography/bulletproofs.html"><strong aria-hidden="true">3.7.</strong> Bulletproofs-非交互零知识证明</a></li><li><a href="cryptography/schnorr.html"><strong aria-hidden="true">3.8.</strong> Schnorr-系列算法和协议</a></li><li><a href="cryptography/sigma.html"><strong aria-hidden="true">3.9.</strong> Sigma-系列算法和协议</a></li><li><a href="cryptography/ristretto.html"><strong aria-hidden="true">3.10.</strong> Ristretto/Decaf-非素数阶曲线实现素数阶群</a></li><li><a href="cryptography/sodium.html"><strong aria-hidden="true">3.11.</strong> sodium加密库</a></li><li><a href="cryptography/25519.html"><strong aria-hidden="true">3.12.</strong> Curve25519/Ed25519/X25519</a></li><li><a href="cryptography/forward_backward_secrecy.html"><strong aria-hidden="true">3.13.</strong> 前（后）向安全性</a></li><li><a href="cryptography/52_things_cryptography.html"><strong aria-hidden="true">3.14.</strong> 密码学52个知识点</a></li><li><a href="cryptography/things_1.html"><strong aria-hidden="true">3.15.</strong> 知识点1-处理器区别</a></li><li><a href="cryptography/things_2.html"><strong aria-hidden="true">3.16.</strong> 知识点2-多核和矢量处理器</a></li><li><a href="cryptography/things_3.html"><strong aria-hidden="true">3.17.</strong> 知识点3-不同设备的计算和存储</a></li><li><a href="cryptography/things_4.html"><strong aria-hidden="true">3.18.</strong> 知识点4-复杂度类P</a></li><li><a href="cryptography/things_5.html"><strong aria-hidden="true">3.19.</strong> 知识点5-复杂度类NP</a></li><li><a href="cryptography/things_6.html"><strong aria-hidden="true">3.20.</strong> 知识点6-NP:多项式时间内检验证明的定理</a></li><li><a href="cryptography/things_7.html"><strong aria-hidden="true">3.21.</strong> 知识点7-随机性与BPP</a></li></ol></li><li><a href="P2P/dht.html"><strong aria-hidden="true">4.</strong> P2P通信</a></li><li><ol class="section"><li><a href="P2P/dht.html"><strong aria-hidden="true">4.1.</strong> DHT</a></li><li><a href="P2P/kademlia.html"><strong aria-hidden="true">4.2.</strong> DHT-Kademlia</a></li><li><a href="P2P/secure_kademlia.html"><strong aria-hidden="true">4.3.</strong> S/Kademlia</a></li><li><a href="P2P/nat.html"><strong aria-hidden="true">4.4.</strong> NAT</a></li></ol></li><li><a href="db/cache_replacement_policies.html"><strong aria-hidden="true">5.</strong> 存储</a></li><li><ol class="section"><li><a href="db/cache_replacement_policies.html"><strong aria-hidden="true">5.1.</strong> 缓存置换机制</a></li><li><a href="db/wal.html"><strong aria-hidden="true">5.2.</strong> WAL-预写式日志</a></li><li><a href="db/hdd_ssd.html"><strong aria-hidden="true">5.3.</strong> hdd/ssd-硬盘存储设置差别</a></li><li><a href="db/overlaydb.html"><strong aria-hidden="true">5.4.</strong> Overlay Database</a></li></ol></li><li><a href="blockchain/blockchain_start.html"><strong aria-hidden="true">6.</strong> 区块链</a></li><li><ol class="section"><li><a href="blockchain/blockchain_start.html"><strong aria-hidden="true">6.1.</strong> 区块链底层开发指北</a></li><li><a href="blockchain/blockchain_door.html"><strong aria-hidden="true">6.2.</strong> 区块链世界浏览器脑洞</a></li><li><a href="blockchain/exchanges.html"><strong aria-hidden="true">6.3.</strong> (去)中心化交易所模块</a></li><li><a href="blockchain/attack_double_spending.html"><strong aria-hidden="true">6.4.</strong> 攻击-双花(Double-spending)</a></li><li><a href="blockchain/attack_sybil.html"><strong aria-hidden="true">6.5.</strong> 攻击-女巫(Sybil)</a></li><li><a href="blockchain/attack_eclipse.html"><strong aria-hidden="true">6.6.</strong> 攻击-日蚀(Eclipse)</a></li><li><a href="blockchain/attack_targeted.html"><strong aria-hidden="true">6.7.</strong> 攻击-定向(Targeted)</a></li></ol></li><li><a href="rust/learning.html"><strong aria-hidden="true">7.</strong> Rust</a></li><li><ol class="section"><li><a href="rust/trait.html"><strong aria-hidden="true">7.1.</strong> Trait</a></li></ol></li><li><a href="python/pip-mirrors.html"><strong aria-hidden="true">8.</strong> Python</a></li><li><ol class="section"><li><a href="python/pip-mirrors.html"><strong aria-hidden="true">8.1.</strong> pip 国内镜像的正确使用姿态</a></li><li><a href="python/selenium_chrome.html"><strong aria-hidden="true">8.2.</strong> selenium + headless Chrome</a></li><li><a href="python/flask-dir.html"><strong aria-hidden="true">8.3.</strong> Flask 项目结构的分析</a></li></ol></li><li><a href="emacs/live.html"><strong aria-hidden="true">9.</strong> Emacs</a></li><li><ol class="section"><li><a href="emacs/emacs_love_python.html"><strong aria-hidden="true">9.1.</strong> 在emacs中开发python</a></li></ol></li><li><a href="thinking/nowadays-education-of-classic-book-in-china.html"><strong aria-hidden="true">10.</strong> 杂笔</a></li><li><ol class="section"><li><a href="thinking/nowadays-education-of-classic-book-in-china.html"><strong aria-hidden="true">10.1.</strong> 论中国传统教育现代化</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Sun's Home</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#happy-hacking-" id="happy-hacking-"><h2>Happy Hacking !</h2></a>
<p>This Is Sun's Personal Website (Note).</p>
<p>Who is Sun ? Maybe you can find me by hackersun.me AT gmail.com</p>
<p><img src="./static/sun.jpg" alt="sun" /></p>
<a class="header" href="#a分布式系统" id="a分布式系统"><h3>分布式系统</h3></a>
<p>分布式系统算法可以根据不同的性质进行分类。比如说根据时序模型，根据进程间的通信方式，根据这个算法所使用的故障模式，还有很多很多，我们接下来也会看到。</p>
<ul>
<li>时序模型 (Timing Model)</li>
<li>进程间通信 (Interprocess Communication)</li>
<li>故障模式 (Failure Modes)</li>
<li>故障检测器 (Failure Detectors)</li>
<li>领袖选举 (Leader Election)</li>
<li>一致性 (Consensus)</li>
<li>仲裁集 (Quorums)</li>
<li>分布式系统中的时间 (Time in distributed systems)</li>
<li>FLP 浏览</li>
<li>总结</li>
<li>引用</li>
</ul>
<a class="header" href="#a拜占庭将军问题" id="a拜占庭将军问题"><h1>拜占庭将军问题</h1></a>
<a class="header" href="#a拜占庭协定ba与拜占庭容错bft" id="a拜占庭协定ba与拜占庭容错bft"><h1>拜占庭协定（BA）与拜占庭容错（BFT）</h1></a>
<a class="header" href="#a二元拜占庭协定bba" id="a二元拜占庭协定bba"><h1>二元拜占庭协定（BBA）</h1></a>
<a class="header" href="#a时钟状态与顺序" id="a时钟状态与顺序"><h1>时钟，状态与顺序</h1></a>
<a class="header" href="#flp" id="flp"><h1>FLP</h1></a>
<a class="header" href="#cap理论" id="cap理论"><h3>CAP理论</h3></a>
<p><a href="https://en.wikipedia.org/wiki/CAP_theorem">WIKI观点</a></p>
<p><a href="https://www.comp.nus.edu.sg/%7Egilbert/pubs/BrewersConjecture-SigAct.pdf">证明论文</a></p>
<p><a href="https://www.goland.org/blockchain_and_cap/">关于Bitcoin在CAP中的地位</a></p>
<p><img src="../static/CAP.png" alt="CAP" /></p>
<a class="header" href="#a区块链比特币处在cap中的什么位置" id="a区块链比特币处在cap中的什么位置"><h4>区块链（比特币）处在CAP中的什么位置？</h4></a>
<p>首先传统区块链系统是满足分区容错的，所以有一个P，至于是CP, 还是AP，取决于对于客户端或者说用户的设置。
-. 如果用户觉得收到区块，就相信这个区块，那么就是AP
-. 如果用户觉得必须等到六个区块确认后，才可以正常使用，那么区块链就是个CP</p>
<a class="header" href="#dag处在cap中的什么位置" id="dag处在cap中的什么位置"><h4>DAG处在CAP中的什么位置？</h4></a>
<p>DAG也是具有分区容错的，所以也有一个P，但是DAG就是一个AP</p>
<ul>
<li>因为用户不用担心双花的问题，因为随时可以使用账户，任何交易都不会被DAG网络丢弃</li>
<li>用户想要判别出交易是否有效，必须要等待很长一段时间，通过其他对比算法才能得到最终结果</li>
</ul>
<p>CAP想要知道一个系统在某个时期到底是选择了CA，还是AP，这是有一个前提的，那就是分区-P，在知道产生了分区的情况下才会出现选择A，还是C的问题。在传统的分布式存储中，想要知道是否出现分区的特征是与其他的主机网络通信断开了。这个时候，系统可以知道自己处在了分区容错阶段，但是区块链系统因为是完全的P2P系统，一个主机并不是通过是否与网络其他Peers断开来判断自己是否处在分区中，而是通过收到区块，区块是否出现了分叉了判断自己是否处于分区中，如果主机判断自己现在出现了分叉，而且这个分叉是没有办法立即得到分区容错结果的，那么这个时候区块对外提供服务的时候，选择了A，还是P才有意义。也就是说，当区块链节点收到两个区块，出现分叉的时候，是否对外继续提供有效服务，如果提供有效服务，那么就是选择了可用性，如果不提供有效服务，也就是不提供是否接受交易并广播的反馈，那么就是选择了一致性。这点需要代码层次了解。这也就是说需要不同的客户端实现才能确认。如果客户端的实现是接受交易并立马广播出去，那么就是可用性，如果客户端只接受交易但是并不对这个交易进行广播和处理（写入操作），那就是选择了一致性。</p>
<a class="header" href="#crdt" id="crdt"><h3>CRDT</h3></a>
<p>CRDT是Conflict-Free Replicated Data Types的缩写，直译的话即“无冲突可复制数据类型”。</p>
<p><a href="https://hal.inria.fr/file/index/docid/555588/filename/techreport.pdf">研究论文</a></p>
<p><a href="https://github.com/basho/riak_dt">代码实现库erlang</a></p>
<ol>
<li>定义了CRDT</li>
<li>列举了CRDT的两种基本形式，即基于状态的CRDT与基于操作的CRDT。前者存储的是一个个的最终值，类似我们的例子，后者存储的是一个个的操作记录，类似于我们例子里面的推导过程</li>
<li>界定了CRDT能满足最终一致性的边界条件。简单说，设计一个CRDT，只需要验证它是否满足这些边界条件，即可知道它是否能保持最终一致</li>
<li>界定了两类CRDT在系统中应用时，需要的信息交换的边界条件。即回答怎样叫做“收集到足够多的信息”</li>
<li>枚举了当前人类所知的CRDT，包含了计数器(counter)，寄存器(register)，集合(set)和图(graph)等几类</li>
<li>在现实中应该如何应用CRDT，尤其是对于存储空间怎样进行回收的问题</li>
</ol>
<a class="header" href="#a使用-merklix-tree-进行分块验证-raidx-tree-and-merkle-tree-结合" id="a使用-merklix-tree-进行分块验证-raidx-tree-and-merkle-tree-结合"><h3>使用 Merklix Tree 进行分块验证 （Raidx Tree and Merkle Tree 结合）</h3></a>
<p><a href="https://www.deadalnix.me/2016/11/06/using-merklix-tree-to-shard-block-validation/">原始地址</a></p>
<p><a href="https://www.deadalnix.me/2016/09/24/introducing-merklix-tree-as-an-unordered-merkle-tree-on-steroid/">Merklix Tree</a></p>
<a class="header" href="#merkle-tree" id="merkle-tree"><h4>Merkle Tree</h4></a>
<p><img src="../static/Merkle-tree.png" alt="Merkle Tree" /></p>
<a class="header" href="#radix-tree" id="radix-tree"><h4>Radix Tree</h4></a>
<a class="header" href="#merklix-tree" id="merklix-tree"><h4>Merklix Tree</h4></a>
<p>无序的Merkle树</p>
<a class="header" href="#a新特性" id="a新特性"><h5>新特性</h5></a>
<ol>
<li>无论树以何种方式创建，最终的结果都是一样的</li>
<li>插入和删除是ln（n）</li>
<li>可以生成一个证明，证明一个元素包含在集合中而不产生集合</li>
</ol>
<p>用一个Key（不是必要写出来的）去标记所有element在树中的位置。与Merkle不一样，这样的Key可以是分散的。通过使每个节点成为所有元素的子树，在它们的Key中具有共同的前缀，可以使用基数结构来存储元素。</p>
<a class="header" href="#a分布式系统学习摘要" id="a分布式系统学习摘要"><h3>分布式系统学习摘要</h3></a>
<a class="header" href="#a分布式系统的几个显著特点" id="a分布式系统的几个显著特点"><h5>分布式系统的几个显著特点</h5></a>
<ol>
<li>并发执行</li>
<li>无全局的时钟</li>
<li>故障的独立性-无法辨别机器故障还是网络故障，也就得保障故障时的依旧可运行</li>
</ol>
<a class="header" href="#a超级复杂的分布式系统" id="a超级复杂的分布式系统"><h5>超级复杂的分布式系统</h5></a>
<ul>
<li>Web搜索
<ul>
<li>一个底层的物理设施</li>
<li>一个分布式的文件系统</li>
<li>一个相关的结构化分布式存储系统</li>
<li>一个锁系统</li>
<li>一个编程模式</li>
</ul>
</li>
<li>大型在线游戏（MMOG）
<ul>
<li>客户-服务器模型（负载分区和用户分区） EVE游戏</li>
<li>完全对等的技术？研究中 =&gt; 长久运行（永不宕机）的游戏服务基础设施</li>
</ul>
</li>
<li>金融交易
<ul>
<li>基于事件的分布式系统</li>
<li>异构性问题的适配器。复杂事件处理(CEP)</li>
</ul>
</li>
</ul>
<a class="header" href="#a趋势" id="a趋势"><h5>趋势</h5></a>
<ol>
<li>出现了泛在联网技术</li>
<li>出现了无处不在计算，支持用户移动性的意愿</li>
<li>对多媒体设备的需求增加</li>
<li>把分布式系统作为一个基础设施 （云计算，云存储等）</li>
</ol>
<a class="header" href="#a挑战" id="a挑战"><h5>挑战</h5></a>
<ol>
<li>异构性（网络，计算机硬件，操作系统，编程语言，软件实现等），通过中间件实现</li>
<li>开放性
<ul>
<li>发布系统的关键接口是开发系统的特征</li>
<li>开发的分布式系统是基于一致的通信机制和发布接口访问共享资源</li>
<li>能够使用异构的硬件和软件构建</li>
</ul>
</li>
<li>安全性。有两大安全：DDOS, 移动代码的安全性(远程代码的本地执行)
<ul>
<li>机密性</li>
<li>完整性</li>
<li>可用性</li>
</ul>
</li>
<li>可伸缩性 —— 理想状态下，系统规模变化时候，系统和应用程序应该不需要随之改变
<ul>
<li>控制物理资源的开销</li>
<li>控制性能损失</li>
<li>防止软件资源耗尽</li>
<li>避免性能瓶颈</li>
</ul>
</li>
<li>故障处理
<ul>
<li>检测故障</li>
<li>掩盖故障</li>
<li>容错</li>
<li>故障恢复</li>
<li>冗余 —— 以便解决容错</li>
</ul>
</li>
<li>并发性</li>
<li>透明性 —— 对外屏蔽分布式系统的分离性，被认为是一个整体
<ul>
<li><em>访问透明性</em></li>
<li><em>位置透明性</em></li>
<li>并发透明性</li>
<li>复制透明性</li>
<li>故障透明性</li>
<li>移动透明性</li>
<li>性能透明性</li>
<li>伸缩透明性</li>
</ul>
</li>
<li>服务质量 —— 可靠，安全，性能</li>
</ol>
<a class="header" href="#a分布式体系结构" id="a分布式体系结构"><h4>分布式体系结构</h4></a>
<a class="header" href="#a体系结构元素" id="a体系结构元素"><h5>体系结构元素</h5></a>
<ul>
<li>通信实体：
<ul>
<li>对象</li>
<li>组件</li>
<li>Web服务</li>
</ul>
</li>
<li>通信范型：
<ul>
<li>进程间通信
<ul>
<li>消息传递</li>
<li>套接字</li>
<li>多播</li>
</ul>
</li>
<li>远程调用
<ul>
<li>请求-应答模型</li>
<li>远程过程调用-RPC</li>
<li>远程方法调用-RMI（一般跟分布式对象一起组合使用）</li>
</ul>
</li>
<li>间接通信
<ul>
<li>组通信（一对多的通信范型）</li>
<li>发布-订阅系统</li>
<li>消息队列（生产者和消费者模型的中介方式）</li>
<li>元组空间（生成通信，提供一个持久的元组空间）</li>
<li>分布式共享内存（DSM）</li>
</ul>
</li>
</ul>
</li>
<li>角色和责任
<ul>
<li>客户 —— 服务器</li>
<li>对等体系结构</li>
</ul>
</li>
</ul>
<a class="header" href="#a体系结构模式" id="a体系结构模式"><h5>体系结构模式</h5></a>
<ul>
<li>分层体系结构（Layering architecture）</li>
<li>层次化体系结构（tiered architecture）</li>
<li>瘦客户相关的概念（包括虚拟网络计算的特定机制）</li>
</ul>
<a class="header" href="#a基础模型" id="a基础模型"><h4>基础模型</h4></a>
<ul>
<li>交互模型
<ul>
<li>通信信道的性能：延迟(latency), 带宽(bandwidth), 抖动(jitter, 多与流媒体相关)</li>
<li>计算机时钟和时序事件：时钟漂移率(clock drift rate)</li>
<li>交互模型的两个变体
<ul>
<li>同步分布式系统：进程执行的每一步的时间都有一个上限和下限，通过通道传递的每一个消息在一个已知的范围内接收到，每个进程有一个本地时钟，与实际事件的漂移率在一个已知的范围</li>
<li>异步分布式系统：进程执行速度不受限制，消息传递延迟不受限制，时钟漂移率不受限制</li>
</ul>
</li>
<li>事件排序（Pepperland协定）—— 逻辑时间</li>
</ul>
</li>
<li>故障模型
<ul>
<li>遗漏故障 —— 良性故障：进程或者通信通道不能完成它应该做的动作。进程遗漏故障主要是崩溃。通信遗漏故障（发送,通道,接收遗漏故障）</li>
<li>随机故障（拜占庭故障）—— 恶性故障</li>
<li>时序故障（同步分布式系统中，性能故障） —— 良性故障：实时操作系统</li>
<li>故障屏蔽</li>
<li>一对一通信的可靠性：有效性与完整性（重放攻击，伪造消息，篡改消息）</li>
</ul>
</li>
<li>安全模型
<ul>
<li>保护对象</li>
<li>保护进程与它们的交互</li>
<li>解除安全威胁
<ul>
<li><em>密码学与共享秘密</em></li>
<li><em>认证</em></li>
<li><em>安全通道</em>：每个进程知道执行主体身份，保障传输数据的私密性和完整性，消息包括物理或逻辑时间戳防止重放和篡改</li>
</ul>
</li>
<li>其他可能的来自敌人的威胁（拒绝服务攻击，移动代码执行等）</li>
</ul>
</li>
</ul>
<a class="header" href="#a网络与网络互联" id="a网络与网络互联"><h3>网络与网络互联</h3></a>
<p>...</p>
<a class="header" href="#a进程间通信" id="a进程间通信"><h3>进程间通信</h3></a>
<p>层次： 2和3都是中间件层</p>
<ol>
<li>
<p>应用，服务</p>
</li>
<li>
<p>远程调用和间接通信</p>
</li>
<li>
<p>底层进程间通信原语：套接字，消息传递，组播支持，覆盖网络</p>
</li>
<li>
<p>UDP和TCP</p>
</li>
</ol>
<ul>
<li>
<p>UDP：提供了消息传递(message passing)抽象</p>
</li>
<li>
<p>TCP：提供了进程间的双向数据流(two-way stream)抽象 —— 生产者和消费者</p>
</li>
<li>
<p>CORBA：公共数据表示(Common Data Representation)</p>
</li>
</ul>
<a class="header" href="#a组播通信" id="a组播通信"><h4>组播通信</h4></a>
<p>将单个消息从一个进程发送到一组进程的每一个成员。</p>
<p>组播通信为构造下面特征的分布式系统提供了基础设施:</p>
<ul>
<li>基于复制服务的容错(fault tolerance based on replicated services), 就是客户需要发送消息到一组服务器所有成员上，这样，就算每个宕机，也可以提供服务</li>
<li>在自发网络中发现服务(discovering services in spontaneous networking)</li>
<li>通过复制的数据获得更好的性能(better performance through replicated data)</li>
<li>事件通知的传播(propagation of event notification) —— 发布订阅</li>
</ul>
<a class="header" href="#ip组播--组播通信的实现" id="ip组播--组播通信的实现"><h5>IP组播 —— 组播通信的实现</h5></a>
<ul>
<li>组播路由器 —— 设置路由长度：存活时间(TTL)</li>
<li>组播地址分配 —— 224.0.0.0 ~ 239.255.255.255</li>
</ul>
<a class="header" href="#a覆盖网络-overlay-network" id="a覆盖网络-overlay-network"><h4>覆盖网络 overlay network</h4></a>
<p>是一个节点与虚拟链接组成的虚拟网络，位于一个底层网络（例如IP网络）之上。</p>
<ul>
<li>为应用需求而裁剪
<ul>
<li>分布式散列表 —— Kad</li>
<li>对等文件共享 —— BT下载</li>
<li>内容分发网络 —— CDN</li>
</ul>
</li>
<li>为网络类型而裁剪
<ul>
<li>无线自组织网络 —— 提供的定制的路由协议，包括能在底层节点上有效构造路由拓扑的主动模式和按需构建路由的被动模式，后者通常由泛洪机制支持</li>
<li>容中断网络 —— 用于恶劣环境中，可能遭遇严重链接故障，具有很高的延迟</li>
</ul>
</li>
<li>提供额外的特性
<ul>
<li>组播</li>
<li>恢复能力 —— 提升互联网服务路径健壮性和可用性</li>
<li>安全性 —— 虚拟私网</li>
</ul>
</li>
<li>实例研究 —— Skype</li>
</ul>
<a class="header" href="#a远程调用" id="a远程调用"><h3>远程调用</h3></a>
<a class="header" href="#rpc" id="rpc"><h5>RPC</h5></a>
<ul>
<li>RPC推动的编程风格——面向接口编程</li>
<li>和RPC关联的调用语义</li>
<li>透明性的关键问题和它如何与远程过程调用相关联</li>
<li>分布式系统的接口与接口定义语言(Interface Definition Languages)</li>
<li>RPC调用语义
<ul>
<li>重发请求消息，过滤重复请求，重传结果</li>
<li>或许调用语义——可能调用执行一次或者根本不执行</li>
<li>至少调用一次语义</li>
<li>至多一次调用语义</li>
</ul>
</li>
<li>实例 Sun RPC —— Sun NFS</li>
</ul>
<a class="header" href="#rmi" id="rmi"><h5>RMI</h5></a>
<ul>
<li>与RPC共性
<ul>
<li>接口编程</li>
<li>基于请求——应答模型</li>
<li>相似地透明度</li>
</ul>
</li>
<li>不同点
<ul>
<li>可以使用面向对象的方式</li>
<li>基于面向对象中对象标识的概念（对象具有惟一的标识符）</li>
</ul>
</li>
<li>两个核心的概念
<ul>
<li>远程对象的引用 —— 能够调用远程的对象去调用别的远程对象</li>
<li>远程接口</li>
</ul>
</li>
<li>实例研究 —— Java RMI</li>
</ul>
<a class="header" href="#a间接通信" id="a间接通信"><h3>间接通信</h3></a>
<table><thead><tr><th>  </th><th> 时间耦合 </th><th> 时间解耦 </th></tr></thead><tbody>
<tr><td> 空间耦合 </td><td> 性质：与一个或一些给定的接收者直接通信；接收者必须在那个时候存在 例子：消息传递，远程调用 </td><td> 性质：与一个或一些给定的接收者直接通信；发送者和接收者有各自的独立的生命周期 </td></tr>
<tr><td> 空间解耦 </td><td> 性质：发送者不需要知道接收者的身份；接收者必须在那个时候存在 例子：IP组播 </td><td> 性质：发送者不需要知道接收者的身份；发送者和接收者有各自的独立的生命周期 例子：大部分间接通信模型 </td></tr>
</tbody></table>
<ul>
<li>组通信。组通信对于IP组播就像TCP对IP中的点对点服务一样。
<ul>
<li>应用领域：
<ul>
<li>面向可能是大量客户的可靠信息分发，包括金融业</li>
<li>支持协作应用 google docs</li>
<li>支持一系列容错策略，包括复制数据的一致更新，或者高可用（复制）服务器实现</li>
<li>支持系统监控和管理，包括负载均衡策略</li>
</ul>
</li>
<li>编程模型：一个进程事项只发起一个组播操作，是一个send操作，将消息传到组的每一个成员，而不是发起多个send操作
<ul>
<li>进程组和对象组</li>
<li>封闭组和开发组：封闭组只发送到本组内，开发组可以发送到任何人那</li>
<li>重叠和非重叠组：在实际系统中，组成员的重叠是现实的</li>
<li>同步和异步系统</li>
</ul>
</li>
<li>实例研究 —— JGroups工具箱</li>
</ul>
</li>
<li>发布-订阅系统(publish-subscribe systems)。有时也被称为基于事件的分布式系统(distributed event-based system)。大部分系统都是自然地建模成由事件提供的更为解耦和反应式的编程风格。
<ul>
<li>
<p>应用场景：</p>
<ul>
<li>金融信息系统</li>
<li>实时数据直接输入的其他领域(RSS)</li>
<li>支持协同工作</li>
<li>支持无处不在的计算，包括管理来自无处不在基础设施的事件（例如：位置事件）</li>
<li>一系列监控应用，包括互联网上的网络监控</li>
</ul>
</li>
<li>
<p>特征：</p>
<ul>
<li>异构性</li>
<li>异步性</li>
<li>传递保障</li>
</ul>
</li>
<li>
<p>实现方式</p>
<ul>
<li>集中式实现：单点服务器提供代理，缺乏弹性和可伸缩性</li>
<li>分布式实现：代理网络(network of broker)</li>
</ul>
<p><img src="../static/ds-pub-sub.png" alt="发布-订阅的体系结构" /></p>
<ul>
<li>泛洪：像网络中所有节点发送事件通知，不必要的网络流量</li>
<li>过滤：基于本地和代理点的路由订阅信息，单独给订阅者发送，但是订阅者需要事先向可能的发布者泛洪告知</li>
<li>汇聚：类DHT一样的路由机制</li>
<li>知情闲聊(informed gossip)：将动态消息与邻居进行交换</li>
</ul>
</li>
<li>
<p>实例研究</p>
</li>
</ul>
</li>
</ul>
<table><thead><tr><th> 系统               </th><th> 订阅模型       </th><th> 分布模型  </th><th> 事件路由   </th></tr></thead><tbody>
<tr><td> CORBA 事件服务     </td><td> 基于渠道       </td><td> 集中式    </td><td>            </td></tr>
<tr><td> TIB Rendezvouz     </td><td> 基于主题       </td><td> 分布式    </td><td> 过滤       </td></tr>
<tr><td> Scribe             </td><td> 基于主题       </td><td> 对等(DHT) </td><td> 汇聚       </td></tr>
<tr><td> TERA               </td><td> 基于主题       </td><td> 对等      </td><td> 知情闲聊   </td></tr>
<tr><td> Siena              </td><td> 基于内容       </td><td> 分布式    </td><td> 过滤       </td></tr>
<tr><td> Gryphon            </td><td> 基于内容       </td><td> 分布式    </td><td> 过滤       </td></tr>
<tr><td> Hermes             </td><td> 基于主题和内容 </td><td> 分布式    </td><td> 汇聚和过滤 </td></tr>
<tr><td> MEDYM              </td><td> 基于内容       </td><td> 分布式    </td><td> 泛洪       </td></tr>
<tr><td> Meghdoot           </td><td> 基于内容       </td><td> 对等      </td><td> 汇聚       </td></tr>
<tr><td> Structure-less CBR </td><td> 基于内容       </td><td> 对等      </td><td> 知情闲聊   </td></tr>
</tbody></table>
<ul>
<li>消息队列 —— 分布式消息队列 —— 面向消息的中间件
<ul>
<li>集中式实现</li>
<li>分布式实现：WebSphere MQ, JMS</li>
</ul>
</li>
<li>共享内存
<ul>
<li>分布式共享内存（DSM） —— 必须是异步，不再是基于请求-应答模型</li>
<li>元组空间通信 —— 生成通信。Agora系统，JavaSpaces, TSpaces
<ul>
<li>空间解耦 —— 分布式命名(distributed naming)</li>
<li>事件解耦</li>
</ul>
</li>
</ul>
</li>
</ul>
<table><thead><tr><th>          </th><th> 组             </th><th> 发布-订阅系统                     </th><th> 消息队列                    </th><th> DSM              </th><th> 元组空间                             </th></tr></thead><tbody>
<tr><td> 空间解耦 </td><td> 是             </td><td> 是                                </td><td> 是                          </td><td> 是               </td><td> 是                                   </td></tr>
<tr><td> 时间解耦 </td><td> 可能           </td><td> 可能                              </td><td> 是                          </td><td> 是               </td><td> 是                                   </td></tr>
<tr><td> 服务风格 </td><td> 基于通信       </td><td> 基于通信                          </td><td> 基于通信                    </td><td> 基于状态         </td><td> 基于状态                             </td></tr>
<tr><td> 通信模式 </td><td> 一对多         </td><td> 一对多                            </td><td> 一对一                      </td><td> 一对多           </td><td> 一对一或一对多                       </td></tr>
<tr><td> 主要目的 </td><td> 可靠分布式计算 </td><td> 信息分发或EAI；移动和无处不在系统 </td><td> 信息分发或EAI；商业事务处理 </td><td> 并行和分布式计算 </td><td> 并行和分布式计算；移动和无处不在系统 </td></tr>
<tr><td> 可伸缩性 </td><td> 有限           </td><td> 可能                              </td><td> 可能                        </td><td> 有限             </td><td> 有限                                 </td></tr>
<tr><td> 关联性   </td><td> 无             </td><td> 仅基于内容的                      </td><td> 无                          </td><td> 无               </td><td> 有                                   </td></tr>
</tbody></table>
<a class="header" href="#a操作系统支持" id="a操作系统支持"><h3>操作系统支持</h3></a>
<p>...</p>
<a class="header" href="#a分布式对象和组件" id="a分布式对象和组件"><h3>分布式对象和组件</h3></a>
<p>CORBA - 分布式对象； EJB, Fractal - 分布式组件</p>
<a class="header" href="#a分布式对象" id="a分布式对象"><h4>分布式对象</h4></a>
<ul>
<li>出现的背景
<ul>
<li>分布式系统方面，早期的是简单的基于客户-服务器模型</li>
<li>编程语言方面，面向对象语言的兴起</li>
<li>软件工程方面，面向对象的风格引起了UML(Unified Modeling Language)出现，成为面向对象系统的业界标准的表示方法</li>
</ul>
</li>
</ul>
<a class="header" href="#a分布式对象和传统对象区别" id="a分布式对象和传统对象区别"><h5>分布式对象和传统对象区别</h5></a>
<table><thead><tr><th> 对象     </th><th> 分布式对象     </th><th> 分布式对象的描述                                               </th></tr></thead><tbody>
<tr><td> 对象引用 </td><td> 远程对象引用   </td><td> 分布式对象具有全局唯一的引用，可以作为参数传递                 </td></tr>
<tr><td> 接口     </td><td> 远程接口       </td><td> 提供在远程对象上可调用方法的抽象，使用接口(IDL)定义            </td></tr>
<tr><td> 动作     </td><td> 分布式动作     </td><td> 由方法调用初始化，可能会形成调用链；使用RMI进行远程调用        </td></tr>
<tr><td> 异常     </td><td> 分布式异常     </td><td> 由于系统的分布式特性，会生成额外的异常，例如消息丢失或进程故障 </td></tr>
<tr><td> 垃圾回收 </td><td> 分布式垃圾回收 </td><td> 需要分布式垃圾回收算法，扩展现有模式确保对象至少有一个本地或远程对象引用时必须存在，否则应该回收它                                                               </td></tr>
</tbody></table>
<ul>
<li>类：一组对象的相关行为的描述(模板), 用给定行为实例化对象或对象组的地方(工厂), 分布式系统中通常用模板和工厂这样的叫法。</li>
<li>继承：分布式系统提供接口继承。</li>
<li>对象间通信</li>
<li>生命周期管理</li>
<li>激活与去活</li>
<li>持久化</li>
<li>其他服务</li>
</ul>
<a class="header" href="#web服务" id="web服务"><h3>Web服务</h3></a>
<p>...</p>
<a class="header" href="#a对等系统" id="a对等系统"><h3>对等系统</h3></a>
<ul>
<li>特点：
<ul>
<li>系统设计确保每个用户都能想系统提供资源</li>
<li>虽然各个参与的节点提供的资源不同，但在同一个对等系统中它们具有相同的功能和责任</li>
<li>系统不依赖一个中心管理系统就能正常运行</li>
<li>系统的设计能够给资源的提供者和使用者提供一定限度的匿名性</li>
<li>系统能够高效运行的一个关键点就是选择一个在大量主机中放置数据资源，以及访问这些资源的方法。这个算法能够自动平衡各个主机的负载，确保可用性，并且不会增加不必要的负担</li>
</ul>
</li>
<li>前身的技术
<ul>
<li><a href="http://lamport.azurewebsites.net/pubs/lamport-paxos.pdf">Lamport兼职议会算法</a>（Lamport part-time Parliament Algorithm）</li>
<li><a href="http://zoo.cs.yale.edu/classes/cs422/2011/bib/terry95managing.pdf">Bayou复制存储系统</a></li>
<li>无类别域间IP路由算法</li>
</ul>
</li>
<li>三代技术
<ul>
<li>第一代：音乐文件交换服务。<a href="https://en.wikipedia.org/wiki/Napster">Napster</a></li>
<li>第二代：文件共享型的更大伸缩性，匿名使用能够，具有容错机制。<a href="https://freenetproject.org/">Freenet</a>, <a href="https://en.wikipedia.org/wiki/Gnutella">Gnutella</a>, <a href="https://en.wikipedia.org/wiki/Kazaa">Kazaa</a>, <a href="https://en.wikipedia.org/wiki/BitTorrent">BitTorrent</a></li>
<li>第三代：对等中间件。全球范围内管理与应用无关的分布式资源。<a href="https://en.wikipedia.org/wiki/Pastry_(DHT)">Pastry</a>, <a href="https://en.wikipedia.org/wiki/Tapestry_(DHT)">Tapestry</a>, CAN, Chord, Kademlia</li>
</ul>
</li>
<li>对等中间件
<ul>
<li>关键：快速高效的索引方式 - 第一代是集中式索引，第二代是分区和分布式索引</li>
<li>需求
<ul>
<li>功能需求</li>
<li>非功能性需求
<ul>
<li>全国可伸缩性</li>
<li>负载均衡</li>
<li>优化相邻节点间的本地交互</li>
<li>适应高度动态的主机可用性</li>
</ul>
</li>
<li>安全考量
<ul>
<li>能够在具有不同信任体系的环境下保持数据的安全性</li>
<li>匿名，可否认能力和对审查的抵抗</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>路由覆盖</strong> (routing overlay) —— 定位节点和对象 —— 有时候也叫做DHT
<ul>
<li><a href="http://www.cs.kent.edu/%7Ejaved/class-FP2P10S/papers-2006/P2P-plaxton-1.pdf">早期论文</a></li>
<li>任务
<ul>
<li>路由请求给对象</li>
<li>插入对象</li>
<li>删除对象</li>
<li>节点的增加和移除</li>
</ul>
</li>
<li>分布式对象定位和路由(DOLR) ——　实现一个更加灵活的接口</li>
<li>几种常见算法
<ul>
<li>Pastry与Tapestry采取前缀路由(prefix routing): 对GUID进行二进制掩码, 逐级跳转</li>
<li>Chord: 根据选择节点和目标节点的GUID在数值上的不同作出选择</li>
<li>CAN: 将节点放入d维空间，并使用d维空间的结点之间的距离</li>
<li>Kademlia: 异或距离算法</li>
</ul>
</li>
</ul>
</li>
</ul>
<a class="header" href="#a安全性" id="a安全性"><h3>安全性</h3></a>
<ul>
<li>假设最坏情形和设计指南
<ul>
<li>接口是外露的</li>
<li>网络是不安全的</li>
<li>限制秘密信息的生存周期和范围</li>
<li>攻击者可以获取算法和程序代码</li>
<li>攻击者也许能访问到大量的资源</li>
<li>最小化可信基</li>
</ul>
</li>
<li>密码学在安全系统中应用
<ul>
<li>场景1: 用共享的密钥进行通信</li>
<li>场景2: 和服务器间的认证通信</li>
<li>场景3: 使用公钥的认证通信</li>
<li>场景4: 使用安全摘要函数的数字签名</li>
</ul>
</li>
</ul>
<a class="header" href="#a分布式文件系统" id="a分布式文件系统"><h3>分布式文件系统</h3></a>
<p>...</p>
<a class="header" href="#a名字服务" id="a名字服务"><h3>名字服务</h3></a>
<p>DNS, GNS(全局名字服务), X.500目录服务(包括 LDAP)</p>
<a class="header" href="#a时间和全局状态" id="a时间和全局状态"><h3>时间和全局状态</h3></a>
<ul>
<li>时钟：物理时钟。给一系列的事件打上时间戳，条件是时钟分辨率(时钟值更新的周期)比连续事件之间的时间间隔小</li>
<li>时钟偏移(clock skew): 两个时钟瞬间的不同</li>
<li>时间漂移率(clock drift rate): 指与完美时钟之间的偏移量</li>
<li>通用协调时间(Coordinated Universal Time, UTC)：基于原子振荡器技术的国际原子时间(International Atomic Time)为基准，增加了偶尔增加删除闰秒，以便同天文时间保持一致。</li>
<li>同步物理时钟：
<ul>
<li>外部同步</li>
<li>内部同步</li>
</ul>
</li>
<li>同步时钟的算法
<ul>
<li>同步系统中的同步。可以简单设置 t = t + (max + min) / 2</li>
<li>Cristian算法。使用外部的时间服务器</li>
<li>Berkeley算法。需要一个时间协调主机，收到所有从属机的时间，算出他们的偏移量（容错平均值）发送回去 —— Bitcoin在用</li>
<li>网络时间协议
<ul>
<li>提供一个服务，使得跨互联网的用户能精确地与UTC同步 —— 过滤时序数据的统计技术</li>
<li>提供一个能在漫长的连接丢失中生存的可靠服务 —— 提供冗余的可选择服务器</li>
<li>提供保护，防止时间服务的干扰，无论是恶意的还是偶然的 —— 认证技术</li>
<li>金字塔形状的分级服务器</li>
</ul>
</li>
</ul>
</li>
<li>逻辑时间和逻辑时钟 —— Lamport
<ul>
<li>逻辑时间
<ul>
<li>如果两个事件发生在同一个进程Pi(i=1, 2, ..., N), 那么他们发生的顺序是Pi观察到的顺序，即我们上面定义的顺序 -&gt;i</li>
<li>当消息在不同进程之间发送时，发送消息的事件在接收消息的事件之前发送</li>
<li>上面两种关系得到的偏序称为发生在先关系，或者叫做因果序或潜在的因果序</li>
</ul>
</li>
<li>逻辑时钟
<ul>
<li>单调增长的软件计数器，每个进程维护自己的逻辑时钟，并给事件加上Lamport时间戳(Lamport timestamp)</li>
<li>全序逻辑时钟：定义(Ti, i),Ti是i事件的Lamport时间戳, 当Ti &lt;= Tj, i&lt;j时，(Ti, i) &lt; (Tj, j)</li>
</ul>
</li>
<li>向量时钟 —— 矩阵时钟(matrix clock)</li>
</ul>
</li>
<li>全局调试
<ul>
<li>分布式无用单元收集 —— 不再有任何引用的对象，包括信道的状态和进程的状态</li>
<li>分布式死锁检测 —— 两个进程相互等待</li>
<li>分布式终止检测 —— 检测分布式算法是否终止
<ul>
<li>死锁只影响系统中的进程子集，而终止是所有进程的</li>
<li>进程被动性与死锁循环中的等待不一样：死锁进程试图执行进一步的动作，该动作是另一个进程在等待的；一个被动的进程不参与任何活动</li>
</ul>
</li>
<li>分布式调试 —— Marzullo和Neiger算法</li>
</ul>
</li>
<li>全局状态(global state)和一致割集(cut)
<ul>
<li>全局历史(global history)是每个进程的事件历史的并集</li>
<li>取全局历史中的任意一个事件，都能得到当前的全局状态</li>
<li>割集(cut)是全局历史的子集，该状态下每个进程的最后一个事件构成了割集的边界(frontier)</li>
<li>割集的一致与不一致: 无原因而有结果是不一致(inconsistent)，但无结果而有原因是一致(consistent)</li>
<li>一致割集的状态称为一致的全局状态(consistent global state)</li>
<li>我们可以把分布式系统描述成一致的全局状态的一系列推进或转化</li>
<li>走向(run)是全局历史中所有事件的全序</li>
<li>线性化走向或一致的走向不仅全局历史中所有事件的全序，而且与H上发生在先关系是一致的</li>
<li>我们可以在线性化走向中交换两个并发事件的顺序，得到的走向仍是经历一致全局状态的走向</li>
<li>全局状态谓词
<ul>
<li>稳定的： { True, False }</li>
<li>相关概念
<ul>
<li>安全性: 假设a是成为死锁的性质，则安全性是一个断言：从所有S0状态到S的状态，a值是False</li>
<li>活性: 假设b是系统应该有的性质，则任一从状态S0开始的线性化走向L, 可从S0到达S, b值是True</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Chandy和Lamport的“快照”算法</strong>
<ul>
<li>假设
<ul>
<li>无论是通道还是进程都不出现故障</li>
<li>通道是单向，提供FIFO顺序的消息传递</li>
<li>描述进程和通道间的图是强连接的(任意两个进程间至少有一条通道)</li>
<li>任一进程可以在任一时间开始一个全局快照</li>
<li>在拍快照时，进程可以继续他们的执行，并发送和接收消息</li>
</ul>
</li>
<li>通道
<ul>
<li>接入通道(incoming channel)</li>
<li>外出通道(outgoing channel)</li>
</ul>
</li>
<li>基本思想
<ul>
<li>每个进程记录它的状态，对每个接入通道还记录发送给它的消息。对每个通道，进程记录下在它自己记录下状态之后和在发送方记录下它自己状态之前到达的任何消息。这种方式可以记录不同时间的进程状态并且能用已传达但还没有接收到的消息说明进程状态之间的差别。如果进程Pi已经向进程Pj发送了消息m，但Pj还没有收到，那么m属于他们之间通道的状态</li>
</ul>
</li>
<li>标记(marker)消息
<ul>
<li>作用
<ul>
<li>如果接收者还没有保存自己的状态，那么标记作为提示</li>
<li>作为一种决定哪个消息包括在通道状态中的手段</li>
</ul>
</li>
</ul>
</li>
<li>规则
<ul>
<li>标记接收规则：强制进程在记录下自己的状态之后但在它们发送其他消息之前发送一个标记</li>
<li>标记发送规则：强制没有记录状态的进程去记录状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>// Chandy 和 Lamport的快照算法
进程Pi的标记接收规则
Pi接收通道c上的标记消息
  if (Pi还没有记录它的状态)
    Pi记录它的进程状态
    将c的状态记成空集
    开始记录从其他接入通道上到达的消息
  else
    Pi把c的状态记录成从保存其他状态以来它在c上接收到的消息的集合
  endif

进程Pi的标记发送规则
  在Pi记录了其状态之后，对每个外出通道c:
    (在Pi从c上发送任何其他消息之前)
    Pi在c上发送一个标记消息
</code></pre>
<a class="header" href="#a协调与协定" id="a协调与协定"><h3>协调与协定</h3></a>
<ul>
<li>关于分布式系统是异步的还是同步的。在异步系统中不做时序上的假设，在同步系统中，我们假设消息传送的最大延迟，进程的每步运行时间以及时钟漂移率都有约束，这些同步假设允许我们用超时来检测进程崩溃。</li>
<li><strong>即使在良性故障条件下，在异步系统中也不可能保证一组进程能对一个共享值达成协定。</strong></li>
<li>不可靠故障检测器(unreliable failure detector)和可靠故障检测器(reliable failure detector)</li>
</ul>
<a class="header" href="#a分布式互斥" id="a分布式互斥"><h4>分布式互斥</h4></a>
<p>一个仅基于消息传送的解决方案。</p>
<a class="header" href="#a互斥算法" id="a互斥算法"><h5><em>互斥算法</em></h5></a>
<ul>
<li>协议
<ul>
<li>entry() -&gt; 进入临界区，如果必须可以阻塞进入</li>
<li>resourceAccesses() -&gt; 在临界区访问共享资源</li>
<li>exit() -&gt; 离开临界区，其他进程现在可以进入</li>
</ul>
</li>
<li>基本要求
<ul>
<li>ME1：安全性 =&gt; 在临界区(CS)一次最多有一个进程可以执行</li>
<li>ME2：活性 =&gt; 进入和离开临界区的请求最终成功执行 =&gt; 无死锁也无饥饿问题（还关乎公平性问题=&gt;在先顺序）</li>
<li>ME3：顺序 =&gt; 如果一个进入CS的请求发生在先，那么进入CS时仍按此顺序</li>
</ul>
</li>
<li>评价性能的标准
<ul>
<li>消耗的带宽(bandwidth)，与在每个entry和exit操作中发送的消息数成比例</li>
<li>每一次entry和exit操作由进程导致的客户延迟</li>
<li>算法对系统吞吐量(throughput)的影响。我们用一个进程离开临界区和下一个进程进入临界区之间的同时延时(synchronization delay)来衡量着这个影响，当延迟较短时，吞吐量较大。</li>
</ul>
</li>
<li><strong>中央服务器算法</strong>
<ul>
<li>使用一个服务器来授予进入临界区的许可，包含一个请求(request)消息和授权(grant)消息</li>
<li>性能的同步延迟取决于下面两个消息往返一次要花费的时间</li>
</ul>
</li>
<li><strong>基于环的算法</strong>
<ul>
<li>所有的进程组成一个环，当环线顺序，当轮到该进程时候，进程需要使用令牌的话就使用，不使用的化就传给相邻的进程</li>
<li>同步延迟可能是 1 ~ N (N是进程数目)</li>
</ul>
</li>
<li><strong>使用组播和逻辑时钟的算法</strong> —— Richat, Agrawala
<pre><code>//算法描述
初始化:
    state = RELEASED;
为了进入临界区:
    state = WANTED;
    组播请求给所有进程;
    T = 请求的时间戳;
    wait until (接收的应答数=(N-1));
    state=HELD;
接收到Pj请求&lt;Ti, Pi&gt;:
    if (state=HELD) or (state=WANTED and (T, Pj) &lt; (Ti, Pi)):
        将请求Pi放入队列，不给出应答;
    else:
        马上给Pi应答;
为了退出临界区:
    state = RELEASED;
    对队列中的请求作出应答;
</code></pre>
<ul>
<li>同步延迟仅仅是一个消息的时间</li>
<li>带宽消耗2(N-1), 请求进入的客户端延迟为一个往返时间</li>
</ul>
</li>
<li><strong>Maekawa投票算法</strong>
<ul>
<li>分组要求：两两分组至少有一个重叠的成员，最优解是N^1/2</li>
<li>确认是否可行，只需要跟同组成员沟通，即可确认是否可以进入</li>
<li>消息量减少到2N^1/2</li>
<li>同步延迟是一个消息的往返时间
<img src="../static/maekawa_group.png" alt="Maekawa Group" /></li>
</ul>
</li>
</ul>
<a class="header" href="#a选举" id="a选举"><h4>选举</h4></a>
<p>选择一个唯一的进程来扮演特定角色的算法称为<strong>选举算法</strong>(election algorithm)。我们使用总的网络带宽(与发送消息总数成正比)和算法的回转时间(从启动算法到终止算法之间的串行消息传输的次数)来衡量一个选举算法的性能。</p>
<ul>
<li><strong>基于环的选举算法</strong> —— Chang, Roberts
<ul>
<li>安装逻辑顺序排列成一个环。消息只是通过相邻的顺序传递下去。选举是异步的，目标是选出一个协调者(coordinator) —— 最大标识符的进程</li>
<li>过程
<ol>
<li>初始时候，所有进程都是非参与者，当一个进程开始选举时，将自己标记为选举者，将自己的标识放到消息中去，传递给邻居</li>
<li>当进程收到一个选举消息，和自己的标识比较大小，如果对方标识大的化，传递给邻居；如果较小，此时，如果接收进程不是一个参与者，就标记自己是参与者，用自己的替换并转发消息，如果是一个参与者，就不用管。</li>
<li>如果收到的标识符是自己的，那么此时自己就成为了协调者，协调者再次把自己标记为非参与者，并向邻居发送一条当选消息。</li>
<li>当进程收到当选消息时，标记自己是非参与者，将自己的印记i放到消息中，传递给邻居。</li>
<li>消息量最大为3N-1, 也就是说发起者逆时针邻居是最大的标识符人，他也要发送一轮，这样就2N-1，最后的当选消息还有一轮N。</li>
</ol>
</li>
</ul>
</li>
<li><strong>霸道算法</strong> —— Garcia-Molina
<ul>
<li>假设：每个进程知道哪些进程有更大的标识符，并且可以和所有这些进程通信</li>
<li>三种消息：选举消息用于宣布选举，应答消息用于回复选举消息，协调者消息用户宣布当选进程的身份</li>
<li>检测超时：同步系统，最大消息传输延迟为T(trans)，最大消息处理延迟T(process) =&gt; T = 2T(trans) + T(process)</li>
<li>过程：
<ol>
<li>假设A认为自己是一个最大标识符的进程，发起了一次协调者消息，如果在T内没有反对的声音，就认为自己是协调者，发送一次当选消息给所有人</li>
<li>A检测到当前的协调者出现了故障，就对其他人发起了一次选举消息，其他人会对这些消息进行应答</li>
<li>不同应答的人再次发起选举消息，等待别人的应答，以确定自己是否可以发起协调者消息</li>
</ol>
</li>
</ul>
</li>
</ul>
<a class="header" href="#a组通信中的协调与协定" id="a组通信中的协调与协定"><h4>组通信中的协调与协定</h4></a>
<p>一条消息可以根据某种在可靠性和顺序策略方面的保证来传递给组内的所有成员。特别倾向于基于有效性，完整性和协定的可靠性，以及基于FIFO排序(FIFO ordering)，因果排序(causal ordering)和全排序(total ordering)的排序。操作multicast(g, m)发送消息m给进程组g的所有成员。相应地，操作deliver(m)传递由组播发送的消息到调用进程。每个消息m携带发送它的进程sender(m)的唯一标识符和唯一目的组标识符group(m)。</p>
<a class="header" href="#a基本组播" id="a基本组播"><h5>基本组播</h5></a>
<p>只要组播进程不崩溃，一个正确的进程最终会传递消息，我们把这种原语称为 B-muliticast, 与之对应的是 B-deliver。最简单的是send操作，这样会导致ack-implosion确认爆炸，也可以使用IP组播来实现。</p>
<a class="header" href="#a可靠组播--hadziacostoueg1994-chandratoueg1996" id="a可靠组播--hadziacostoueg1994-chandratoueg1996"><h5>可靠组播 —— Hadziacos&amp;Toueg[1994], Chandra&amp;Toueg[1996]</h5></a>
<ul>
<li>可靠组播(reliable multicast), 相应的操作R-multicast, R-deliver</li>
<li>性质：
<ul>
<li>完整性(integrity)</li>
<li>有效性(validity)</li>
<li>协定(agreement): 要求如果组中任何一个进程收到一个消息，那么组中所有正确的进程都必须收到这个消息 ——　原子性相关（都有或都没有）</li>
</ul>
</li>
<li>实现：
<ul>
<li>B-multicast
<pre><code>//可靠组播算法
初始化:
    Received = {}
进程P为了将R-multicast消息m发送给组g：
    B-multicast(g, m)
在进程q执行B-deliver(m)时，其中g=group(m)
    if (m not in Received):
        Received += {m}
            if (q != p):
                B-multicast(g, m)
            endif
        R-deliver m
    endif
</code></pre>
</li>
<li>IP组播实现：IP组播，捎带确认法（确认附加在其他消息上）和否认确定结合使用
<ul>
<li>进程不单独发送确认消息，而是在发给其他组内消息中附加上</li>
<li>只有当进程检测到漏掉消息时，才会发送一个单独的应答消息，指出一个预期的消息没有到达，这种应答消息称为否认确定</li>
</ul>
</li>
</ul>
</li>
</ul>
<a class="header" href="#a有序组播" id="a有序组播"><h5>有序组播</h5></a>
<ul>
<li>FIFO排序</li>
<li>因果排序</li>
<li>全排序-&gt;偏序</li>
</ul>
<a class="header" href="#a共识和相关问题" id="a共识和相关问题"><h4>共识和相关问题</h4></a>
<ul>
<li>系统模型
<ul>
<li>满足条件
<ul>
<li>终止性：每个正确的进程最终设置它的决定变量</li>
<li>协定性：所有正确进程的决定值都相同 =&gt; 一致性</li>
<li>完整性：如果正确的进程都提议同一个值，那么处在决定状态的任何正确进程那个已选择了该值 =&gt; 有效性</li>
</ul>
</li>
<li>拜占庭将军问题</li>
<li>共识问题</li>
</ul>
</li>
</ul>
<a class="header" href="#swirlds-hashgraph" id="swirlds-hashgraph"><h2>SWIRLDS HASHGRAPH</h2></a>
<a class="header" href="#a共识协议-公平快速拜占庭容错" id="a共识协议-公平快速拜占庭容错"><h3>共识协议: 公平，快速，拜占庭容错</h3></a>
<p>LEEMON BAIRD
MAY 31, 2016
SWIRLDS TECH REPORT SWIRLDS-TR-2016-01</p>
<a class="header" href="#a摘要" id="a摘要"><h3>摘要</h3></a>
<p>一个新的系统，Swirlds散列图共识算法，被提议用于保证拜占庭容错的复制状态机。它实现了公平性，因为攻击者很难操纵两个交易中的哪一个将被选为第一个这样的的共识顺序。它具有完全的异步性，没有领导者，没有轮询，没有工作证明，最终以同样的概率达成一致，并且在没有缺陷的情况下高速运转。它基于gossip协议，其中参与者不只是传播交易。他们传播gossip。他们共同构建一个反映所有gossip事件的散列图。这使得拜占庭协议可以通过虚拟投票来实现。Alice不会通过互联网向Bob投票。相反，Bob根据他对Alice的了解，计算Alice将投什么票。这对所有交易的总订单产生了公平的拜占庭协议，除了交易本身之外，通信开销很少。</p>
<p>关键词：拜占庭，拜占庭协议，拜占庭容错，复制状态机，公平，公平，哈希图，关于传播gossip，虚拟投票，Swirlds</p>
<a class="header" href="#a内容" id="a内容"><h3>内容</h3></a>
<p>List of Figures</p>
<ol>
<li>Introduction 介绍</li>
<li>Core concepts 核心概念</li>
<li>Gossip about gossip: the hashgraph 传播gossip: 哈希图</li>
<li>Consensus algorithm 共识算法</li>
<li>Proof of Byzantine fault tolerance 拜占庭容错证明</li>
<li>Fairness 公平性</li>
<li>Generalizations and enhancements 概括和增强</li>
<li>Conclusions 结论</li>
</ol>
<a class="header" href="#references-参考" id="references-参考"><h3>References 参考</h3></a>
<ol start="9">
<li>Appendix A: Consensus algorithm in functional form</li>
</ol>
<a class="header" href="#list-of-figures-图表列表" id="list-of-figures-图表列表"><h3>List of Figures 图表列表</h3></a>
<ol>
<li>Gossip history as a directed graph</li>
<li>The hashgraph data structure</li>
<li>Illustration of strongly seeing.</li>
<li>Pseudocode: the Swirlds hashgraph consensus algorithm</li>
<li>Pseudocode: the divideRounds procedure</li>
<li>Pseudocode: the decideFame procedure</li>
<li>Pseudocode: the finalOrder procedure</li>
</ol>
<a class="header" href="#a1-介绍" id="a1-介绍"><h2>1. 介绍</h2></a>
<p>分布式数据库通常需要具有拜占庭容错的复制状态机。一些作者用“拜占庭”这个术语来表示软弱，例如假设攻击者不会串通，或者沟通是弱的异步。在本文中，“拜占庭”将以使用其原始定义的强烈意义：成员中只有不到1/3的成员可以成为攻击者，他们可以勾结，并且在没有消息延迟的限制下，可以删除或延迟诚实成员之间的信息。攻击者可以控制网络来延迟和删除任何消息，尽管在任何时候，如果一个诚实的成员多次向另一个成员发送消息，攻击者最终必须允许其中一个通过。假设存在安全的数字签名，那攻击者不能无法不留痕迹地修改消息。假定存在安全的散列函数，那这些散列函数永远不会冲突。本文提出并描述了Swirlds散列图的共识算法，并在强烈的定义下证明了拜占庭容错性。
FLP定理说明：没有一个完全确定性的拜占庭系统是完全异步的，无限的消息延迟，并且仍然保证达成共识。但是非确定性系统有可能以同样的概率达成共识。哈希图共识算法是完全异步的，是非确定性的，并且以相同的概率实现拜占庭协议。
一些系统，如Paxos或Raft使用领导者，如果攻击者对当前领导者发起拒绝服务攻击，他们可能会使他们容易遭受大量延迟。很多系统甚至可能被一个坏客户推迟。事实上，后面的文章表明，具有这种漏洞的系统可能更好地被描述为“拜占庭故障可存活”而不是“拜占庭容错”。哈希图共识不使用领导者，并且能够适应对小型的成员子集进行攻击。
其他系统（比如比特币）则基于工作的区块链验证。这避免了所有上述问题。然而，这样的系统不是拜占庭式的，因为一个成员从来不知道何时达成共识，他们只能随着时间的推移, 从而信任某个结果。如果两个区块同时开采，那么该链就会分叉，直到社区都同意延伸哪个分支。如果块缓慢添加，社区总是选择更长的分支，其他分支将停止增长，并且可以修剪和丢弃，因为它是“陈旧”的。这会导致效率低下，虽然某些区块开采得当，但无论如何都会被丢弃。这也意味着有必要放慢块开采的速度，以便社区能够共同选择分叉，而不是一直创建新分叉。这是工作证明的目的。通过要求矿工解决一个困难的计算问题来挖掘一个区块，它可以确保整个网络在采矿之间平均具有足够长的延迟。哈希图共识算法相当于一个块链，其中“链”不断地分支，没有任何修剪，没有任何块过时，并且允许每个矿工每秒钟挖掘许多新块，而没有工作证明和100％的效率。
工作量证明的区块链还要求额外计算，浪费电力，并且可能需要购买昂贵的采矿设备。通过使用长时间延迟的可信硬件芯片，一个过期时间证明系统可以避免浪费的电力（尽管可能不是开采工具的成本），就好像他们正在进行工作证明的计算一样。但是，这要求所有参与者相信创建该芯片的公司。这种对芯片厂商的信任在某些情况下存在，但在其他情况下则不存在，例如当FreeBSD被更改为不仅仅依靠硬件RDRAND指令获取安全随机数时，因为“我们不能再相信它们了”。
拜占庭协议系统为避免上述问题，制定了该拜占庭协议。这些系统通常交换许多信息供会员投票。对于n个成员来决定单个YES/NO问题，有些系统可能需要 O（n）个消息需要通过网络发送。其他系统可能需要O（n^2），或者甚至O（n^3）个消息，每个二进制决策通过网络。然后可以扩展单个YES/NO决策的算法来决定一组交易的总订单，这可能进一步增加投票流量。哈希图在整个网络上都没有投票，因为所有投票都是虚拟的。</p>
<a class="header" href="#a2-核心概念" id="a2-核心概念"><h2>2. 核心概念</h2></a>
<p>哈希图共识算法包括下面这些核心概念:</p>
<ul>
<li>交易: 任何人都可以在任何时刻创建新的签名交易。所有人都会有此交易的完整拷贝，社区将会对这些交易的排序达成共识。</li>
<li>公平性：少数攻击者难以不公平地影响被选为共识的交易顺序。</li>
<li>Gossip：信息会由每位成员随机选择另一名成员，并告诉他们所有的自己知道的信息。</li>
<li>哈希图：一种记录了每个人传播的gossip记录和顺序的数据结构。</li>
<li>关于gossip的gossip：哈希图是通过gossip协议传播的。被传播的是gossip本身的历史，所以这是gossip about gossip。这仅仅使用非常少的带宽开销，而且不仅仅是在单纯地传播gossip事件。</li>
<li>虚拟投票：每个成员都有一个散列图的副本，所以如果Alice运行着正常的拜占庭协议协议（包括发送投票），Alice可以计算Bob将给她发送了什么投票。所以鲍勃不需要真正的投票。每个成员都可以就任何的决定达成拜占庭协议，而无需发送任何一次投票。散列图本身就足够了。因此，零带宽使用，不仅仅是在简单地传播hashgraph。</li>
<li>著名的证人：社区可以通过收集 O（n log n）个关于 “是/否事件x在事件y之前出现” 的是/否问题，进行运行单独的拜占庭协议协议，将n个事务列表排序。更快的方法是只挑选几个事件（散列图中的顶点），称为证人，并且如果散列图显示大多数成员在创建后很短时间内收到它，则定义一个有名的证人。仅仅为证人运行拜占庭协议协议就足够了，为每个证人决定单个问题“这个证人是否出名？”。一旦拜占庭就一组固定的证人达成协议，就很容易从哈希图中得出所有事件的公平的总订单。</li>
<li>强连接：给定散列图中的任何两个顶点x和y，可以立即计算出x是否强连接y，如果它们通过经过足够多成员的多个有向路径连接，则将其定义为真。这个概念可以证明关键定理：如果Alice和Bob都能够计算Carol在给定问题上的虚拟投票，那么Alice和Bob会得到相同的答案。这个定理形成了拜占庭与概率一致的数学证明的基础。</li>
</ul>
<p>图1.
Gossip历史是一个有向图。任何Gossip历史都可以用一个图来表示，每一个成员都是一个顶点。当Alice收到Bob的gossip时，告诉她他所知道的一切，这个gossip事件由Alice列中的一个顶点表示，其中两条边向下延伸到Alice和Bob的紧接着的前面的gossip事件。</p>
<a class="header" href="#a3-关于gossip的gossip哈希图" id="a3-关于gossip的gossip哈希图"><h2>3. 关于gossip的gossip：哈希图</h2></a>
<p>哈希图共识算法使用一个gossip协议。这意味着像Alice这样的成员会随机选择另一个成员，比如Bob，然后Alice会告诉Bob她知道的所有信息。 Alice然后重复这样的操作，选择一个随机的成员。Bob反复做这样的事情，同时，其他成员也会这样做。通过这种方式，如果一个成员接到新信息，它就会以指数形式快速传播到整个社区，直到每个成员都意识到这一点。
任何gossip协议的历史都可以用像图1这样的有向图来说明。Alice列中的每个顶点表示一个gossip事件。例如，Alice列中的顶级事件表示了Bob向Alice发送了一个gossip同步，Bob在其中告知了他所知道的所有信息。该顶点有两个向下的连线，连接到Alice和Bob的最前面的gossip。时间在图形中流动，所以较低的顶点表示历史中较早的事件。在一个典型的gossip协议中，像这样的图只是用来讨论协议;实质上这个图形并没有存储在任何地方形。
在哈希图共识中，图是实际上的数据结构。图2说明了这个数据结构。每个事件（顶点）都以字节序列的形式存储在内存中，由其创建者签名。例如，Alice（红色）的一个事件记录了Bob执行了gossip同步的事实，在该事实中，他向她发送了他所知道的一切。此事件由Alice创建并由她签名，并包含另外两个事件的散列：她的最后一个事件和Bob在该gossip同步之前的最后一个事件。红色事件还可以包含Alice选择在那个时候创建​​的任何事务的有效载荷，并且可能包含一个时间戳，即Alice声明创建它的时间和日期。该事件的其他祖先（灰色）不包含在其中，而是由一组密码哈希确定。具有散列图的这种数据结构已经被用于其他的地方，例如Git中的顶点是文件树的版本，边表示文件的更改。但Git并没有存储成员是如何沟通的这种记录。哈希表有自己的实现目的，就是记录下成员之间沟通的历史。
gossip协议被广泛用于传输各种类型的信息。他们可能会涉及传播用户身份，传播交易，传播区块链，或传播其他需要分发的信息。但如何定义关于gossip的gossip协议？如果成员们传播传递哈希图本身呢？当Bob向Alice传播时，他会把所有他知道但她不知道的事件都给她。
传播哈希图给参与者很多信息。如果一个新事件被放置在事件的有效载荷中，它将很快传播至所有成员那，直到每个成员都知道。Alice在接受这笔交易时。她会知道Bob是何时才知道这笔交易。同时她也会确切地知道Carol是何时知道Bob已经知道这笔交易的事实。当所有成员都有散列图的副本时，这种深层次的链推理就成为可能。随着哈希函数向上增长，不同的成员可能会在顶部附近的关于新事件的子集上略有不同，但它们将迅速收敛到一个在哈希图中具有完全相同的事件的状态。此外，如果Alice和Bob碰巧都有一个特定的事件，那么他们也保证都拥有其所有的祖先。他们也会同意这些祖先的所有子图的所有连线。所有这些都是在本地运行的强大的算法，包括拜占庭容错。
这种能力带来的通信开销很小。如果社区只是传播他们创建的签名交易，则需要一定数量的带宽。如果他们只是在传播散列图，并且如果在足够多的事务中，有一个典型事件中至少包含一笔交易，则开销很小。她不会签署她创建的交易，她只会签署她创建的事件来包含该交易。无论哪种方式，她只发送一个签名。换句话说，无论如何，她必须自己发送交易。唯一额外的开销就是她必须发送这两个哈希值。但即使这样也可以压缩处理。在图2中，Alice不会向Carol发送红色事件，直到Carol已经拥有其所有早期祖先（不论是来自Alice还是早先与其他人同步）之后。所以Alice不需要发送两个蓝色父事件的两个哈希值。告诉Carol这个事件是Alice的下一个事件就足够了，并且它的另一个父母是Bob的第三个事件。通过适当的压缩，这可以以很少的字节发送，仅增加发送消息的几个百分比来的大小。</p>
<a class="header" href="#a4-共识算法" id="a4-共识算法"><h2>4. 共识算法</h2></a>
<p>确保每个成员都知道每一个事件是不够的，还需要就事件的线性排序以及事件内记录的交易达成一致。大多数没有领导者的拜占庭容错协议取决于每个人成员告知所有人他们的投票结果。因此，对于n个成员就单个YES/NO问题达成一致而言，可能需要通过网络发送O(n^2)个投票消息，因为每个成员都需要告诉其他成员投票结果。其中一些协议要求收到发给每个人的选票，使其成为O(n^3)。他们可能需要多轮投票，这进一步增加了发送的投票消息的数量。</p>
<p>图2.
哈希图数据结构。Alice创建一个事件（红色），记录Bob对她做的传播同步的事件，并告诉她他知道的一切。该事件包含两个父事件（蓝色）的散列：由同一个创建者Alice创建的父母（深蓝色），以及Bob创建的另一个父母（浅蓝色）。它还包含Alice当时选择创建的任何新交易的有效载荷，以及Alice的数字签名。其他祖先事件（灰色）不存储在红色事件中，但它们由所有哈希确定。其他自我祖先（深灰色）可以通过自我亲缘关系序列到达，其他祖先（浅灰色）则不是。</p>
<p>哈希图共识不需要发送任何投票。每个成员都有散列图的副本。如果Alice和Bob都具有相同的散列图，那么他们可以根据该散列图，通过函数计算并确定下所有事件的顺序，并且它们都会得到相同的答案。因此，即使不发送投票信息，也能达成共识。
当然，在某个特定时刻，Alice和Bob可能没有完全相同的哈希图。他们通常会在较早的事件中达成一致，但对于最近的事件，互相可能还没有完全同步。此外，有时可能会向社区发布一个新事件，该事件被放置在散列图中较低（较早）的位置。哈希图形共识算法使用被认为最好的虚拟投票系统来处理这些问题。
假设Alice具有散列图A和Bob散列图B。这些哈希图在任何给定的时刻都可能稍有不同，但它们将始终保持一致。一致意味着如果A和B都包含事件x，那么它们都将包含与x完全相同的一组祖先，并且都包含这些祖先之间完全相同的一组边。如果Alice知道x而Bob不知道，并且他们都诚实并积极参与，那么我们相信Bob会通过gossip协议很快地接收到x。共识算法假设最终会发生，但不会对其发生速度做出任何假设。该协议是完全异步的，并没有对超时时间，传播速度或进度进行假设。
Alice将通过一系列的选举计算来确定A中事件的总顺序。在每次选举中，A中的一些事件将被视为投票，同时A中的一些事件将被视为接受该投票。Alice将多次计算选举，因为某一事件可能参加一些选举而不参与其他选举，并可能在不同的选举中投不同的选票。如果这个事件是由Bob创建的，我们将会讨论Bob在特定选举中以某种方式进行了投票。但实际的鲍勃不参与。这完全是Alice在本地执行的计算，她计算出Bob发送出去的投票数。当然这建立在真的是Bob通过互联网向她投票的基础上。</p>
<p>图3.
强烈看到的插图。在每个哈希图中，顶部的黄色事件可以强烈地看到底部行中的一个橙色事件。有n = 5个成员，所以大于2n / 3的最小整数是4。在（d）中，一个事件（橙色）是不同创建者（红色）的4个中间事件中的每一个的祖先，每个事件都是黄色事件的祖先。因此，黄色事件可以强烈地看到橙色事件。 其他每个哈希图都被着色，以显示底行不同的橙色事件，黄色事件至少会看到4个红色事件。如果所有4个橙色事件和黄色事件的父母都创建了一轮r，则在r + 1轮创建黄色，因为它可以强烈地看到r轮中由不同成员创建的超过2n / 3个证人。请注意，每个事件都被定义为自己的祖先和自我祖先。</p>
<p>这个虚拟投票有几个好处。除了节省带宽之外，它还确保成员总能够按照规则计算他们的投票。如果Alice是诚实的，她会真实地计算出Bob所做出的虚拟投票。即使真正的Bob是个骗子，他也不能通过虚假的虚拟投票来攻击Alice。
Bob可以尝试以不同的方式作弊。假设Bob创建一个事件x，其中自身父事件指向他以前的事件z。然后Bob创建一个新的事件y，也将自身父事件指向了z，而不是指向x。这意味着Bob在哈希图中的事件将不再是一个链。他们现在将成为一棵树，因为他创造了一个分叉。如果Bob将x传给Alice，然后y传给Carol，那么一段时间后，Alice和Carol可能还没有意识到这个分叉。这个时候，爱丽丝计算出来的关于x的虚拟投票，与Carol对y的虚拟投票计算结果不同。
哈希图的一致性算法通过使用一种状态观念来看一个状态这种方式来防止这种攻击，并且一个状态的观念是可以强烈地看到另一个状态的。这些基于对祖先和自我祖先的定义，以致每个事件都被认为是自己的祖先和自我祖先。##译者注
如果Bob创建两个事件x和y，这两个事件都不是另一个的自我祖先，那么Bob就会被分叉作弊。如果某个事件w有x作为祖先，但没有y作为祖先，那么事件w可以看到事件x。然而，如果x和y都是w的祖先，那么w被定义为不会看到它们中的任何一个，也不会被同一个创建者看到任何其他事件。换句话说，如果x能够看到w的话，w可以看到x，而且不知道是谁创建了分叉。
如果有n个成员，那么事件w可以强烈地看到事件x，如果w可以看到不同成员的超过2n/3个事件，其中每个成员都可以看到x。这个概念如图3所示。该图显示了相同哈希图的四个副本，每个在底部行上以不同的事件着橙色。在（d）中，顶部的黄色事件可以由不同的成员看到4个红色事件，每个事件都可以在底部看到橙色事件。（a），（b）和（c）中也是如此，其中（a）实际上有5个红色事件。但只有4个人需要强烈观察，因为这个例子有n = 5个成员，大于2n / 3的最小整数是4。
这个概念允许一个协议通过本地虚拟投票而无需任何实际投票就能实现拜占庭容错。
在虚拟投票中，在事件x中，对某个YES/NO问题进行了投票（例如，不管事件是否有名），投票计算纯粹是作为x的祖先的函数。如果w可以强烈地看到x，则该投票仅被认为是从x可以连接到它的后代事件w。在第5节中证明，如果x和y在不同的分叉上，那么w可以强烈地看到x和y中的一个，但不能同时看到这两个分支。此外，如果哈希图A和B一致，则同一个事件不可能既可以强烈地看到A中的x，而另一个事件可以强烈地看到B中的y。这个引理是拜占庭证明的基石。它确保即使攻击者试图通过分叉作弊，他们仍然无法让不同的成员根据不同的顺序做出决定。从历史上看，一些拜占庭协议算法要求成员向每个人发送他们收到的每一张投票的“收据”，以防止Alice向Bob和Carol发送不一致的投票。这种攻击在哈希图分叉攻击上，以及使用收据和使用强烈看到之间有一些相似之处。
鉴于这些定义，完整的哈希图共识协议可以由图4,5,6和7中的算法给出。
图4中的主要算法表明通信非常简单：Alice随机挑选另一名成员Bob，并向他传达她所知道的所有事件。Bob然后创建一个新的事件来记录这个gossip的事实。
这个简单的gossip协议足以支持拜占庭容错和正确性。同时它也可以以各种方式扩展, 以提高效率。例如, Alice和Bob可能会告诉对方, 他们已经知道的事件, 然后Alice只需要发送给Bob所有她知道而他不知道的事件。该协议可能要求Alice以拓扑顺序发送这些事件, 因此Bob在接收事件之前总是会有一个事件的父级。协议甚至可能要求, 在Alice 同步到Bob之后, Bob将立即同步回Alice。多个同步可能会立即发生, 因此Alice可能会同步到多个成员, 同时几个成员也正在同步到她。这些以及其他优化都可以使用, 但这一简单的要求实现就已经足够了。
在每次同步之后, 该成员调用三个过程来确定尽可能多的事件的协商一致顺序。这些不涉及交流，只是纯粹地在本地计算就足够了。在这些过程中，每个for循环都以拓扑顺序访问事件，在这种情况下，事件总是在其父级之后访问。在算法的第一个for循环中，如果x是所有历史记录中的第一个事件，那么它将不会有父级或前几轮，因此应该将其设置为 x.round = 1 和 x.witness = TRUE。该算法还使用常量n，代表所有成员数目，c是大于2的常数, 如 c = 10。在下面的算法中, 拜占庭协议是达成相同概率的保证。
将每个事件的循环数定义为其祖先的函数是有用的。在divideRounds（图5）中，每个已知事件都被赋予一个回合整数（定义5.2），作为其祖先的整数的函数。图3中的哈希图显示了如何完成。如果最下面的所有事件都是回合制的，那么这些数字中的所有其他事件也将是回合的，除了黄色事件，它将是r + 1。黄色事件前进到下一回r + 1，因为它能够强烈地看到来自r回的超过2n / 3个事件。历史上的第一个事件被定义为第一回合，所以未来的所有回合都由此决定。每个事件最终都会有一回合创建和一回合接收的数字。所创建的回合也被称为回合或回合数。
对于任何给定的成员，他们在每轮中创建的第一个事件称为证人。只有证人事件发送和接收虚拟投票。这发生在图6所示的decisionFame过程中。此过程是拜占庭协议发生的地方。对于每个证人，决定它是否出名的是：如果许多证人在下一轮能够看到它，该证人就很有名，如果许多证人无法看到，它就不会出名。拜占庭协议协议为每个证人进行选举，以确定它是否有名。对于第r轮中的证人x，第r + 1轮中的每个证人都会投票表明是否能够看到x，如果看到它就是有名的。如果超过2n/3就是否知名达成一致，那么可以宣告选举结束。如果表决达到一个平衡，那么它会根据需要继续进行多轮，每个证人在正常轮次投票中根据其在上一轮中可以看到的大多数证人进行投票。为了防御可以控制互联网的攻击者，有定期的硬币轮，证人可以伪随机地投票。这意味着，即使攻击者可以控制所有通过互联网传递的信息，以保持投票的谨慎分裂，社区仍然有可能随机跨越2n/3的阈值。最终达成协议的一致概率。
在图6中，如果将行“if d = 1”更改为“if d = 2”，算法将继续工作。在该修订算法中，每次选举将在一轮后开始。如果两者在以下混合算法中组合，它甚至会继续工作。在每轮中，首先用“d = 1”检查运行其所有选举。如果这一轮中每个证人的名气都已经确定，并且在那一轮中有2n/3或更少的成员创造了有名的证人，那么这一轮的选举就全部重新开始，使用a，d = 2来验证。对于这种混合算法，本文中的所有定理都将继续保持真实，包括拜占庭容错的证明。对于引发新选举的轮次来说，达成共识的时间会稍微增加（大概增加20％）。但在实践中这种情况很少发生，如果发生这种情况，可能会增加著名证人的数量，以确保公平。
一旦就特定回合中的每个证人是否出名达成共识，那么使用它可以很容易地确定一个一致的时间戳，并且对较早事件的顺序达成共识。这由findOrder过程完成，见图7。</p>
<p>图4
Swirlds哈希图共识算法。每个成员反复呼叫随机选择的其他成员，并与其同步。向外同步的同时，每个成员也在接收传入的同步信息。当Alice与Bob同步时，她发送她知道Bob不知道的所有事件。Bob将这些事件添加到哈希图中，并且只接受包含他拥有的有效父哈希的有效签名的事件。所有已知的事件然后被分成几轮。然后，每一轮每个成员（“证人”）的都会对这轮的第一个事件，执行本地拜占庭式协议，通过虚拟投票来决定是否著名。然后对拥有足够可用信息的事件，进行排序。如果两位成员单独给某个事件分配一个位置，他们将保证分配的是相同的职位，并保证永远不会改变职位，即使后面有更多的事件进入。最终，每个事件都会以一个相同的概率被分配到这样一个位置上。</p>
<p>首先，计算收到的回合。如果这是所有独特的著名证人都是其后代的第一轮，并且每个证人的名气都被确定为小于或等于r的回合，则事件x已经接收到一轮r。（一轮中独特的着名证人的定义与一组着名证人的定义相同，只是如果该成员在该回合中有一个以上着名证人的话，那么来自给定成员的所有着名证人都将被删除。）
然后，计算接收到的时间。假设事件x有一个r的接收轮，Alice在r轮创建了一个独特的着名见证y。该算法找到z，它是学习了x的y的最早的自我祖先。假设t是Alice创建z时放入z的时间戳。那么t可以被认为是Alice声称第一次学习x的时间。x的接收时间是所有这些时间戳的中位数，对于r轮中唯一著名证人的所有创建者。
然后计算一致性顺序。所有的事件都按他们收到的一轮排序。如果两个事件有相同的接收轮次，则按接收时间排序。如果仍然存在关系，那么在签名被与接收回合中所有独特的着名证人签名异或之后，通过简单的签名排序就可以打破关系。</p>
<p>图5
divideRounds程序。只要事件x已知，就会分配一个回合数字x.round，并计算布尔值x.witness，指出它是否是“见证事件”，即该成员是否是该轮中创建的第一个事件。</p>
<a class="header" href="#a5-拜占庭容错证明" id="a5-拜占庭容错证明"><h2>5. 拜占庭容错证明</h2></a>
<p>本节提供了许多有用的定义，其次是几个证明，从强烈看见引理（引理5.12）到拜占庭容错定理（定理5.19）。在证明中，假设有n个成员（n&gt;1），其中超过 2n/3 个是诚实的，并且其中不到 n/3 是不诚实的。还假定数字签名和密码哈希是安全的，所以签名不能被伪造，签名的消息不能被检测而改变，并且哈希碰撞永远不会发生。同步gossip协议被假定为确保当Alice向Bob发送她知道的所有事件时，Bob只接受那些具有有效签名并包含与他拥有的事件相对应的有效哈希。该系统完全异步。假定对于任何诚实的成员Alice和Bob，Alice最终将尝试与Bob同步，并且如果Alice反复尝试向Bob发送消息，她最终将成功。对网络可靠性或网络速度或超时时间没有其他假设。具体来说，允许攻击者完全控制网络，任意删除和延迟消息，但要受限于反复发送的诚实成员之间的消息必须最终具有其通过的副本。</p>
<p>定义5.1： 如果x是y，则事件x被定义为事件y的祖先，或者是y的父亲，或者是父亲的父亲，等等。如果x是y，或者是y的自身父母，或者是y的自身父母的自身父母等，那么它也是y的自身祖先。
An event x is defined to be an ancestor of event y if x is y , or a parent of y , or a parent of a parent of y , and so on. It is also a self-ancestor of y if x is y , or a self-parent of y , or a self-parent of a self-parent of y and so on.</p>
<p>定义5.2: 一个事件x的回合创建数（或轮）被定义为r + i，其中r是x的父辈的最大轮数（如果没有父代，则为1），如果x可以强烈地看到r轮中超过2n / 3个证人（如果不能，则为0），那么i就是1，
The round created number (or round) of an event x is defined to be r + i, where r is the maximum round number of the parents of x (or 1 if it has no parents), and i is defined to be 1 if x can strongly see more than 2n/3 witnesses in round r (or 0 if it can’t).</p>
<p>定义5.3: 如果所有独特的著名证人都是x的后代，那么事件x的回合数(或者轮)就是1。
The round received number (or round received) of an event x is defined to be the first round where all unique famous witnesses are descendants of x.</p>
<p>图6.DecideFame程序。
对于每个见证事件（即，其中x.witness为真的事件x），决定它是否是有名的（即，将布尔分配给x.famous）。这个决定是通过基于虚拟投票的拜占庭协议协议完成的。每个成员在本地运行它，在他们自己的哈希图副本上，没有额外的通信。它将哈希图中的事件看作是彼此发送的投票，尽管纯粹是成员在本地计算的的。该成员为每轮回合的证人分配选票数次，直到超过2/3的人口同意。为了判断x是否有名，在持续增长的哈希图上反复重复这个操作，直到x.famous被判定。</p>
<p>定义5.4: 一组事件 (x, y), 如果x和y拥有相同的祖先，而且他们互相都不是对方的自我祖先, 那么这是一个分叉(fork)。
The pair of events(x, y) is a fork if x and y have the same creator, but neither is a self-ancestor of the other.</p>
<p>图7。findOrder程序。
一旦r轮中的所有证人都有了名气，那么在那一轮中找到一组着名的证人，然后从该组中删除与该组中任何其他著名证人相同的创造者（去除重复的创建者）。其余的著名证人是独特的著名证人。他们担任评委，接受一轮事件和达成共识时间戳。所有独特的着名证人收到它的第一轮“接收”事件，如果所有先前的轮次都有所有决定的证人的名气。它的时间戳是每个成员第一次收到它的事件时间戳的中间值。一旦计算出来后，这些事件就按照收到的一轮进行排序。任何关系都按照一致的时间戳进行分类。任何剩余的关系都是由白色签名来划分的。白色签名是与接收回合中所有唯一着名证人签名异或的签名。</p>
<p>定义5.5: 一个诚实的成员会一直尝试着与其他成员进行同步，并在每次同步后创建一个有效事件（使用最新的自身父母和其他父母的哈希），并且永远不会创建两个彼此分叉的事件。
An honest member tries to sync infinitely often with every other member, creates a valid event after each sync (with hashes of the latest self-parent and other-parent), and never creates two events that are forks with each other.</p>
<p>定义5.6: 如果y是x的祖先，则事件x可以看到事件y，并且x的祖先不包括y的创建者的分叉。
An event x can see event y if y is an ancestor of x, and the ancestors of x do not include a fork by the creator of y.</p>
<p>定义5.7: 如果x能够看到y，并且在超过2/3的成员中有一组事件S，x可以看到S中的每个事件，并且S中的每个事件都可以看到y， 那么事件x可以强烈地看到事件y。
An event x can strongly see event y if x can see y and there is a set S of events by more than 2/3 of the members such that x can see every event in S, and every event in S can see y.</p>
<p>定义5.8：见证是指某一轮中一个成员创建的第一个事件。
A witness is the first event created by a member in a round.</p>
<p>定义5.9: 一个著名的证人是由社区来决定的，使用这里描述的算法。非正式地，如果许多成员在下一轮开始时看到证人，社区往往会认定证人是有名的。一个唯一的著名的见证的创建者在这一轮中所有著名见证中应该只会出现一次。在没有分叉的情况下，每个著名的证人都是一个唯一的著名证人。
A famous witness is a witness that has been decided to be famous by the community, using the algorithms described here. Informally, the community tends to decide that a witness is famous if many members see it by the start of the next round. A unique famous witness is a famous witness that does not have the same creator as any other famous witness created in the same round. In the absence of forking, each famous witness is also a unique famous witness.</p>
<p>定义5.10: 如果两个哈希图中包含的任何事件x都包含相同的x祖先，并且在这些祖先之间具有相同的父亲和自身父亲边缘，则哈希图A和B是一致的。
Hashgraphs A and B are consistent if for any event x contained in both hashgraphs, both contain the same set of ancestors for x, with the same parent and self-parent edges between those ancestors.</p>
<p>引理5.11: 所有成员都有一致的哈希图。
All members have consistent hashgraphs.</p>
<p>引理5.12: （强烈的看见引理） 如果一组事件(x, y)是分叉，而且在哈希图A中，x能够被事件z强烈的看到， 因此，在和A相同的哈希图B中，y将不能被任何事件强烈的看到。
if the pair of events (x, y) is a fork, and x is strongly seen by event z in hashgraph A , then y will not be strongly seen by any event in any hashgraph B that is consistent with A.</p>
<p>引理5.13: 如果哈希图A和B一致，而且都包含x事件，那么两者都会对x得到相同的回合数。
If hashgraphs A and B are consistent and both contain event x, then both will assign the same round created number to x.</p>
<p>引理5.14: 如果A和B一样，在A中的算法显示，在r轮中，成员m(0)投了v(A)票，给在r+1轮的成员m(1)，而且在B中的算法显示，m(0)在r轮的时候，投了v(B)给r+1轮中的m(1)的事件，则可以得出 v(A) = v(B)。
if hashgraphs A and B are consistent, and the algorithm running on A shows that a round r event by member m(0) sends a vote v(A) to member m(1) in round r + 1, and the algorithm running on B shows that a round r event by member m(0) sends a vote v(B) to an event by member m(1) in round r + 1, then v(A) = v(B).</p>
<p>引理5.15: 如果哈希图A和B是一致的，并且A决定好了在r回合中结果为v的拜占庭协议选举，并且B在r之前还没有决定，那么B将在r + 2回合或之前决定v。
if hashgraphs A and B are consistent, and A decides a Byzantine agreement election with result v in round r and B has not decided prior to r , then B will decide v in round r + 2 or before.</p>
<p>定理5.16: 对于任何单一的是/否问题，最终以相同的概率达成共识。
For any single YES/NO question, consensus is achieved eventually with probability 1.</p>
<p>定理5.17: 对于任何轮r，在r + 3轮中至少有一个事件的哈希图，那么在r轮中至少有一个证人会被共识算法著名，这个决定将由 每个 r+3 轮中的或更早轮中的见证人决定。
For any round number r, for any hashgraph that has at least one event in round r + 3, there will be at least one witness in round r that will be decided to be famous by the consensus algorithm, and this decision will be made by every witness in round r + 3 , or earlier.</p>
<p>定理5.18: 如果哈希图A不包含事件x，但确实包含x的所有父项，并且哈希图B是加了x的结果，并且x是在r轮创建的证人，并且A在r轮中至少有一个证人 其名气已经决定（无论是着名的还是不知名的），那么在B中x将被定为“不出名”。
If hashgraph A does not contain event x, but does contain all the parents of x, and hashgraph B is the result of adding x to A, and x is a witness created in round r , and A has at least one witness in round r whose fame has been decided (as either famous or as not famous), then x will be decided as “not famous” in B.</p>
<p>定理5.19: （拜占庭容错定理）。 由诚实成员创建的每个事件x最终将以相同的概率按被纳入到所有事件的总顺序中。
(Byzantine Fault Tolerance Theorem). Each event x created by an honest member will eventually be assigned a consensus position in the total order of events, with probability 1.</p>
<a class="header" href="#swirlds-hashgraph-1" id="swirlds-hashgraph-1"><h2>SWIRLDS HASHGRAPH</h2></a>
<a class="header" href="#a共识协议-公平快速拜占庭容错-1" id="a共识协议-公平快速拜占庭容错-1"><h3>共识协议: 公平，快速，拜占庭容错</h3></a>
<p>LEEMON BAIRD
MAY 31, 2016
SWIRLDS TECH REPORT SWIRLDS-TR-2016-01</p>
<a class="header" href="#a摘要-1" id="a摘要-1"><h3>摘要</h3></a>
<p>一个新的系统，Swirlds散列图共识算法，被提议用于保证拜占庭容错的复制状态机。它实现了公平性，因为攻击者很难操纵两个交易中的哪一个将被选为第一个这样的的共识顺序。它具有完全的异步性，没有领导者，没有轮询，没有工作证明，最终以同样的概率达成一致，并且在没有缺陷的情况下高速运转。它基于gossip协议，其中参与者不只是传播交易。他们传播gossip。他们共同构建一个反映所有gossip事件的散列图。这使得拜占庭协议可以通过虚拟投票来实现。Alice不会通过互联网向Bob投票。相反，Bob根据他对Alice的了解，计算Alice将投什么票。这对所有交易的总订单产生了公平的拜占庭协议，除了交易本身之外，通信开销很少。</p>
<p>关键词：拜占庭，拜占庭协议，拜占庭容错，复制状态机，公平，公平，哈希图，关于传播gossip，虚拟投票，Swirlds</p>
<a class="header" href="#a内容-1" id="a内容-1"><h3>内容</h3></a>
<p>List of Figures</p>
<ol>
<li>Introduction 介绍</li>
<li>Core concepts 核心概念</li>
<li>Gossip about gossip: the hashgraph 传播gossip: 哈希图</li>
<li>Consensus algorithm 共识算法</li>
<li>Proof of Byzantine fault tolerance 拜占庭容错证明</li>
<li>Fairness 公平性</li>
<li>Generalizations and enhancements 概括和增强</li>
<li>Conclusions 结论</li>
</ol>
<a class="header" href="#references-参考-1" id="references-参考-1"><h3>References 参考</h3></a>
<ol start="9">
<li>Appendix A: Consensus algorithm in functional form</li>
</ol>
<a class="header" href="#list-of-figures-图表列表-1" id="list-of-figures-图表列表-1"><h3>List of Figures 图表列表</h3></a>
<ol>
<li>Gossip history as a directed graph</li>
<li>The hashgraph data structure</li>
<li>Illustration of strongly seeing.</li>
<li>Pseudocode: the Swirlds hashgraph consensus algorithm</li>
<li>Pseudocode: the divideRounds procedure</li>
<li>Pseudocode: the decideFame procedure</li>
<li>Pseudocode: the finalOrder procedure</li>
</ol>
<a class="header" href="#a1-介绍-1" id="a1-介绍-1"><h2>1. 介绍</h2></a>
<p>分布式数据库通常需要具有拜占庭容错的复制状态机。一些作者用“拜占庭”这个术语来表示软弱，例如假设攻击者不会串通，或者沟通是弱的异步。在本文中，“拜占庭”将以使用其原始定义的强烈意义：成员中只有不到1/3的成员可以成为攻击者，他们可以勾结，并且在没有消息延迟的限制下，可以删除或延迟诚实成员之间的信息。攻击者可以控制网络来延迟和删除任何消息，尽管在任何时候，如果一个诚实的成员多次向另一个成员发送消息，攻击者最终必须允许其中一个通过。假设存在安全的数字签名，那攻击者不能无法不留痕迹地修改消息。假定存在安全的散列函数，那这些散列函数永远不会冲突。本文提出并描述了Swirlds散列图的共识算法，并在强烈的定义下证明了拜占庭容错性。
FLP定理说明：没有一个完全确定性的拜占庭系统是完全异步的，无限的消息延迟，并且仍然保证达成共识。但是非确定性系统有可能以同样的概率达成共识。哈希图共识算法是完全异步的，是非确定性的，并且以相同的概率实现拜占庭协议。
一些系统，如Paxos或Raft使用领导者，如果攻击者对当前领导者发起拒绝服务攻击，他们可能会使他们容易遭受大量延迟。很多系统甚至可能被一个坏客户推迟。事实上，后面的文章表明，具有这种漏洞的系统可能更好地被描述为“拜占庭故障可存活”而不是“拜占庭容错”。哈希图共识不使用领导者，并且能够适应对小型的成员子集进行攻击。
其他系统（比如比特币）则基于工作的区块链验证。这避免了所有上述问题。然而，这样的系统不是拜占庭式的，因为一个成员从来不知道何时达成共识，他们只能随着时间的推移, 从而信任某个结果。如果两个区块同时开采，那么该链就会分叉，直到社区都同意延伸哪个分支。如果块缓慢添加，社区总是选择更长的分支，其他分支将停止增长，并且可以修剪和丢弃，因为它是“陈旧”的。这会导致效率低下，虽然某些区块开采得当，但无论如何都会被丢弃。这也意味着有必要放慢块开采的速度，以便社区能够共同选择分叉，而不是一直创建新分叉。这是工作证明的目的。通过要求矿工解决一个困难的计算问题来挖掘一个区块，它可以确保整个网络在采矿之间平均具有足够长的延迟。哈希图共识算法相当于一个块链，其中“链”不断地分支，没有任何修剪，没有任何块过时，并且允许每个矿工每秒钟挖掘许多新块，而没有工作证明和100％的效率。
工作量证明的区块链还要求额外计算，浪费电力，并且可能需要购买昂贵的采矿设备。通过使用长时间延迟的可信硬件芯片，一个过期时间证明系统可以避免浪费的电力（尽管可能不是开采工具的成本），就好像他们正在进行工作证明的计算一样。但是，这要求所有参与者相信创建该芯片的公司。这种对芯片厂商的信任在某些情况下存在，但在其他情况下则不存在，例如当FreeBSD被更改为不仅仅依靠硬件RDRAND指令获取安全随机数时，因为“我们不能再相信它们了”。
拜占庭协议系统为避免上述问题，制定了该拜占庭协议。这些系统通常交换许多信息供会员投票。对于n个成员来决定单个YES/NO问题，有些系统可能需要 O（n）个消息需要通过网络发送。其他系统可能需要O（n^2），或者甚至O（n^3）个消息，每个二进制决策通过网络。然后可以扩展单个YES/NO决策的算法来决定一组交易的总订单，这可能进一步增加投票流量。哈希图在整个网络上都没有投票，因为所有投票都是虚拟的。</p>
<a class="header" href="#a2-核心概念-1" id="a2-核心概念-1"><h2>2. 核心概念</h2></a>
<p>哈希图共识算法包括下面这些核心概念:</p>
<ul>
<li>交易: 任何人都可以在任何时刻创建新的签名交易。所有人都会有此交易的完整拷贝，社区将会对这些交易的排序达成共识。</li>
<li>公平性：少数攻击者难以不公平地影响被选为共识的交易顺序。</li>
<li>Gossip：信息会由每位成员随机选择另一名成员，并告诉他们所有的自己知道的信息。</li>
<li>哈希图：一种记录了每个人传播的gossip记录和顺序的数据结构。</li>
<li>关于gossip的gossip：哈希图是通过gossip协议传播的。被传播的是gossip本身的历史，所以这是gossip about gossip。这仅仅使用非常少的带宽开销，而且不仅仅是在单纯地传播gossip事件。</li>
<li>虚拟投票：每个成员都有一个散列图的副本，所以如果Alice运行着正常的拜占庭协议协议（包括发送投票），Alice可以计算Bob将给她发送了什么投票。所以鲍勃不需要真正的投票。每个成员都可以就任何的决定达成拜占庭协议，而无需发送任何一次投票。散列图本身就足够了。因此，零带宽使用，不仅仅是在简单地传播hashgraph。</li>
<li>著名的证人：社区可以通过收集 O（n log n）个关于 “是/否事件x在事件y之前出现” 的是/否问题，进行运行单独的拜占庭协议协议，将n个事务列表排序。更快的方法是只挑选几个事件（散列图中的顶点），称为证人，并且如果散列图显示大多数成员在创建后很短时间内收到它，则定义一个有名的证人。仅仅为证人运行拜占庭协议协议就足够了，为每个证人决定单个问题“这个证人是否出名？”。一旦拜占庭就一组固定的证人达成协议，就很容易从哈希图中得出所有事件的公平的总订单。</li>
<li>强连接：给定散列图中的任何两个顶点x和y，可以立即计算出x是否强连接y，如果它们通过经过足够多成员的多个有向路径连接，则将其定义为真。这个概念可以证明关键定理：如果Alice和Bob都能够计算Carol在给定问题上的虚拟投票，那么Alice和Bob会得到相同的答案。这个定理形成了拜占庭与概率一致的数学证明的基础。</li>
</ul>
<p>图1.
Gossip历史是一个有向图。任何Gossip历史都可以用一个图来表示，每一个成员都是一个顶点。当Alice收到Bob的gossip时，告诉她他所知道的一切，这个gossip事件由Alice列中的一个顶点表示，其中两条边向下延伸到Alice和Bob的紧接着的前面的gossip事件。</p>
<a class="header" href="#a3-关于gossip的gossip哈希图-1" id="a3-关于gossip的gossip哈希图-1"><h2>3. 关于gossip的gossip：哈希图</h2></a>
<p>哈希图共识算法使用一个gossip协议。这意味着像Alice这样的成员会随机选择另一个成员，比如Bob，然后Alice会告诉Bob她知道的所有信息。 Alice然后重复这样的操作，选择一个随机的成员。Bob反复做这样的事情，同时，其他成员也会这样做。通过这种方式，如果一个成员接到新信息，它就会以指数形式快速传播到整个社区，直到每个成员都意识到这一点。
任何gossip协议的历史都可以用像图1这样的有向图来说明。Alice列中的每个顶点表示一个gossip事件。例如，Alice列中的顶级事件表示了Bob向Alice发送了一个gossip同步，Bob在其中告知了他所知道的所有信息。该顶点有两个向下的连线，连接到Alice和Bob的最前面的gossip。时间在图形中流动，所以较低的顶点表示历史中较早的事件。在一个典型的gossip协议中，像这样的图只是用来讨论协议;实质上这个图形并没有存储在任何地方形。
在哈希图共识中，图是实际上的数据结构。图2说明了这个数据结构。每个事件（顶点）都以字节序列的形式存储在内存中，由其创建者签名。例如，Alice（红色）的一个事件记录了Bob执行了gossip同步的事实，在该事实中，他向她发送了他所知道的一切。此事件由Alice创建并由她签名，并包含另外两个事件的散列：她的最后一个事件和Bob在该gossip同步之前的最后一个事件。红色事件还可以包含Alice选择在那个时候创建​​的任何事务的有效载荷，并且可能包含一个时间戳，即Alice声明创建它的时间和日期。该事件的其他祖先（灰色）不包含在其中，而是由一组密码哈希确定。具有散列图的这种数据结构已经被用于其他的地方，例如Git中的顶点是文件树的版本，边表示文件的更改。但Git并没有存储成员是如何沟通的这种记录。哈希表有自己的实现目的，就是记录下成员之间沟通的历史。
gossip协议被广泛用于传输各种类型的信息。他们可能会涉及传播用户身份，传播交易，传播区块链，或传播其他需要分发的信息。但如何定义关于gossip的gossip协议？如果成员们传播传递哈希图本身呢？当Bob向Alice传播时，他会把所有他知道但她不知道的事件都给她。
传播哈希图给参与者很多信息。如果一个新事件被放置在事件的有效载荷中，它将很快传播至所有成员那，直到每个成员都知道。Alice在接受这笔交易时。她会知道Bob是何时才知道这笔交易。同时她也会确切地知道Carol是何时知道Bob已经知道这笔交易的事实。当所有成员都有散列图的副本时，这种深层次的链推理就成为可能。随着哈希函数向上增长，不同的成员可能会在顶部附近的关于新事件的子集上略有不同，但它们将迅速收敛到一个在哈希图中具有完全相同的事件的状态。此外，如果Alice和Bob碰巧都有一个特定的事件，那么他们也保证都拥有其所有的祖先。他们也会同意这些祖先的所有子图的所有连线。所有这些都是在本地运行的强大的算法，包括拜占庭容错。
这种能力带来的通信开销很小。如果社区只是传播他们创建的签名交易，则需要一定数量的带宽。如果他们只是在传播散列图，并且如果在足够多的事务中，有一个典型事件中至少包含一笔交易，则开销很小。她不会签署她创建的交易，她只会签署她创建的事件来包含该交易。无论哪种方式，她只发送一个签名。换句话说，无论如何，她必须自己发送交易。唯一额外的开销就是她必须发送这两个哈希值。但即使这样也可以压缩处理。在图2中，Alice不会向Carol发送红色事件，直到Carol已经拥有其所有早期祖先（不论是来自Alice还是早先与其他人同步）之后。所以Alice不需要发送两个蓝色父事件的两个哈希值。告诉Carol这个事件是Alice的下一个事件就足够了，并且它的另一个父母是Bob的第三个事件。通过适当的压缩，这可以以很少的字节发送，仅增加发送消息的几个百分比来的大小。</p>
<a class="header" href="#a4-共识算法-1" id="a4-共识算法-1"><h2>4. 共识算法</h2></a>
<p>确保每个成员都知道每一个事件是不够的，还需要就事件的线性排序以及事件内记录的交易达成一致。大多数没有领导者的拜占庭容错协议取决于每个人成员告知所有人他们的投票结果。因此，对于n个成员就单个YES/NO问题达成一致而言，可能需要通过网络发送O(n^2)个投票消息，因为每个成员都需要告诉其他成员投票结果。其中一些协议要求收到发给每个人的选票，使其成为O(n^3)。他们可能需要多轮投票，这进一步增加了发送的投票消息的数量。</p>
<p>图2.
哈希图数据结构。Alice创建一个事件（红色），记录Bob对她做的传播同步的事件，并告诉她他知道的一切。该事件包含两个父事件（蓝色）的散列：由同一个创建者Alice创建的父母（深蓝色），以及Bob创建的另一个父母（浅蓝色）。它还包含Alice当时选择创建的任何新交易的有效载荷，以及Alice的数字签名。其他祖先事件（灰色）不存储在红色事件中，但它们由所有哈希确定。其他自我祖先（深灰色）可以通过自我亲缘关系序列到达，其他祖先（浅灰色）则不是。</p>
<p>哈希图共识不需要发送任何投票。每个成员都有散列图的副本。如果Alice和Bob都具有相同的散列图，那么他们可以根据该散列图，通过函数计算并确定下所有事件的顺序，并且它们都会得到相同的答案。因此，即使不发送投票信息，也能达成共识。
当然，在某个特定时刻，Alice和Bob可能没有完全相同的哈希图。他们通常会在较早的事件中达成一致，但对于最近的事件，互相可能还没有完全同步。此外，有时可能会向社区发布一个新事件，该事件被放置在散列图中较低（较早）的位置。哈希图形共识算法使用被认为最好的虚拟投票系统来处理这些问题。
假设Alice具有散列图A和Bob散列图B。这些哈希图在任何给定的时刻都可能稍有不同，但它们将始终保持一致。一致意味着如果A和B都包含事件x，那么它们都将包含与x完全相同的一组祖先，并且都包含这些祖先之间完全相同的一组边。如果Alice知道x而Bob不知道，并且他们都诚实并积极参与，那么我们相信Bob会通过gossip协议很快地接收到x。共识算法假设最终会发生，但不会对其发生速度做出任何假设。该协议是完全异步的，并没有对超时时间，传播速度或进度进行假设。
Alice将通过一系列的选举计算来确定A中事件的总顺序。在每次选举中，A中的一些事件将被视为投票，同时A中的一些事件将被视为接受该投票。Alice将多次计算选举，因为某一事件可能参加一些选举而不参与其他选举，并可能在不同的选举中投不同的选票。如果这个事件是由Bob创建的，我们将会讨论Bob在特定选举中以某种方式进行了投票。但实际的鲍勃不参与。这完全是Alice在本地执行的计算，她计算出Bob发送出去的投票数。当然这建立在真的是Bob通过互联网向她投票的基础上。</p>
<p>图3.
强烈看到的插图。在每个哈希图中，顶部的黄色事件可以强烈地看到底部行中的一个橙色事件。有n = 5个成员，所以大于2n / 3的最小整数是4。在（d）中，一个事件（橙色）是不同创建者（红色）的4个中间事件中的每一个的祖先，每个事件都是黄色事件的祖先。因此，黄色事件可以强烈地看到橙色事件。 其他每个哈希图都被着色，以显示底行不同的橙色事件，黄色事件至少会看到4个红色事件。如果所有4个橙色事件和黄色事件的父母都创建了一轮r，则在r + 1轮创建黄色，因为它可以强烈地看到r轮中由不同成员创建的超过2n / 3个证人。请注意，每个事件都被定义为自己的祖先和自我祖先。</p>
<p>这个虚拟投票有几个好处。除了节省带宽之外，它还确保成员总能够按照规则计算他们的投票。如果Alice是诚实的，她会真实地计算出Bob所做出的虚拟投票。即使真正的Bob是个骗子，他也不能通过虚假的虚拟投票来攻击Alice。
Bob可以尝试以不同的方式作弊。假设Bob创建一个事件x，其中自身父事件指向他以前的事件z。然后Bob创建一个新的事件y，也将自身父事件指向了z，而不是指向x。这意味着Bob在哈希图中的事件将不再是一个链。他们现在将成为一棵树，因为他创造了一个分叉。如果Bob将x传给Alice，然后y传给Carol，那么一段时间后，Alice和Carol可能还没有意识到这个分叉。这个时候，爱丽丝计算出来的关于x的虚拟投票，与Carol对y的虚拟投票计算结果不同。
哈希图的一致性算法通过使用一种状态观念来看一个状态这种方式来防止这种攻击，并且一个状态的观念是可以强烈地看到另一个状态的。这些基于对祖先和自我祖先的定义，以致每个事件都被认为是自己的祖先和自我祖先。##译者注
如果Bob创建两个事件x和y，这两个事件都不是另一个的自我祖先，那么Bob就会被分叉作弊。如果某个事件w有x作为祖先，但没有y作为祖先，那么事件w可以看到事件x。然而，如果x和y都是w的祖先，那么w被定义为不会看到它们中的任何一个，也不会被同一个创建者看到任何其他事件。换句话说，如果x能够看到w的话，w可以看到x，而且不知道是谁创建了分叉。
如果有n个成员，那么事件w可以强烈地看到事件x，如果w可以看到不同成员的超过2n/3个事件，其中每个成员都可以看到x。这个概念如图3所示。该图显示了相同哈希图的四个副本，每个在底部行上以不同的事件着橙色。在（d）中，顶部的黄色事件可以由不同的成员看到4个红色事件，每个事件都可以在底部看到橙色事件。（a），（b）和（c）中也是如此，其中（a）实际上有5个红色事件。但只有4个人需要强烈观察，因为这个例子有n = 5个成员，大于2n / 3的最小整数是4。
这个概念允许一个协议通过本地虚拟投票而无需任何实际投票就能实现拜占庭容错。
在虚拟投票中，在事件x中，对某个YES/NO问题进行了投票（例如，不管事件是否有名），投票计算纯粹是作为x的祖先的函数。如果w可以强烈地看到x，则该投票仅被认为是从x可以连接到它的后代事件w。在第5节中证明，如果x和y在不同的分叉上，那么w可以强烈地看到x和y中的一个，但不能同时看到这两个分支。此外，如果哈希图A和B一致，则同一个事件不可能既可以强烈地看到A中的x，而另一个事件可以强烈地看到B中的y。这个引理是拜占庭证明的基石。它确保即使攻击者试图通过分叉作弊，他们仍然无法让不同的成员根据不同的顺序做出决定。从历史上看，一些拜占庭协议算法要求成员向每个人发送他们收到的每一张投票的“收据”，以防止Alice向Bob和Carol发送不一致的投票。这种攻击在哈希图分叉攻击上，以及使用收据和使用强烈看到之间有一些相似之处。
鉴于这些定义，完整的哈希图共识协议可以由图4,5,6和7中的算法给出。
图4中的主要算法表明通信非常简单：Alice随机挑选另一名成员Bob，并向他传达她所知道的所有事件。Bob然后创建一个新的事件来记录这个gossip的事实。
这个简单的gossip协议足以支持拜占庭容错和正确性。同时它也可以以各种方式扩展, 以提高效率。例如, Alice和Bob可能会告诉对方, 他们已经知道的事件, 然后Alice只需要发送给Bob所有她知道而他不知道的事件。该协议可能要求Alice以拓扑顺序发送这些事件, 因此Bob在接收事件之前总是会有一个事件的父级。协议甚至可能要求, 在Alice 同步到Bob之后, Bob将立即同步回Alice。多个同步可能会立即发生, 因此Alice可能会同步到多个成员, 同时几个成员也正在同步到她。这些以及其他优化都可以使用, 但这一简单的要求实现就已经足够了。
在每次同步之后, 该成员调用三个过程来确定尽可能多的事件的协商一致顺序。这些不涉及交流，只是纯粹地在本地计算就足够了。在这些过程中，每个for循环都以拓扑顺序访问事件，在这种情况下，事件总是在其父级之后访问。在算法的第一个for循环中，如果x是所有历史记录中的第一个事件，那么它将不会有父级或前几轮，因此应该将其设置为 x.round = 1 和 x.witness = TRUE。该算法还使用常量n，代表所有成员数目，c是大于2的常数, 如 c = 10。在下面的算法中, 拜占庭协议是达成相同概率的保证。
将每个事件的循环数定义为其祖先的函数是有用的。在divideRounds（图5）中，每个已知事件都被赋予一个回合整数（定义5.2），作为其祖先的整数的函数。图3中的哈希图显示了如何完成。如果最下面的所有事件都是回合制的，那么这些数字中的所有其他事件也将是回合的，除了黄色事件，它将是r + 1。黄色事件前进到下一回r + 1，因为它能够强烈地看到来自r回的超过2n / 3个事件。历史上的第一个事件被定义为第一回合，所以未来的所有回合都由此决定。每个事件最终都会有一回合创建和一回合接收的数字。所创建的回合也被称为回合或回合数。
对于任何给定的成员，他们在每轮中创建的第一个事件称为证人。只有证人事件发送和接收虚拟投票。这发生在图6所示的decisionFame过程中。此过程是拜占庭协议发生的地方。对于每个证人，决定它是否出名的是：如果许多证人在下一轮能够看到它，该证人就很有名，如果许多证人无法看到，它就不会出名。拜占庭协议协议为每个证人进行选举，以确定它是否有名。对于第r轮中的证人x，第r + 1轮中的每个证人都会投票表明是否能够看到x，如果看到它就是有名的。如果超过2n/3就是否知名达成一致，那么可以宣告选举结束。如果表决达到一个平衡，那么它会根据需要继续进行多轮，每个证人在正常轮次投票中根据其在上一轮中可以看到的大多数证人进行投票。为了防御可以控制互联网的攻击者，有定期的硬币轮，证人可以伪随机地投票。这意味着，即使攻击者可以控制所有通过互联网传递的信息，以保持投票的谨慎分裂，社区仍然有可能随机跨越2n/3的阈值。最终达成协议的一致概率。
在图6中，如果将行“if d = 1”更改为“if d = 2”，算法将继续工作。在该修订算法中，每次选举将在一轮后开始。如果两者在以下混合算法中组合，它甚至会继续工作。在每轮中，首先用“d = 1”检查运行其所有选举。如果这一轮中每个证人的名气都已经确定，并且在那一轮中有2n/3或更少的成员创造了有名的证人，那么这一轮的选举就全部重新开始，使用a，d = 2来验证。对于这种混合算法，本文中的所有定理都将继续保持真实，包括拜占庭容错的证明。对于引发新选举的轮次来说，达成共识的时间会稍微增加（大概增加20％）。但在实践中这种情况很少发生，如果发生这种情况，可能会增加著名证人的数量，以确保公平。
一旦就特定回合中的每个证人是否出名达成共识，那么使用它可以很容易地确定一个一致的时间戳，并且对较早事件的顺序达成共识。这由findOrder过程完成，见图7。</p>
<p>图4
Swirlds哈希图共识算法。每个成员反复呼叫随机选择的其他成员，并与其同步。向外同步的同时，每个成员也在接收传入的同步信息。当Alice与Bob同步时，她发送她知道Bob不知道的所有事件。Bob将这些事件添加到哈希图中，并且只接受包含他拥有的有效父哈希的有效签名的事件。所有已知的事件然后被分成几轮。然后，每一轮每个成员（“证人”）的都会对这轮的第一个事件，执行本地拜占庭式协议，通过虚拟投票来决定是否著名。然后对拥有足够可用信息的事件，进行排序。如果两位成员单独给某个事件分配一个位置，他们将保证分配的是相同的职位，并保证永远不会改变职位，即使后面有更多的事件进入。最终，每个事件都会以一个相同的概率被分配到这样一个位置上。</p>
<p>首先，计算收到的回合。如果这是所有独特的著名证人都是其后代的第一轮，并且每个证人的名气都被确定为小于或等于r的回合，则事件x已经接收到一轮r。（一轮中独特的着名证人的定义与一组着名证人的定义相同，只是如果该成员在该回合中有一个以上着名证人的话，那么来自给定成员的所有着名证人都将被删除。）
然后，计算接收到的时间。假设事件x有一个r的接收轮，Alice在r轮创建了一个独特的着名见证y。该算法找到z，它是学习了x的y的最早的自我祖先。假设t是Alice创建z时放入z的时间戳。那么t可以被认为是Alice声称第一次学习x的时间。x的接收时间是所有这些时间戳的中位数，对于r轮中唯一著名证人的所有创建者。
然后计算一致性顺序。所有的事件都按他们收到的一轮排序。如果两个事件有相同的接收轮次，则按接收时间排序。如果仍然存在关系，那么在签名被与接收回合中所有独特的着名证人签名异或之后，通过简单的签名排序就可以打破关系。</p>
<p>图5
divideRounds程序。只要事件x已知，就会分配一个回合数字x.round，并计算布尔值x.witness，指出它是否是“见证事件”，即该成员是否是该轮中创建的第一个事件。</p>
<a class="header" href="#a5-拜占庭容错证明-1" id="a5-拜占庭容错证明-1"><h2>5. 拜占庭容错证明</h2></a>
<p>本节提供了许多有用的定义，其次是几个证明，从强烈看见引理（引理5.12）到拜占庭容错定理（定理5.19）。在证明中，假设有n个成员（n&gt;1），其中超过 2n/3 个是诚实的，并且其中不到 n/3 是不诚实的。还假定数字签名和密码哈希是安全的，所以签名不能被伪造，签名的消息不能被检测而改变，并且哈希碰撞永远不会发生。同步gossip协议被假定为确保当Alice向Bob发送她知道的所有事件时，Bob只接受那些具有有效签名并包含与他拥有的事件相对应的有效哈希。该系统完全异步。假定对于任何诚实的成员Alice和Bob，Alice最终将尝试与Bob同步，并且如果Alice反复尝试向Bob发送消息，她最终将成功。对网络可靠性或网络速度或超时时间没有其他假设。具体来说，允许攻击者完全控制网络，任意删除和延迟消息，但要受限于反复发送的诚实成员之间的消息必须最终具有其通过的副本。</p>
<p>定义5.1： 如果x是y，则事件x被定义为事件y的祖先，或者是y的父亲，或者是父亲的父亲，等等。如果x是y，或者是y的自身父母，或者是y的自身父母的自身父母等，那么它也是y的自身祖先。
An event x is defined to be an ancestor of event y if x is y , or a parent of y , or a parent of a parent of y , and so on. It is also a self-ancestor of y if x is y , or a self-parent of y , or a self-parent of a self-parent of y and so on.</p>
<p>定义5.2: 一个事件x的回合创建数（或轮）被定义为r + i，其中r是x的父辈的最大轮数（如果没有父代，则为1），如果x可以强烈地看到r轮中超过2n / 3个证人（如果不能，则为0），那么i就是1，
The round created number (or round) of an event x is defined to be r + i, where r is the maximum round number of the parents of x (or 1 if it has no parents), and i is defined to be 1 if x can strongly see more than 2n/3 witnesses in round r (or 0 if it can’t).</p>
<p>定义5.3: 如果所有独特的著名证人都是x的后代，那么事件x的回合数(或者轮)就是1。
The round received number (or round received) of an event x is defined to be the first round where all unique famous witnesses are descendants of x.</p>
<p>图6.DecideFame程序。
对于每个见证事件（即，其中x.witness为真的事件x），决定它是否是有名的（即，将布尔分配给x.famous）。这个决定是通过基于虚拟投票的拜占庭协议协议完成的。每个成员在本地运行它，在他们自己的哈希图副本上，没有额外的通信。它将哈希图中的事件看作是彼此发送的投票，尽管纯粹是成员在本地计算的的。该成员为每轮回合的证人分配选票数次，直到超过2/3的人口同意。为了判断x是否有名，在持续增长的哈希图上反复重复这个操作，直到x.famous被判定。</p>
<p>定义5.4: 一组事件 (x, y), 如果x和y拥有相同的祖先，而且他们互相都不是对方的自我祖先, 那么这是一个分叉(fork)。
The pair of events(x, y) is a fork if x and y have the same creator, but neither is a self-ancestor of the other.</p>
<p>图7。findOrder程序。
一旦r轮中的所有证人都有了名气，那么在那一轮中找到一组着名的证人，然后从该组中删除与该组中任何其他著名证人相同的创造者（去除重复的创建者）。其余的著名证人是独特的著名证人。他们担任评委，接受一轮事件和达成共识时间戳。所有独特的着名证人收到它的第一轮“接收”事件，如果所有先前的轮次都有所有决定的证人的名气。它的时间戳是每个成员第一次收到它的事件时间戳的中间值。一旦计算出来后，这些事件就按照收到的一轮进行排序。任何关系都按照一致的时间戳进行分类。任何剩余的关系都是由白色签名来划分的。白色签名是与接收回合中所有唯一着名证人签名异或的签名。</p>
<p>定义5.5: 一个诚实的成员会一直尝试着与其他成员进行同步，并在每次同步后创建一个有效事件（使用最新的自身父母和其他父母的哈希），并且永远不会创建两个彼此分叉的事件。
An honest member tries to sync infinitely often with every other member, creates a valid event after each sync (with hashes of the latest self-parent and other-parent), and never creates two events that are forks with each other.</p>
<p>定义5.6: 如果y是x的祖先，则事件x可以看到事件y，并且x的祖先不包括y的创建者的分叉。
An event x can see event y if y is an ancestor of x, and the ancestors of x do not include a fork by the creator of y.</p>
<p>定义5.7: 如果x能够看到y，并且在超过2/3的成员中有一组事件S，x可以看到S中的每个事件，并且S中的每个事件都可以看到y， 那么事件x可以强烈地看到事件y。
An event x can strongly see event y if x can see y and there is a set S of events by more than 2/3 of the members such that x can see every event in S, and every event in S can see y.</p>
<p>定义5.8：见证是指某一轮中一个成员创建的第一个事件。
A witness is the first event created by a member in a round.</p>
<p>定义5.9: 一个著名的证人是由社区来决定的，使用这里描述的算法。非正式地，如果许多成员在下一轮开始时看到证人，社区往往会认定证人是有名的。一个唯一的著名的见证的创建者在这一轮中所有著名见证中应该只会出现一次。在没有分叉的情况下，每个著名的证人都是一个唯一的著名证人。
A famous witness is a witness that has been decided to be famous by the community, using the algorithms described here. Informally, the community tends to decide that a witness is famous if many members see it by the start of the next round. A unique famous witness is a famous witness that does not have the same creator as any other famous witness created in the same round. In the absence of forking, each famous witness is also a unique famous witness.</p>
<p>定义5.10: 如果两个哈希图中包含的任何事件x都包含相同的x祖先，并且在这些祖先之间具有相同的父亲和自身父亲边缘，则哈希图A和B是一致的。
Hashgraphs A and B are consistent if for any event x contained in both hashgraphs, both contain the same set of ancestors for x, with the same parent and self-parent edges between those ancestors.</p>
<p>引理5.11: 所有成员都有一致的哈希图。
All members have consistent hashgraphs.</p>
<p>引理5.12: （强烈的看见引理） 如果一组事件(x, y)是分叉，而且在哈希图A中，x能够被事件z强烈的看到， 因此，在和A相同的哈希图B中，y将不能被任何事件强烈的看到。
if the pair of events (x, y) is a fork, and x is strongly seen by event z in hashgraph A , then y will not be strongly seen by any event in any hashgraph B that is consistent with A.</p>
<p>引理5.13: 如果哈希图A和B一致，而且都包含x事件，那么两者都会对x得到相同的回合数。
If hashgraphs A and B are consistent and both contain event x, then both will assign the same round created number to x.</p>
<p>引理5.14: 如果A和B一样，在A中的算法显示，在r轮中，成员m(0)投了v(A)票，给在r+1轮的成员m(1)，而且在B中的算法显示，m(0)在r轮的时候，投了v(B)给r+1轮中的m(1)的事件，则可以得出 v(A) = v(B)。
if hashgraphs A and B are consistent, and the algorithm running on A shows that a round r event by member m(0) sends a vote v(A) to member m(1) in round r + 1, and the algorithm running on B shows that a round r event by member m(0) sends a vote v(B) to an event by member m(1) in round r + 1, then v(A) = v(B).</p>
<p>引理5.15: 如果哈希图A和B是一致的，并且A决定好了在r回合中结果为v的拜占庭协议选举，并且B在r之前还没有决定，那么B将在r + 2回合或之前决定v。
if hashgraphs A and B are consistent, and A decides a Byzantine agreement election with result v in round r and B has not decided prior to r , then B will decide v in round r + 2 or before.</p>
<p>定理5.16: 对于任何单一的是/否问题，最终以相同的概率达成共识。
For any single YES/NO question, consensus is achieved eventually with probability 1.</p>
<p>定理5.17: 对于任何轮r，在r + 3轮中至少有一个事件的哈希图，那么在r轮中至少有一个证人会被共识算法著名，这个决定将由 每个 r+3 轮中的或更早轮中的见证人决定。
For any round number r, for any hashgraph that has at least one event in round r + 3, there will be at least one witness in round r that will be decided to be famous by the consensus algorithm, and this decision will be made by every witness in round r + 3 , or earlier.</p>
<p>定理5.18: 如果哈希图A不包含事件x，但确实包含x的所有父项，并且哈希图B是加了x的结果，并且x是在r轮创建的证人，并且A在r轮中至少有一个证人 其名气已经决定（无论是着名的还是不知名的），那么在B中x将被定为“不出名”。
If hashgraph A does not contain event x, but does contain all the parents of x, and hashgraph B is the result of adding x to A, and x is a witness created in round r , and A has at least one witness in round r whose fame has been decided (as either famous or as not famous), then x will be decided as “not famous” in B.</p>
<p>定理5.19: （拜占庭容错定理）。 由诚实成员创建的每个事件x最终将以相同的概率按被纳入到所有事件的总顺序中。
(Byzantine Fault Tolerance Theorem). Each event x created by an honest member will eventually be assigned a consensus position in the total order of events, with probability 1.</p>
<a class="header" href="#gossip算法" id="gossip算法"><h2>Gossip算法</h2></a>
<p>原始论文：Efficient Reconciliation and Flow Control for Anti-Entropy Protocols</p>
<p>别名 Anti-Entropy(反熵), “闲话算法”, “疫情传播算法”, “病毒感染算法”, “谣言传播算法”</p>
<p>之前的泛洪查找、路由算法都归属于这个范畴，不同的是Gossip给这类算法提供了明确的语义、具体实施方法及收敛性证明。</p>
<p>Gossip是一个带冗余的容错算法，更进一步，Gossip是一个最终一致性算法。</p>
<a class="header" href="#a1-gossip背景" id="a1-gossip背景"><h4>1. Gossip背景</h4></a>
<p>Gossip算法如其名，灵感来自办公室八卦，只要一个人八卦一下，在有限的时间内所有的人都会知道该八卦的信息，这种方式也与病毒传播类似，因此Gossip有众多的别名“闲话算法”、“疫情传播算法”、“病毒感染算法”、“谣言传播算法”。</p>
<p>但Gossip并不是一个新东西，之前的泛洪查找、路由算法都归属于这个范畴，不同的是Gossip给这类算法提供了明确的语义、具体实施方法及收敛性证明。</p>
<a class="header" href="#a2-gossip特点" id="a2-gossip特点"><h4>2. Gossip特点</h4></a>
<p>Gossip算法又被称为反熵（Anti-Entropy），熵是物理学上的一个概念，代表杂乱无章，而反熵就是在杂乱无章中寻求一致，这充分说明了Gossip的特点：在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。每个节点可能知道所有其他节点，也可能仅知道几个邻居节点，只要这些节可以通过网络连通，最终他们的状态都是一致的，当然这也是疫情传播的特点。</p>
<p>要注意到的一点是，即使有的节点因宕机而重启，有新节点加入，但经过一段时间后，这些节点的状态也会与其他节点达成一致，也就是说，Gossip天然具有分布式容错的优点。</p>
<a class="header" href="#a3-gossip本质" id="a3-gossip本质"><h4>3. Gossip本质</h4></a>
<p>Gossip是一个带冗余的容错算法，更进一步，Gossip是一个最终一致性算法。虽然无法保证在某个时刻所有节点状态一致，但可以保证在”最终“所有节点一致，”最终“是一个现实中存在，但理论上无法证明的时间点。</p>
<p>因为Gossip不要求节点知道所有其他节点，因此又具有去中心化的特点，节点之间完全对等，不需要任何的中心节点。实际上Gossip可以用于众多能接受“最终一致性”的领域：失败检测、路由同步、Pub/Sub、动态负载均衡。</p>
<p>但Gossip的缺点也很明显，冗余通信会对网路带宽、CUP资源造成很大的负载，而这些负载又受限于通信频率，该频率又影响着算法收敛的速度，后面我们会讲在各种场合下的优化方法。</p>
<a class="header" href="#a4-gossip节点的通信方式及收敛性" id="a4-gossip节点的通信方式及收敛性"><h4>4. Gossip节点的通信方式及收敛性</h4></a>
<p>根据原论文，两个节点（A、B）之间存在三种通信方式:</p>
<pre><code>push: A节点将数据(key,value,version)及对应的版本号推送给B节点，B节点更新A中比自己新的数据
pull：A仅将数据key,version推送给B，B将本地比A新的数据（Key,value,version）推送给A，A更新本地
push/pull：与pull类似，只是多了一步，A再将本地比B新的数据推送给B，B更新本地
</code></pre>
<p>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，push需通信1次，pull需2次，push/pull则需3次，从效果上来讲，push/pull最好，理论上一个周期内可以使两个节点完全一致。直观上也感觉，push/pull的收敛速度是最快的。</p>
<p>假设每个节点通信周期都能选择（感染）一个新节点，则Gossip算法退化为一个二分查找过程，每个周期构成一个平衡二叉树，收敛速度为O(n2 )，对应的时间开销则为O(logn )。这也是Gossip理论上最优的收敛速度。但在实际情况中最优收敛速度是很难达到的，假设某个节点在第i个周期被感染的概率为pi ,第i+1个周期被感染的概率为pi+1 ，则pull的方式:</p>
<p>P(i+1) = Pi^2</p>
<p>而push为：</p>
<p>Pi+1) = Pi(1-1/n)^(n(1-pi))</p>
<p>显然pull的收敛速度大于push，而每个节点在每个周期被感染的概率都是固定的p(0&lt;p&lt;1)，因此Gossip算法是基于p的平方收敛，也成为概率收敛，这在众多的一致性算法中是非常独特的。</p>
<p>个Gossip的节点的工作方式又分两种：</p>
<pre><code>Anti-Entropy（反熵）：以固定的概率传播所有的数据
Rumor-Mongering（谣言传播）：仅传播新到达的数据
</code></pre>
<p>Anti-Entropy模式有完全的容错性，但有较大的网络、CPU负载；Rumor-Mongering模式有较小的网络、CPU负载，但必须为数据定义”最新“的边界，并且难以保证完全容错，对失败重启且超过”最新“期限的节点，无法保证最终一致性，或需要引入额外的机制处理不一致性。我们后续着重讨论Anti-Entropy模式的优化。</p>
<a class="header" href="#a5-anti-entropy的协调机制" id="a5-anti-entropy的协调机制"><h4>5. Anti-Entropy的协调机制</h4></a>
<p>协调机制是讨论在每次2个节点通信时，如何交换数据能达到最快的一致性，也即消除两个节点的不一致性。上面所讲的push、pull等是通信方式，协调是在通信方式下的数据交换机制。协调所面临的最大问题是，因为受限于网络负载，不可能每次都把一个节点上的数据发送给另外一个节点，也即每个Gossip的消息大小都有上限。在有限的空间上有效率地交换所有的消息是协调要解决的主要问题。</p>
<p>在讨论之前先声明几个概念：</p>
<pre><code>令N = {p,q,s,...}为需要gossip通信的server集合，有界大小
令(p1,p2,...)是宿主在节点p上的数据，其中数据有(key,value,version)构成，q的规则与p类似。
</code></pre>
<p>为了保证一致性，规定数据的value及version只有宿主节点才能修改，其他节点只能间接通过Gossip协议来请求数据对应的宿主节点修改。</p>
<a class="header" href="#a51-精确协调precise-reconciliation" id="a51-精确协调precise-reconciliation"><h5>5.1 精确协调（Precise Reconciliation）</h5></a>
<p>精确协调希望在每次通信周期内都非常准确地消除双方的不一致性，具体表现为相互发送对方需要更新的数据，因为每个节点都在并发与多个节点通信，理论上精确协调很难做到。精确协调需要给每个数据项独立地维护自己的version，在每次交互是把所有的(key,value,version)发送到目标进行比对，从而找出双方不同之处从而更新。但因为Gossip消息存在大小限制，因此每次选择发送哪些数据就成了问题。当然可以随机选择一部分数据，也可确定性的选择数据。对确定性的选择而言，可以有最老优先（根据版本）和最新优先两种，最老优先会优先更新版本最新的数据，而最新更新正好相反，这样会造成老数据始终得不到机会更新，也即饥饿。</p>
<p>当然，开发这也可根据业务场景构造自己的选择算法，但始终都无法避免消息量过多的问题。</p>
<a class="header" href="#a52-整体协调scuttlebutt-reconciliation" id="a52-整体协调scuttlebutt-reconciliation"><h5>5.2 整体协调（Scuttlebutt Reconciliation）</h5></a>
<p>整体协调与精确协调不同之处是，整体协调不是为每个数据都维护单独的版本号，而是为每个节点上的宿主数据维护统一的version。比如节点P会为(p1,p2,...)维护一个一致的全局version，相当于把所有的宿主数据看作一个整体，当与其他节点进行比较时，只需必须这些宿主数据的最高version，如果最高version相同说明这部分数据全部一致，否则再进行精确协调。</p>
<p>整体协调对数据的选择也有两种方法：</p>
<pre><code>广度优先：根据整体version大小排序，也称为公平选择
深度优先：根据包含数据多少的排序，也称为非公平选择。因为后者更有实用价值，所以原论文更鼓励后者
</code></pre>
<a class="header" href="#a6-cassandra中的实现" id="a6-cassandra中的实现"><h4>6. Cassandra中的实现</h4></a>
<p>经过验证，Cassandra实现了基于整体协调的push/push模式，有几个组件：</p>
<p>三条消息分别对应push/pull的三个阶段：</p>
<pre><code>GossipDigitsMessage
GossipDigitsAckMessage
GossipDigitsAck2Message
</code></pre>
<p>还有三种状态：</p>
<pre><code>EndpointState：维护宿主数据的全局version，并封装了HeartBeat和ApplicationState
HeartBeat：心跳信息
ApplicationState：系统负载信息（磁盘使用率）
</code></pre>
<p>Cassandra主要是使用Gossip完成三方面的功能：</p>
<pre><code>失败检测
动态负载均衡
去中心化的弹性扩展
</code></pre>
<a class="header" href="#a7-总结" id="a7-总结"><h4>7. 总结</h4></a>
<p>Gossip是一种去中心化、容错而又最终一致性的绝妙算法，其收敛性不但得到证明还具有指数级的收敛速度。使用Gossip的系统可以很容易的把Server扩展到更多的节点，满足弹性扩展轻而易举。</p>
<p>唯一的缺点是收敛是最终一致性，不使用那些强一致性的场景，比如2pc。</p>
<a class="header" href="#a4-the-spectre-protocol" id="a4-the-spectre-protocol"><h2>4. THE SPECTRE PROTOCOL</h2></a>
<a class="header" href="#a-the-generation-of-the-block-dag" id="a-the-generation-of-the-block-dag"><h3>A. The generation of the block DAG</h3></a>
<p>As in Bitcoin, participating nodes (called miners) create blocks of transactions by solving PoW puzzles. A block specifies its direct predecessors by referencing their ID in its header (a block’s ID is obtained by applying a collision resistant hash to its header); we will describe in the next subsection how these predecessors are chosen. This results in a structure of a direct acyclic graph (DAG)  of  blocks  (as  blocks  can  only  reference  blocks  created  before  them),  denoted  typically G = (C,E). Here, C represents blocks and E represents the hash references. We will frequently write z ∈ G instead of z ∈ C.
和比特币一样，参与节点（称为矿工）通过解决PoW谜题来创建交易块。 一个块通过在其头中引用它们的ID来指定它的直接前辈（一个块的ID是通过对其头部应用抗冲突散列来获得的）; 我们将在下一小节描述如何选择这些前辈。 这导致块的直接无环图（DAG）的结构（因为块只能参考在它们之前创建的块），通常表示为G =（C，E）。 这里，C表示块，E表示散列引用。 我们将频繁地写z∈G而不是z∈C。</p>
<p>past(z,G) ⊂ C denotes the subset of blocks reachable from z, and similarly future(z,G)⊂ C denotes the subset of blocks from which z is reachable; these are blocks that were provably created before and after z, correspondingly. Note that an edge in the DAG points back in time, from  the  new  block  to  previously created blocks which it extends. A node does not consider a block as valid until it receives its entire past set. We denote by cone(z,G) the set of blocks that the DAG directly orders with respect to z: cone(z,G) := past (z,G) ∪ {z} ∪ future (z,G), and by anticone (z) the  complementary  of cone (z,G).  The  set past (b,G) is  fixed  once  and  for all at the creation of b (in sharp contrast to future (z,G) and anticone (z,G) that may grow as blocks are added later to the DAG), hence we can simply write past (b) without noting the context.
past（z，G）C表示可从z到达的块的子集，并且类似地future（z，G）C表示可从其中z到达的块的子集; 这些是相应地在z之前和之后创建的块。 请注意，DAG中的一条边从时间上指向新块，以及之前创建的块。 一个节点在接收到过去的整个集合之前不会将其视为有效。 我们用锥（z，G）表示DAG关于z直接排序的块集合：cone（z，G）：= past（z，G）∪{z}∪future（z，G）和 通过anticone（z）锥（z，G）的互补。 （b，G）在创建b时一劳永逸地固定（与将来添加到DAG中的块可能增长的未来（z，G）和anticone（z，G）形成鲜明对比）， 因此我们可以简单地写下过去的（b）而不注意上下文。</p>
<p>The unique block genesis is the block created at the inception of the system, and every valid block must have it in its past set. In addition, we relate to a hypothetical block, virtual (G). This block  satisfies past (virtual(G)) = G.  While  its  role  is  merely  methodological, virtual(G) can also be thought of as representing the next block that a node whose current observed DAG is G attempts to create G(v t) denotes  the  block  DAG  observed  by  node v ∈ N at  time t.  This  DAG  represents  the history of all (valid) block-messages received by the node, instantiating the abstract data structure assumed in Section 2.
独特的区块成因是在系统开始时创建的区块，并且每个有效的区块必须在其过去的集合中具有它。 另外，我们涉及一个虚拟块，虚拟（G）。 该块满足过去（虚拟（G））= G。虽然它的作用仅仅是方法论，但虚拟（G）也可以认为代表下一个块，其当前观察到的DAG是G的节点尝试创建G（vt） 表示在时间t由节点v∈N观察到的块DAG。 这个DAG表示节点接收的所有（有效）块消息的历史，实例化第2节中假设的抽象数据结构。</p>
<a class="header" href="#b-the-mining-protocol" id="b-the-mining-protocol"><h3>B. The mining protocol</h3></a>
<p>SPECTRE’s instructions to miners are extremely simple:</p>
<ol>
<li>When creating or receiving a block, transmit the block to all peers.</li>
<li>When creating a block, embed in its header a list containing the hash of all leaf-blocks (blocks with in-degree 0) in the locally-observed DAG.
Note  that  these  instructions  allow  miners  to  operate  concurrently  irrespective  of  potential conflicts in the contents of their blocks.
SPECTER对矿工的指示非常简单：
1）创建或接收块时，将块发送给所有对等体。
2）创建块时，在其头中嵌入一个列表，其中包含本地观察的DAG中所有叶块（具有度0的块）的散列。
请注意，这些说明允许矿工同时进行操作，而不管他们的块内容有潜在冲突。</li>
</ol>
<a class="header" href="#c--the-txo-protocol" id="c--the-txo-protocol"><h3>C.  The TxO protocol</h3></a>
<p>Overview. As the block DAG may contain conflicting transactions, we must provide a method for nodes to interpret the DAG and extract from it the set of accepted transactions. Doing so in a  way  that  will  be  agreed  upon  by  all  nodes  (eventually)  is  the  main  challenge  of  SPECTRE. We now describe how this is done.
概述。 由于块DAG可能包含冲突的事务，因此我们必须提供一种方法让节点解释DAG并从中提取已接受的事务集。 这样做的方式将由所有节点（最终）达成一致，这是SPECTER的主要挑战。 我们现在描述这是如何完成的。</p>
<p>The  topology  of  a  block  DAG G induces  a  natural  precedence-relation  over  blocks:  if x is reachable  from y (i.e., x∈past(y))  then x precedes y,  as  it  was  provably  created  before  it. SPECTRE extends this relation into a complete relation over G’s blocks, denoted ≺. This order is immediately translatable into an order over transactions in G: tx1 precedes tx2 if the block containing the former precedes that containing the latter. This relation, in turn, induces a natural subset  of  accepted  transactions: tx is  accepted  if  it  precedes  all  of  its  conflicting  transactions in G.  The  relation ≺ is  generated  by  a  pairwise  vote  procedure  that  occurs  independently  for every pair of blocks. The operation of this layer will be explained in the next subsections.
块DAG G的拓扑在块上引入自然的优先关系：如果x从y（即，x∈past（y））可到达，则x在y之前，因为它可以在其之前被创建。 SPECTER将此关系扩展为G块上的完整关系，记为≺。 如果包含前者的块在包含后者的块之前，该订单可立即转换为G：tx1之前的订单中的订单。 反过来，这个关系引发了一个可接受事务的自然子集：如果它在G中的所有冲突事务之前，则tx被接受。关系≺由配对投票过程生成，该过程独立于每对块进行。 这一层的操作将在下一小节中解释。</p>
<p>Although  we  may  at  times  refer  to ≺ as  though  it  orders  blocks,  we  stress  that ≺ is  not necessarily a transitive relation. It is possible to have a series of blocks that precede each other cyclically. The lack of a total linear ordering over blocks is in fact the way SPECTRE utilizes the weaker consensus requirements of our framework, as a linear order is equivalent to solving the consensus problem [3].
虽然我们有时可能会提到≺好像命令块一样，但我们强调≺不一定是传递关系。 可能会有一系列循环前后的块。 缺少块的总线性排序实际上是SPECTER利用我们框架的较弱共识需求的方式，因为线性排序相当于解决共识问题[3]。</p>
<p>Pairwise  ordering  of  blocks. The  basic  layer  of  SPECTRE  involves  deciding  on  a  pairwise order  over  the  block  DAG.  Fix  two  blocks x,y ∈ G.  In  order  to  decide  if x ≺ y or y ≺ x, we  interpret  the  structure  of  the  DAG  as  representing  an  abstract  vote.  Every  block z ∈ G is considered a voter with respect to the pair (x,y), and its vote is inferred from the structure of the DAG. We represent a vote by a number in {−1, 0, +1}, and we denote z’s voting-profile on all pairs by vote (z,G). vote x,y (z,G) = −1 represents x preceding y (x≺y), vote x,y (z,G) = +1 represents y preceding x, and vote x,y (z,G) = 0 represents a tie. Importantly, vote (z,G) is an asymmetric relation: vote y,x (z,G) = − vote x,y (z,G).
块的成对排序。 SPECTER的基本层涉及确定块DAG上的成对顺序。 修正两个块x，y∈G.为了决定x≺y还是y≺x，我们将DAG的结构解释为表示抽象投票。 每个块z∈G被认为是一个关于对（x，y）的选举人，并且它的投票是从DAG的结构中推断出来的。 我们用{-1,0，+1}中的一个数字来表示投票，并且我们用投票（z，G）表示z在所有对上的投票配置文件。 投票x，y（z，G）= -1代表x之前的y（x≺y），投票x，y（z，G）= +1代表y前面的x，投票x，y（z，G）= 0代表一个领带。 重要的是，vote（z，G）是一个不对称关系：vote y，x（z，G）= - vote x，y（z，G）。</p>
<p>To  simplify  presentation,  we  associate  a  vote  with virtual (G) as  well.  Recall  that  the virtual  block  of G is  a  hypothetical  block  which  satisfies past (virtual (G))  = G.  The  vote of virtual (G) represents  essentially  the  aggregated  vote  of  the  entire  block  DAG.  The  basic rules of z’s vote, for any z ∈ G ∪{virtual (G)}, are as follows:
为了简化演示，我们还将投票与虚拟（G）相关联。 回想一下，G的虚拟块是满足过去（虚拟（G））= G的假设块。虚拟（G）的投票基本上表示整个块DAG的聚合投票。 对于任何z∈G∪{virtual（G）}，z的投票基本规则如下：</p>
<ol>
<li>if z ∈ G is  in future (x) but  not  in future (y) then  it  will  vote  in  favour  of x (i.e.,  for x ≺ y).
如果z∈G future（x）但 future（y），则它将投票赞成x（即，对于x≺y）。</li>
<li>if z ∈ G is in future (x) ∩ future (y) then z’s vote will be determined recursively according to  the  DAG  that  is  reduced  to  its  past,  i.e.,  it  has  the  same  vote  as virtual (past (z)).  If the result of this vote is a tie, z breaks it arbitrarily.
如果z∈G未来（x）∩future（y），则z的投票将根据减少到其过去的DAG递归确定，即它具有与虚拟（过去（z））相同的投票。 如果这次投票的结果是平局，z就会任意打破。</li>
<li>if z∈ G is not in the future of either blocks then it will vote the same way as the vote of the majority of blocks in its own future.
如果z∈G不在任何区块的未来，那么它将以与未来大多数区块的投票相同的方式投票。</li>
<li>if z is the virtual block of G then it will vote the same way as the vote of the majority of blocks in G.
如果z是G的虚拟块，那么它将以与G中大多数块的投票相同的方式投票。</li>
<li>finally,  (for  the  case  where z equals x or y), z votes  for  itself  to  succeed  any  block  in past (z) and to precede any block outside past (z).
最后（对于z等于x或y的情况），z投票赞成自己继续past（z）中的任何块，并且在past（z）之外的任何块之前投票。</li>
</ol>
<p>Intuitively,  the  first  rule  dictates  that  a  block  that  was  honestly  published  gain  votes  over blocks  that  are  secretly  withheld,  as  honest  nodes  keep  adding  new  blocks  to  its  future  set. The second and fourth rules together guarantee majority amplification, as new blocks add votes that  comply  with  and  enhance  previous  decisions.  The  third  rule  is  the  most  subtle;  basically, it allows blocks in past (x) (in addition to those in future (x)) to vote in its favour against y, in case y was withheld for a long time. This is needed to counter a pre-mining attack scheme, which will be described in future sections. Notice that all votes respect the DAG’s topology: If x is reachable from y then all blocks vote unanimously x ≺ y.
直观地说，第一条规则规定，一个真正发布的区块会获得对隐藏的隐藏区块的投票，因为诚实的节点不断为其未来集合添加新的区块。 第二和第四条规则共同保证大部分放大，因为新的区块增加了符合并加强先前决定的投票。 第三条规则是最微妙的; 基本上，它允许past（x）的区块（除了future（x）的区块）投票赞成反对y，以防y被长时间扣留。 这是对付预挖矿攻击计划所需要的，这将在以后的章节中介绍。 请注意，所有投票都尊重DAG的拓扑结构：如果x是从y到达的，那么所有块都一致投票x≺y。</p>
<p>Figure 1 illustrates the voting procedure with regards to a single pair of blocks (x, y). Additional examples along with intuition regarding this key algorithm are provided in Appendix A.
图1说明了关于一对块（x，y）的投票程序。附录A提供了有关此关键算法的其他示例以及直觉。</p>
<p>Property 4.Once a block is published, the set of blocks that precede it in the pairwise ordering closes fast—w.h.p. it consists only of blocks published before or right after its publication.
属性4.一旦发布块，成对排序之前的块集合将关闭fast-w.h.p。 它仅包含在其发布之前或之后发布的块。</p>
<p>The implications of this guarantee to the security of transactions is immediate, at least at the intuitive level: A user whose transaction is embedded in some published block x can guarantee its safety by waiting some time after x’s publication before accepting it; he is then guaranteed that  any  block  published  later  on  –  and  that  might  contain  a  conflicting  transaction  –  will  be preceded  by x hence  will  not  threaten  the  acceptance  of  his  transaction.  In  Section  5  we  will explain how this guarantee is achieved.
这种保证对交易安全的影响是立竿见影的，至少在直观的层面上是这样的：一个用户的交易被嵌入到某个已发布的块x中，可以通过在x发布之前等待一段时间来保证其安全性，然后再接受它; 那么他可以保证，任何后来发布的区块 - 可能包含冲突的交易 - 都将在x之后，因此不会威胁接受他的交易。 在第5节中，我们将解释如何实现这一保证。</p>
<p>Accepting  transactions. Equipped  with  the  pairwise  relation  over  blocks,  we  now  turn  to construct  the  set  of  accepted  transactions.  To  maintain  consistency,  we  mark  a  transaction  as accepted iff all three conditions below hold true:
接受交易。 通过块上的配对关系，我们现在转而构建一组已接受的交易。 为了保持一致性，如果以下所有三个条件都成立，我们将交易标记为已接受：</p>
<ol>
<li>all of its inputs have been accepted.</li>
<li>all conflicting transactions from its anticone set (i.e., that are not related to it topologically) are contained in blocks that are preceded by the block containing the transaction.</li>
<li>all conflicting transactions from its past set (i.e., that precede it in the DAG, topologically) have been rejected.
1）所有的输入都被接受。
2）所有在它的anticone集合中的（即与拓扑无关的交易）冲突交易都包含在包含该交易的块的前面的块中。
3）所有与past相冲突的交易（即DAG之前的拓扑交易）都被拒绝。</li>
</ol>
<p>Algorithm  2  implements  these  rules,  and  outputs  a  set  of  accepted  transactions.  It  operates recursively,  and  should  be  initially  called  with TxO(G,G) (we  later  denote  this  simply  by TxO (G)).  In  the  algorithm,  the  notation ZG(tx) stands  for  all  blocks  in G that  contain tx. Some complexity arises due to possible multiple copies of the same transaction in the DAG; we denote by [tx] the equivalence class containing all of tx’s copies.
算法2实现这些规则，并输出一组已接受的事务。 它递归地运行，并且应该首先用TxO（G，G）调用（我们稍后通过TxO（G）简单地表示这一点）。 在算法中，符号ZG（tx）代表G中包含tx的所有块。 由于DAG中可能存在多个相同事务的副本，因此会出现一些复杂性; 我们用[tx]表示包含所有tx副本的等价类。</p>
<p>The  third  part  of  the  SPECTRE  protocol,  namely,  the RobustTxO procedure,  is  rather involved. We defer its description to Appendix C.
SPECTER协议的第三部分，即RobustTxO过程相当复杂。 我们将其描述推迟到附录C.</p>
<a class="header" href="#appendix-c" id="appendix-c"><h1>APPENDIX C</h1></a>
<p>easure the robustness of this order,</p>
<a class="header" href="#a-robustness-of-the-block-pairwise-ordering-块成对排序的鲁棒性" id="a-robustness-of-the-block-pairwise-ordering-块成对排序的鲁棒性"><h3>A. Robustness of the block pairwise ordering 块成对排序的鲁棒性</h3></a>
<p>Assume that in the order of the current observable DAG the block x precedes y. We need a method to measure how likely is it that this relation will persist forever. Algorithm 3 outputs an upper bound on the probability that an attacker will be able to reverse the relation x ≺ y. When the  argument y is  unspecified,  the  interpretation  of  the  algorithm’s  output  is x’s  robustness against  an  unseen  block  (withheld  by  an  attacker  or  yet  to  be  created).  In  the  algorithm, gap (b,G) denotes the size of the set {z∈anticone(b,G): vote z,b (virtual(G))≥0}.  The notation 〈G,z,K〉will be explained in the paragraphs that follow.
假设按照当前可观察的DAG的顺序，块x在y之前。 我们需要一种方法来衡量这种关系将永远持续下去的可能性。 算法3输出攻击者将能够逆转关系x≺y的概率的上界。 当参数y未指定时，算法输出的解释是x针对未被看见的块（由攻击者隐瞒或尚未创建）的鲁棒性。 在算法中，gap（b，G）表示集合{z∈anticone（b，G）的大小：vote z，b（virtual（G））≥0}。 符号&lt;G，z，K&gt;将在下面的段落中解释。
In the algorithms below, we omit for the sake of brevity the following parameters which the user must set by himself: α – maximal size of attacker, d – upper bound on D (the recent delay diameter in the network), λ – the block creation rate.
在下面的算法中，为了简洁起见，我们省略了用户必须自己设置的以下参数：α - 攻击者的最大尺寸，d - D上的上限（网络中最近的延迟直径），λ - 块 创造率。</p>
<p>Our work is most similar to the SPECTRE protocol [8]. SPECTRE enjoys both high throughput and  fast  confirmation  times.<br />
It  uses  the  structure  of  the  DAG  as  representing  an  abstract  vote regarding the order between each pair of blocks.
One caveat of SPECTRE is that the output of this pairwise ordering may not be extendable to a full linear ordering, due to possible Condorcet cycles.
PHANTOM solves this issue and provides a linear ordering over the blocks of the DAG.
As such, PHANTOM can support consensus regarding any general computation, also known as Smart Contracts , which SPECTRE cannot.
Indeed, in order for a computation or contract to be processed  correctly  and  consistently,  the  full  order  of  events  in  the  ledger  is  usually  required, and particularly the order of inputs to the contract.
PHANTOM’s linear ordering does not come without  cost—confirmation  times  are  mush  slower  than  those  in  SPECTRE.<br />
In  Section  7  we describe how the same system can simultaneously enjoy the best of both protocols.</p>
<p>我们的工作与SPECTER协议最相似[8]。 SPECTER拥有高吞吐量和快速确认时间。
它使用DAG的结构来表示关于每对块之间的顺序的抽象投票。
SPECTER的一个警告是，由于可能的Condorcet循环，这种成对排序的输出可能无法扩展到全线性排序。
PHANTOM解决了这个问题，并提供了DAG块的线性排序。
因此，PHANTOM可以支持关于任何一般计算的共识，也称为智能合同，而SPECTER不能。
事实上，为了正确和一致地处理计算或合同，通常需要分类账中事件的完整顺序，特别是合同输入的顺序。
PHANTOM的线性订购不会在没有成本确认的情况下比SPECTER中的时间慢得多。
在第7节中，我们描述了同一个系统如何同时享受这两种协议中最好的。</p>
<a class="header" href="#disjoint-sections-不重合的分组" id="disjoint-sections-不重合的分组"><h4>disjoint Sections 不重合的分组</h4></a>
<ul>
<li>原先的分组是可以重合的，现在要将分组做到不重合</li>
<li>组的大小是可以变化的</li>
<li>每组人都知道对方，可以算出下一个组的离自己最近的节点.这样知道选择路由就不会产生交叉?</li>
<li>更好的安全性</li>
<li>可以快速删除一个节点，因为知道是谁那里连接了这个节点</li>
<li>能够自动调节组大小？</li>
<li>每组最少有 groupsize + 1个成员</li>
</ul>
<p>核心观点就是保持组的大小，当有新增加的成员，减少成员，组间进行合并和分裂</p>
<a class="header" href="#tortoise-and-hares-consensus-the-meshcash-framework-for-incentive-compatible-scalable-cryptocurrencies-乌龟与兔子共识-meshcash--激励兼容的可扩展加密货币框架" id="tortoise-and-hares-consensus-the-meshcash-framework-for-incentive-compatible-scalable-cryptocurrencies-乌龟与兔子共识-meshcash--激励兼容的可扩展加密货币框架"><h3>Tortoise and Hares Consensus: the Meshcash Framework for Incentive-Compatible, Scalable Cryptocurrencies 乌龟与兔子共识： Meshcash--激励兼容的可扩展加密货币框架</h3></a>
<p><a href="https://eprint.iacr.org/2017/300.pdf">原始论文</a></p>
<a class="header" href="#a数字货币的有效性" id="a数字货币的有效性"><h5>数字货币的有效性</h5></a>
<ol>
<li>有限的供应</li>
<li>无双花部分</li>
<li>转账的可行</li>
<li>历史记录的一致</li>
<li>记录不可篡改</li>
</ol>
<a class="header" href="#algorand-可扩展的拜占庭协议" id="algorand-可扩展的拜占庭协议"><h3>Algorand: 可扩展的拜占庭协议</h3></a>
<a class="header" href="#a三种挑战" id="a三种挑战"><h5>三种挑战</h5></a>
<ol>
<li>Sybil女巫攻击拜占庭协议</li>
<li>适用百万级别用户</li>
<li>弹性应对拒绝服务攻击和持续稳定服务</li>
</ol>
<a class="header" href="#a应对方式" id="a应对方式"><h5>应对方式</h5></a>
<ol>
<li>Weight users: 有效用户。（节点需要余额）</li>
<li>Consensus by committee: 共识委员会。（随机选举：影响因素：Weight），面临选举人被攻击的问题。</li>
<li>Cryptographic sortition: 密码学抽签。隐秘而且无交互的选举。用户自己在本地执行VRF算法，确认自己是否被选举上。通过自己的私钥和公共信息。如果被选举上，会生成一个简短的字符串来证明。当自己打包好信息之后，只要向别人广播的时候，带上这个字符串，别人就可以验证是否真的被选举上了。</li>
<li>Participant replacement: 参与者变更。不保留任何私人状态（不受任何私人信息控制），达到每次都会变更委员会成员。</li>
</ol>
<a class="header" href="#a目标和假设" id="a目标和假设"><h4>目标和假设</h4></a>
<ol>
<li>Safety goal. 安全目标。诚实会接受诚实的。Eclipse attack(日蚀攻击)。</li>
<li>Liveness goal. 活跃目标。</li>
<li>Assumptions. 一般常见的假设。</li>
</ol>
<p>强同步与弱同步，强同步可以解决活跃的目标。弱同步结果安全目标。所有用户之间有弱同步的时钟，保证相差不大。</p>
<a class="header" href="#a总览和思路" id="a总览和思路"><h4>总览和思路</h4></a>
<p>区块组织形式与比特币类似，使用Gossip协议去传输交易。BA提供了两种共识: final共识与tentative共识。final共识意味着这个区块已经达成了最终的共识，被稳定确认了，后续区块可以接着此区块继续连接下去。tentative共识意味着这个区块，有人能够看到同轮的其他区块。这个区块上的所有交易都处于未确认的状态。Gossip协议来传输新产生的交易与区块。区块提案产生区块生成者们。BA协议确定最终的区块。</p>
<a class="header" href="#a密码学抽签-cryptographic-sortition" id="a密码学抽签-cryptographic-sortition"><h4>密码学抽签 Cryptographic Sortition</h4></a>
<p>VRF函数保证选举的本地执行和不用交互，参数包括（该轮的随机种子，自身的私钥，Weight信息）-&gt; (hash, proof, J)证明信息。首先会确定角色：打包者和委员会成员。十分重要的一点就是需要有余额用于Weight证明。一个用户会被选举上超过一次，所以有了一个参数J，用于记录被选举的次数。也就是有了'sub-user'这个概念。验证的时候，带入公钥，hash等信息，就可以得到J，算出这个用户是否被选中。</p>
<p>其次是种子(seed)生成算法。r轮中的seed是在r-1轮基础上生成的。如果r-1轮没有生效seed, 则通过计算所有打包区块确认这轮的seed。seed为了防止被攻击者影响，会在R轮之后，重新刷新一次，执行一个mod算法。</p>
<p>如何在弱同步的网络中，防止用户执行empty block（上一块区块无效）算法。在计算r轮的时候，所有用户都会去计算r-1-(r mod R)的时间戳，通过对比上次区块的时间戳。</p>
<a class="header" href="#a区块提案-block-proposal" id="a区块提案-block-proposal"><h4>区块提案 Block Proposal</h4></a>
<p>sortition threshold 抽签阀值, 大于1，测算出来的是26最好。是否意味着每轮打包者的数量应该控制在26左右?
区块传输的最小化。根据候选区块的优先级传输。没轮的等待时间是一个固定的数。从收到上一轮的区块开始计算时间。</p>
<a class="header" href="#ba" id="ba"><h4>BA</h4></a>
<p>两个实现阶段。一个是在两个候选区块中选择其中一个，另外一个是在有效无效区块中达成一致。这两个动作都是有交互的步骤的。第一阶段包括两个步骤，第二阶段如果最佳候选节点是诚实的，则需要两步，如果不是诚实的则需要11步。在每一步中，委员会成员都会进行投票。当投票结果超过某一个阀值之后，该结果就作为下一步的条件。</p>
<p>主要的步骤。就是确认这个区块是否是最终定型的区块，还是候选区块。为了高效，投票都是针对区块hash进行的，而不是区块内容。如果最终没有得到想要的结果BlockOfHash的结果，就需要与其他用户通信确认。算法形式：</p>
<pre><code>procedure BA*(ctx, round, block): //ctx当前区块链的状态（包括seed, user weight, 最后的确认区块），round轮数，block是得分最高的候选区块
hblock &lt;- Reduction(ctx, round, H(block))
hblock* &lt;- BinaryBA*(ctx, round, hblock)
r &lt;- CountVotes(ctx, round, FINAL, T_final, t_final, x_step)
if hblock* = r then
    return FINAL, BlockOfHash(hblock*)
else
    return TENTATIVE, BlockOfHash(hblock*)

</code></pre>
<p>投票机制。委员会成员执行。为了检验这个用户是否是委员会的一员。第一步是发送投票，就是说这个委员会成员被选中了，发送一个自己签名的信息，在信息里面包含一些区块信息，用以绑定内容， 包含自身状态下的最先前的一个区块。</p>
<pre><code>procedire CommiteeVote(ctx, round, setp, t, value):
role &lt;- (&quot;committee&quot;, round, step)
sorthash, x, j &lt;- Sortition(user.sk, ctx, seed, t, role, ctx.weight[user.pk], ctx.W)
if j &gt; 0 then
    Gossip(user.pk, Signed(round, step, sorthash, x, H(ctx.last_block), value))

</code></pre>
<p>统计投票信息。分为统计投票和处理投票信息。</p>
<pre><code>procedure CountVotes(ctx, round, step, T, t, x):
start &lt;- Time()
counts &lt;- {} //hash table, new keys mapped to 0
voters &lt;- {}
msgs &lt;- incomingMsgs[round, step].iterator()
while True do
    m &lt;- msgs.next()
    if m = Null then
        if Time() &gt; start + x then return TIMEOUT
    else
        votes, value, sorthash &lt; PorcessMsg(ctx, t, m)
        if pk in votes or votes = 0 then continue
        voters += {pk}
        counts[value] += votes
        if counts[value] &gt; T * t then
            return value

procedure ProcessMsg(ctx, t, m):
pk, signed_m &lt;- m
if verifySignature(pk, signed_m) != OK then
    return 0, 0, Null
round, step, sorthash, x, hprev, value &lt;- signed_m
if hprev != H(ctx.last_block) then return 0, Null, Null
votes &lt;- VerifySort(pk, sorthash, x, ctx.seed, t, (&quot;committee, round, step&quot;), ctx.weight[pk], ctx.W)
return votes, value, sorthash

</code></pre>
<p>还原步骤。对于这是一个有效区块，还是一个无效（空）区块达成共识。对于区块链的活跃(liveness)是十分重要的部分。第一步是对区块hash值进行投票，第二步是判断投票结果是否满足 T * t, 用来确定是否该接受这个区块。</p>
<pre><code>procedure Reduction(ctx, round, hblock):
CommiteeVote(ctx, round, REDUCTION_ONE, t_step, hblock)
hblock1 &lt;- CountVotes(ctx, round, REDUCTION_ONE, T_step, t_step, x_block + x_step)
empty_hash &lt;- H(Empty(round, H(ctx.last_block)))
if hblock1 = TIMEOUT then
    CommiteeVote(ctx, round, REDUCTION_TWO, t_step, empty_hash)
else
    CommiteeVote(ctx, round, REDUCTION_TWO, t_step, hblock1)
hblock2 &lt;- CountVotes(ctx, round, REDUCTION_TWO, T_step, t_step, x_step)
if hblock2 = TIMEOUT then return empty_hash
else return hblock2
</code></pre>
<p>二元共识协议。Binary Agreement.</p>
<a class="header" href="#algorand-区块链" id="algorand-区块链"><h4>Algorand 区块链</h4></a>
<a class="header" href="#vrf应对双花攻击" id="vrf应对双花攻击"><h4>VRF应对双花攻击</h4></a>
<a class="header" href="#a密码抽签-cryptographic-sortition" id="a密码抽签-cryptographic-sortition"><h3>密码抽签 cryptographic sortition</h3></a>
<a class="header" href="#a选出验证者和领导者" id="a选出验证者和领导者"><h4>选出验证者和领导者</h4></a>
<p>假设在第r轮（可以理解为产生第r个区块的时间段）开始时，“种子”参数为Qr-1（表现为一个由0和1组成的长度为256的字符串），PKr-k是第r-k轮结束后系统中活跃的用户/公钥（活跃的标志是至少参与过一笔交易）的集合，其中k被称为回溯参数或安全参数。Qr-1和PKr-k属于公共知识（common knowledge）。</p>
<p>凭证的定义。对每一个PKr-k中的用户i，他使用自己的私钥对“种子”参数Qr-1进行电子签名后（用函数SIGi来表示）并输入哈希函数（用函数H来表示），得到自己的凭证H（SIGi(r,1,Qr-1))(函数SIGi有多个输入参数时，表示将这些参数简单串联后再进行电子签名，下同）。哈希函数的性质决定了：</p>
<p>1.凭证是一个近乎随机的、由0和1组成的长度为256的字符串，并且不同用户的凭证几乎不可能相同；</p>
<p>2.由凭证构建的2进制小数0.H(SIGi(r,1,Qr-1))（也就是将凭证字符串写到小数点后）在0和1之间均匀分布。</p>
<p>“潜在领导者”的选择。对0和1之间的一个数p，0.H(SIGi(r,1,Qr-1))≤p发生的概率为p，称所有满足此条件的用户为“潜在领导者”（也是这一步的“验证者”）。p使得以1-10-18的概率，在所有“潜在领导者”中，至少有一个是诚实的。</p>
<p>“领导者”的选择。在所有“潜在领导者”中，存在一个用户lr，其凭证按字典排序最小。也就是，对所有0.H(SIGi(r,1,Qr-1))≤p的用户i，均有H(SIGlr(r,1,Qr-1))≤H(SIGi(r,1,Qr-1))。用户lr就是第r轮的“领导者”。</p>
<p>“验证者”的选择。第r轮第s步（s&gt;1）的“验证者”的产生程序与上文类似。在这一步中，每一个PKr-k中的用户i使用自己的私钥对“种子”参数Qr-1进行电子签名后并输入哈希函数，得到自己的凭证H(SIGi(r,1,Qr-1))。对0和1之间的一个数p，满足0.H(SIGi(r,1,Qr-1))≤p的用户就构成这一步的“验证者”。</p>
<a class="header" href="#a创建并不断完善种子参数" id="a创建并不断完善种子参数"><h4>创建并不断完善种子参数</h4></a>
<p>用Br表示第r轮结束后，拜占庭协议BA★输出的区块。如果Algorand在第r轮受到了“敌对者”攻击，Br可能是空的，也就是不含有任何真实交易记录（用符号来表示）。比如，“敌对者”可能腐化了这一轮的“领导者”，使其将两个不同的候选区块发给诚实的“验证者”。考虑到这个情况，“种子”参数的更新过程是：</p>
<p>Qr=H(SIGlr(Qr-1，r)),如果Br不是空区块</p>
<p>Qr=H（Qr-1，r）,如果Br是空区块</p>
<p>哈希函数的性质决定了，Qr和Qr-1之间的关系近乎随机的。回溯参数或安全参数k则保证了，“敌对者”在第r-k-1轮几乎不可能预测到Qr-1；否则，他将在第r-k轮引入恶意用户（也就是进入PKr-k），从而能影响第r轮“领导者”和“验证者”的选择。</p>
<a class="header" href="#a四层共识" id="a四层共识"><h2>四层共识</h2></a>
<a class="header" href="#a1-id与注册" id="a1-id与注册"><h3>1. ID与注册</h3></a>
<p>节点注册才能参与全网的运行，注册的意义在于可奖惩机制。经济意义在于：不止是token的价值，还包括了一个外部保障金的价值。节点注册还可以是验证节点的注册。</p>
<a class="header" href="#a2-随机数灯塔" id="a2-随机数灯塔"><h3>2. 随机数灯塔</h3></a>
<p>选举出leader VRF -&gt; BLS算法
去中心化的随机数灯塔协议(DRB)</p>
<a class="header" href="#a3-区块链与分叉协议" id="a3-区块链与分叉协议"><h3>3. 区块链与分叉协议</h3></a>
<p>PSP（概率插槽协议）</p>
<a class="header" href="#a4-公证与近乎即时的最终性" id="a4-公证与近乎即时的最终性"><h3>4. 公证与近乎即时的最终性</h3></a>
<a class="header" href="#a阀值接力与网络可扩展性" id="a阀值接力与网络可扩展性"><h4>阀值接力与网络可扩展性</h4></a>
<a class="header" href="#a一致性与可用性" id="a一致性与可用性"><h4>一致性与可用性</h4></a>
<p>追求一致性。如果不一致，将会暂停。</p>
<p>参与者的主动功能:</p>
<ol>
<li>参与去中心化的随机灯塔</li>
<li>参与去中心化的公证</li>
<li>提议区块 =&gt; 根据自己的观察，建立本地的最终链</li>
</ol>
<p>当r轮开始时，随机数塔生成随机数，然后节点收到随机数，将交易打包到一个候选区块中，将候选区块发送给公证人，公证人在等待固定的出块时间后，运行基于随机数灯塔的排序算法，选择排名最高的那个区块，广播到全网，随机数塔开始r+1轮。</p>
<p>随机数塔由委员会的成员一起运行，产生随机数。委员会成员一轮换一次。</p>
<p>网络中有很多的组，每组大小相同，委员会就是其中被选中的一个组。</p>
<a class="header" href="#a阀值加密" id="a阀值加密"><h5>阀值加密</h5></a>
<ol>
<li>阀值签名（组签名）</li>
<li>非交互性</li>
<li>唯一性（而非确定性），创建了一个消息签名，组内的任何有效子集的签名，最终形成组签名，都是唯一的，一样的。</li>
<li>分布式密钥生成（DKG） Joint-Feld-man算法</li>
</ol>
<a class="header" href="#bls签名方案" id="bls签名方案"><h5>BLS签名方案</h5></a>
<a class="header" href="#practical-byzantine-fault-tolerance-实用拜占庭协议" id="practical-byzantine-fault-tolerance-实用拜占庭协议"><h3>Practical Byzantine Fault Tolerance 实用拜占庭协议</h3></a>
<p><a href="http://pmg.lcs.mit.edu/papers/osdi99.pdf">原始论文</a></p>
<a class="header" href="#bft2f-能够容忍超过三分之一错误的拜占庭容错系统" id="bft2f-能够容忍超过三分之一错误的拜占庭容错系统"><h3>BFT2F 能够容忍超过三分之一错误的拜占庭容错系统</h3></a>
<p><a href="http://www.scs.stanford.edu/%7Ejinyuan/bft2f.pdf">原始论文</a></p>
<a class="header" href="#extending-binary-byzantine-agreement-to-multivalued-byzantine-agreement-将二元拜占庭式协议延伸至多值拜占庭协议" id="extending-binary-byzantine-agreement-to-multivalued-byzantine-agreement-将二元拜占庭式协议延伸至多值拜占庭协议"><h3>Extending binary Byzantine agreement to multivalued Byzantine agreement 将二元拜占庭式协议延伸至多值拜占庭协议</h3></a>
<p><a href="https://groups.csail.mit.edu/tds/papers/Coan/TurpinCoan-ipl84.pdf">原始论文</a></p>
<p>A binary Byzantine agreement algorithm can be extended to produce a multivalued Byzantine agreement algorithm. The resulting multivalued algorithm is cheaper than previously published algorithms when the cost of transmie values from the multivalued domain is significant.
可以扩展二进制拜占庭协议算法以产生多值拜占庭协议算法。 多值域的传输成本显著低于先前公布的算法。。</p>
<a class="header" href="#a以太坊的分片技术" id="a以太坊的分片技术"><h3>以太坊的分片技术</h3></a>
<p><a href="https://github.com/ethereum/wiki/wiki/Sharding-introduction-R&amp;D-compendium">官方资料</a></p>
<a class="header" href="#a目标" id="a目标"><h5>目标</h5></a>
<ol>
<li>Scaling: 可伸缩性，即性能能够达到VISA水平，千级TPS</li>
<li>可用性：
<ul>
<li>跨智能合约交易</li>
<li>跨片交易</li>
</ul>
</li>
<li>紧耦合</li>
</ol>
<a class="header" href="#collation校对数据结构" id="collation校对数据结构"><h5>Collation——校对数据结构</h5></a>
<p>Collation Header</p>
<ul>
<li>shard_id: the Shard ID of shards, most like a network-id, from 0~N-1(N is shard number).</li>
<li>parent_hash: the hash of parent collation.</li>
<li>chunk_root: 类似于默克尔树root的一个字段，是对body里面的chunks的root.</li>
<li>period（周期）: 进行校对的周期. (主链上五个区块算一个周期)</li>
<li>proposer_bid: 该collation的提案人的地址.</li>
<li>proposer_signature: 提案人的签名.</li>
</ul>
<p>Collation Body</p>
<ul>
<li>chunks: list-chunks</li>
</ul>
<a class="header" href="#a整体概览" id="a整体概览"><h4>整体概览</h4></a>
<p>两层和三个步骤：</p>
<ul>
<li>第一层
<ul>
<li>提案人(Proposer)收集交易放入到Collations中</li>
<li>校对人(Collator校对
<ul>
<li>a: 链接Collations</li>
<li>b: 同意规范链</li>
</ul>
</li>
</ul>
</li>
<li>第二层
<ul>
<li>执行人(Executor)
<ul>
<li>a: 处理交易</li>
<li>b: 执行智能合约</li>
<li>c: 计算状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<a class="header" href="#proposer" id="proposer"><h5>Proposer</h5></a>
<ol>
<li>任何人都可以成为Proposer</li>
<li>运行管理一个交易池</li>
<li>收集所有的交易进行打包</li>
<li>发送和接收Collation Body</li>
</ol>
<a class="header" href="#collator" id="collator"><h5>Collator</h5></a>
<ol>
<li>被伪随机抽样为来自所有碎片的整理池的“特定碎片和特定时期”的合格的整理者</li>
<li>整理提案来构建排序规则</li>
</ol>
<a class="header" href="#executor" id="executor"><h5>Executor</h5></a>
<ol>
<li>执行状态转换功能</li>
<li>提议者最好也应该是执行者，这样可以知道交易的消耗的gas，并选择费用高的交易</li>
</ol>
<a class="header" href="#sharding-manager-contractsmc" id="sharding-manager-contractsmc"><h4>Sharding Manager Contract（SMC）</h4></a>
<p><img src="../static/smc_architecture.png" alt="SMC Architecture" /></p>
<a class="header" href="#a执行流程" id="a执行流程"><h4>执行流程</h4></a>
<ol>
<li>验证者通过查看LOOKHEAD, 就是先前的区块链信息去判别接下来的验证者身份</li>
<li>普通用户提交交易到proposer</li>
<li>proposer打包出collations并分一些gas去给验证者</li>
<li>验证者传输接收潜在的collations</li>
<li>验证验证直到一定的深度的片段</li>
<li>验证者提交所验证的片段的深度给root chain</li>
<li>恶意的验证者会提交一个非法的collation</li>
<li>下一阶段的验证将在此分叉处处理这个非法的collation, 选取前一个合法的collation提交给root chain</li>
</ol>
<a class="header" href="#a分片方案与现有架构的整合图" id="a分片方案与现有架构的整合图"><h4>分片方案与现有架构的整合图</h4></a>
<p><img src="../static/eth_sharding_architecture.png" alt="Eth_Sharding Architecture" /></p>
<a class="header" href="#sharding-faq" id="sharding-faq"><h3>Sharding FAQ</h3></a>
<a class="header" href="#a三个简单的实现扩容的方案" id="a三个简单的实现扩容的方案"><h5>三个简单的实现扩容的方案</h5></a>
<ol>
<li>不再使用单一的链结构。但是这样会加多N-因子，导致安全性的下降</li>
<li>提高区块的大小。但是这种方案将导致很多弱连接的节点下线，最终成为集中式的中心化结局</li>
<li>联合挖矿。所有的矿工一起挖，共享收益，但是这种方式将导致矿工的成本增加，原理上还是和提高区块大小一样</li>
</ol>
<a class="header" href="#a扩展性的难题" id="a扩展性的难题"><h5>扩展性的难题</h5></a>
<ol>
<li>Decentralization（分散化）。任何设备接入并且只都能提供O(c)的资源</li>
<li>Scalability（可扩展性）。能够处理O(n) &gt; O(c)的交易</li>
<li>Security（安全性）。能够抵御O(n)资源的攻击</li>
</ol>
<p>c指单节点能够提供的有效资源(计算，带宽，存储)，n指整个生态的规模，交易负载，存储状态大小，数字货币价值都与n成正比。</p>
<a class="header" href="#what-are-some-moderately-simple-but-only-partial-ways-of-solving-the-scalability-problem--什么是解决可伸缩性问题的一些中等简单但仅部分的方法" id="what-are-some-moderately-simple-but-only-partial-ways-of-solving-the-scalability-problem--什么是解决可伸缩性问题的一些中等简单但仅部分的方法"><h4>What are some moderately simple but only partial ways of solving the scalability problem ? 什么是解决可伸缩性问题的一些中等简单但仅部分的方法？</h4></a>
<p>早期的分片思想和后来的Zilliqa, Merklix tree都是在使用分片或者碎片技术来解决吞吐量的问题，主要用于解决交易吞吐量的问题，但是没有考虑存储的代价。要全面解决这些问题，还需要解决状态存储，事务执行和广播机制都全面调整。需要深入到P2P层。早期的一个分片方案<a href="https://www.comp.nus.edu.sg/%7Eloiluu/papers/elastico.pdf">ELASTICO</a>。</p>
<a class="header" href="#a并没有走分片路线的其他方法" id="a并没有走分片路线的其他方法"><h4>并没有走分片路线的其他方法？</h4></a>
<ol>
<li>用拜占庭协议去改造区块链共识形态: Bitcoin-NG</li>
<li>使用外部通道和off-chain加速: Lightning Network，Raiden</li>
<li>使用密码学来改造： Mimblewimble，zk-SNARKs</li>
</ol>
<a class="header" href="#a术语" id="a术语"><h4>术语</h4></a>
<ul>
<li>State: 当前的状态，可以判别是否有效。比如Bitcoin中的UTXO，Ethereum中balance+nonce+code+storage，Namecoin中的域名注册表</li>
<li>History: 自从传世交易以来的所有交易记录</li>
<li>Transaction: 用户生成的含有签名的一个操作，有时候叫 blobs</li>
<li>State transaction function: 是一个涉及操作状态的交易</li>
<li>Merkle tree: 验证只需要 O(log(n))的一种存储数据的树形结构</li>
<li>Receipt: 代表一个事物效果的对象，并不直接存储在State中，但是存储在Merkle中，用于表示记录的存在，便于以后查询和使用，比如Ethereum中的Logs就是Receipt</li>
<li>Light client: 存储少量数据，用于Merkle判别的一种客户端实现</li>
<li>State root: 状态的Merkle树
<img src="../static/eth-state-root.png" alt="State root" /></li>
</ul>
<a class="header" href="#a分片的初始思想" id="a分片的初始思想"><h4>分片的初始思想</h4></a>
<p>我们将状态和历史分为 K=O(n/c) 分区，我们称之为“碎片”。例如，以太坊的分片方案可能会将所有以0x00开头的地址放入一个分片中，以0x01开头的地址放入另一个分片中。在最简单的分片形式中，每个分片也具有其自己的事务历史记录，某些分片k中的交易仅限于分片k的状态。一个简单的例子是多资产区块链，其中有K个分片，每个分片存储余额并处理与一个特定资产相关联的交易。在更高级的分片中，还包括某种形式的跨分片通信功能，其中一个分片上的事务可以触发其他分片上的事件。</p>
<a class="header" href="#a分片区块链的基本设计" id="a分片区块链的基本设计"><h4>分片区块链的基本设计</h4></a>
<p>一个简单的演示例子。为了简单，设计只存储数据点，不执行状态更改操作（UTXO）。存在一些叫做 collators 的节点分布在K分区中，负责接受blobs（transactions），并对这些交易进行打包操作成Collation，包括头，简短消息，上一个Collation和Merkle root。在每一个分区中，这都很想一条完整的区块链。现在的主链就是对这些一个个Collations的排序。一个分区K中的有效区块链，是指在主链上的所有K分区中的区块形成的那条最长链。因此在系统中存在几种节点。</p>
<ul>
<li>Super-full node - 下载所有分区和所有Collation, 进行所有验证操作。</li>
<li>Top-level node - 处理所有主链区块，提供信息给其他的分片组。</li>
<li>Single-shard node - 处理所有主链区块，并且处理该分区内的所有Collations。</li>
<li>Light node - 下载主链的区块头。</li>
</ul>
<p>Windback Verification——回溯验证。轻客户端通过下载最近的N（N=25）个Collation，来做有效性和可用性验证。</p>
<a class="header" href="#a面临的挑战有哪些" id="a面临的挑战有哪些"><h4>面临的挑战有哪些？</h4></a>
<ul>
<li>Single-shard takeover attacks —— 单分片占领攻击 =&gt; 一般采用随机选举算法抵御</li>
<li>State transition execution —— 状态交易执行。（具有强同步的状态，保持所有Collator具有准确的状态）</li>
<li>Fraud detection —— 欺诈识别</li>
<li>Cross shard communication —— 分片交叉通信</li>
<li>The data availability problem —— 数据可用性问题</li>
<li>Superquadratic sharding —— 2次分片</li>
</ul>
<a class="header" href="#a安全模型" id="a安全模型"><h4>安全模型？</h4></a>
<ul>
<li>Honest majority —— 大部分是诚实的</li>
<li>Uncoordinated majority —— 大部分是理性的</li>
<li>Coordinated choice —— 协调选择</li>
<li>Bribing attacker model —— 贿赂型攻击者模型</li>
</ul>
<a class="header" href="#zilliqa-一种分片驱动的区块链技术" id="zilliqa-一种分片驱动的区块链技术"><h3>Zilliqa 一种分片驱动的区块链技术</h3></a>
<p><a href="https://docs.zilliqa.com/whitepaper.pdf">官方白皮书</a></p>
<p><a href="https://docs.zilliqa.com/zilliqa-slides-updated.pdf">PPT项目展示</a></p>
<a class="header" href="#bitcoin-ng-可扩展的区块链协议" id="bitcoin-ng-可扩展的区块链协议"><h3>Bitcoin-NG 可扩展的区块链协议</h3></a>
<p><a href="https://www.usenix.org/system/files/conference/nsdi16/nsdi16-paper-eyal.pdf">原始论文</a></p>
<a class="header" href="#off-chain-链下链上结合" id="off-chain-链下链上结合"><h3>Off-Chain 链下链上结合</h3></a>
<a class="header" href="#lighting-network-闪电网络" id="lighting-network-闪电网络"><h5>Lighting Network 闪电网络</h5></a>
<a class="header" href="#raiden-雷电项目" id="raiden-雷电项目"><h5>Raiden 雷电项目</h5></a>
<a class="header" href="#mimblewimble-一种基于密码学的扩展性方案" id="mimblewimble-一种基于密码学的扩展性方案"><h3>Mimblewimble 一种基于密码学的扩展性方案</h3></a>
<p><a href="https://scalingbitcoin.org/papers/mimblewimble.txt">原始论文</a></p>
<a class="header" href="#plasma-scalable-autonomous-smart-contracts" id="plasma-scalable-autonomous-smart-contracts"><h3>Plasma: Scalable Autonomous Smart Contracts</h3></a>
<p><a href="https://www.plasma.io/plasma.pdf">官方论文</a></p>
<a class="header" href="#conflux-将链与dag相结合的区块链技术" id="conflux-将链与dag相结合的区块链技术"><h3>Conflux: 将链与DAG相结合的区块链技术</h3></a>
<p><a href="https://arxiv.org/pdf/1805.03870.pdf">原始论文</a></p>
<a class="header" href="#polkadot--a-heterogeneous-multichain-technology-一种异构跨链技术" id="polkadot--a-heterogeneous-multichain-technology-一种异构跨链技术"><h3>Polkadot —— a heterogeneous multi‑chain technology. 一种异构跨链技术</h3></a>
<p><a href="https://polkadot.network/Polkadot-lightpaper.pdf">lightpaper-简介PPT</a></p>
<p><a href="https://github.com/w3f/polkadot-white-paper/blob/master/PolkaDotPaper.pdf">WhitePaper</a></p>
<p><a href="https://github.com/paritytech/polkadot">源码地址</a></p>
<a class="header" href="#parsec-异步可靠安全和有效的共识算法" id="parsec-异步可靠安全和有效的共识算法"><h2>Parsec 异步，可靠，安全和有效的共识算法</h2></a>
<p><a href="http://docs.maidsafe.net/Whitepapers/pdf/PARSEC.pdf">原始论文</a></p>
<a class="header" href="#protocol-for-asynchronous-reliable-secure-and-efficient-consensus-parsec" id="protocol-for-asynchronous-reliable-secure-and-efficient-consensus-parsec"><h2>Protocol for Asynchronous, Reliable, Secure and Efficient Consensus (PARSEC)</h2></a>
<a class="header" href="#a简介" id="a简介"><h3>简介</h3></a>
<p>论文中主要论述了一种全新的拜占庭容错共识算法，通过弱同步来实现的。如同Hashgrap一样，没有leader，没有准备的轮，没有POW，并且达到最终的概率为1的共识。但是跟Hashgrap不同的是，它不仅提供一个非常高的速度，不管系统中是否出现容错。而且这是一个完全开放的，遵循GPLv3，采用Rust实现。</p>
<p>跟HoneyBadeger BFT一样，这个算法建立在很多理论研究中的好的想法上。一个Gossip协议用来有效的在节点间沟通，如果Hashgrap和<a href="">Snowflake Avalanche</a>一样. 传播消息，实际上达成共识只需要花费O(NlogN)通信和O(logN)阶段。</p>
<p>达到任意值的拜占庭协议的一般问题被简化为在参与每个决策的节点上达到二分拜占庭协议的更简单问题。 这允许我们在将其应用于Gossip协议之后重用<a href="">免签名的异步拜占庭</a>中描述的优雅二进制拜占庭协议协议。</p>
<p>最后，在上面免签名的异步拜占庭中存在的可信领导者和可信步骤被替换为<a href="">异步协定</a>中实现异步的设置。</p>
<a class="header" href="#a算法详解" id="a算法详解"><h3>算法详解</h3></a>
<a class="header" href="#a网络模型" id="a网络模型"><h4>网络模型</h4></a>
<p>我们假设网络是通过随机同步连接进行通信的算法的N个实例的集合N. “随机同步”是指消息以随机延迟传递，使得平均延迟是有限的。特别是，可能存在任意长时间延迟的时期。这是一个比弱同步更弱的假设，并且只比完全异步强一点，其中唯一的保证是最终传递消息。</p>
<p>使用随机同步，就像完全异步一样，无法通过完全停止来判断实例是否已失败，或者消息传递只是延迟。</p>
<p>我们允许最多t拜占庭（任意）失败的可能性，其中3t &lt;N。我們将调用未正确或诚实失败的实例，并且失败的实例有故障或恶意 - 因为拜占庭故障模型允许恶意行为和合作。</p>
<p>我们将引用任何包含超过2/3N的实例作为绝对多数。</p>
<a class="header" href="#a数据结构" id="a数据结构"><h4>数据结构</h4></a>
<p>一个节点保持着两种结构：gossip图和所有区块顺序。gossip图的顶点称为gossip事件(gossip event)，包含下面的字段：</p>
<ul>
<li>有效负载(Payload) - 节点想要传过其他节点的数据</li>
<li>自身父项(Self-parent) - 指向自身节点的上一次区块的hash</li>
<li>其他父项(Other-parent) - 指向一个其他节点创建的区块的hash</li>
<li>原因(Cause) - 此事件的创建原因; 可以是请求，回应或观察</li>
<li>创建者ID(Creator ID) - 创建这个事件的创建者的公钥</li>
<li>签名(Signature) - 整体的签名</li>
</ul>
<p>除了由各个节点创建的第一个事件之外，自父项和其他父项始终存在，因为在这种情况下不存在要引用的父事件。 由于观察而在创建的事件中也缺少其他父母 - 因为在这种情况下没有goosip伙伴。</p>
<p>有序集中的块是由网络中的节点的子集签名的网络事件。 该集合是算法的输出，表示所有节点都同意的网络事件的顺序。</p>
<p>我们还要定义一些关于gossip图的有用术语以供将来使用。</p>
<ul>
<li>
<p>Definition 2.1. We say that event A is an ancestor of event B iff: A=B, or A is an ancestor of B’s self-parent, or A is an ancestor of B’s other-parent.</p>
</li>
<li>
<p>定义 2.1. 我们说事件A是事件B的祖先，那么：A = B，或者A是B的自身父事件的祖先，或者A是B的其他父事件的祖先。</p>
</li>
<li>
<p>Definition 2.2. We say that event A is a descendant of event B iff: B is an ancestor of A.</p>
</li>
<li>
<p>定义 2.2. 我们说事件A是事件B的后裔，那么：B是A的祖先。</p>
</li>
<li>
<p>Definition 2.3. We say that event A is a strict ancestor/descendant of event B iff A is an ancestor/descendant of B and A != B.</p>
</li>
<li>
<p>定义2.3. 我们说事件A是事件B的严格祖先/后代，那么: A是B和A的祖先/后代，并且A != B.</p>
</li>
<li>
<p>Definition 2.4. An event A is said to see an event B iff B is an ancestor of A, and there doesn’t exist any pair of events by B ’s creator B1, B2 , such that B1 and B2 are ancestors of A , but B1 is neither an ancestor nor a descendant of B2 (see fig. 1). We call a situation in which such a pair exists a fork.</p>
</li>
<li>
<p>定义2.4. 事件A能看到事件B，表现为事件B是A的祖先，并且B的创建者B1，B2不存在任何事件对，使得B1和B2是A的祖先，但B1是既不是B2的祖先也不是后代（见图1）。我们称这种情况下存在一个分叉的情况。</p>
</li>
<li>
<p>Definition 2.5. An event A is said to strongly see an event B iff A sees a set of events created by a supermajority of nodes in the system that all see B (see fig. 2).</p>
</li>
<li>
<p>定义2.5. 事件A能够强烈的看到事件B，表现为A能够看到系统中绝大多数节点的事件都可以看到B。</p>
</li>
</ul>
<p><img src="../static/parsec_fig_1_2.png" alt="parsec fig1_2" /></p>
<a class="header" href="#a算法总览" id="a算法总览"><h4>算法总览</h4></a>
<p>在每一轮中，节点将执行两个主要步骤：</p>
<ul>
<li>与随机的节点进行gossip图的同步</li>
<li>确定是否将任何的新块加入到有序集中</li>
</ul>
<a class="header" href="#a同步" id="a同步"><h5>同步</h5></a>
<p>此步骤负责构建Gossip图,并在网络中传播信息。节点不断向其他节点发出称为同步请求的随机调用，并交换有关该图的信息，以便所有正确的节点在其图中以相同的数据结束。gossip事件中的哈希和签名可确保恶意节点无法篡改图表的任何部分。</p>
<p>每当节点收到同步请求时，它就会创建一个新的gossip事件并发回一个同步响应。此事件的自我父事件是收件人创建的最后一个gossip事件的哈希值，另一个父事件是发件人创建的最后一个事件的哈希值（收件人从交换中获知）。同步响应的收件人还会创建一个具有类似父项的新事件。创建的两个事件还存储创建它们的原因（无论是由于请求还是响应）。</p>
<p>如果请求/响应的接收者认为它知道应该作为链中的下一个附加的网络事件，则将其投票记录为新创建的事件的有效负载。其他节点将在其创建者进行的后续同步交换期间了解此投票。</p>
<a class="header" href="#a决定顺序" id="a决定顺序"><h5>决定顺序</h5></a>
<p>在这个阶段，节点将分析图，统计投票数来决定哪个区块将作为下一个区块，这个步骤是复杂的，所以在下面另开一章描述。</p>
<a class="header" href="#a计算顺序" id="a计算顺序"><h4>计算顺序</h4></a>
<p>为了对区块进行排序，我们首先得有一些区块。</p>
<p>如上所述，Gossip事件可能包含对网络中事件的投票。 看到由包含针对给定网络事件的投票的绝大多数节点创建的事件的gossip事件被称为有效块，并且我们将这种gossip事件称为块投票。强烈看到由绝大多数节点创建的块投票的第一个gossip事件被认为是观察者。块投票不需要看到相同的有效块 - 实际上，当它们看到最有趣的不同有效块时就是这种情况。但是，它们必须仅引用尚未附加到有序集的块。</p>
<p>观察者隐含地携带N个元投票的列表。每个元投票只是一个二进制值，表示在确定顺序时是否要考虑相应节点的块投票。观察者如果能够强烈地看到该节点的块投票，则在节点上进行元投票。每个节点都在进行元投票，因此有N个元投票，并且由于观察者强烈地看到绝大多数的块投票，根据定义，它们中至少有2/3N是真的。</p>
<p>元投票将拜占庭关于秩序的协议问​​题减少到二元拜占庭协议的问题, 这解决了的<a href="">免签名的异步拜占庭</a>中的问题。</p>
<p><a href="">免签名的异步拜占庭</a>中描述的算法有一些缺点，但最重要的是需要一个共同的硬币，一个可能需要同步的原语和/或一个可信的第三方来进行有效的创建或设置。这里介绍的算法没有这样的要求。</p>
<a class="header" href="#binary-agreement" id="binary-agreement"><h5>Binary agreement</h5></a>
<p>为简单起见，我们将根据单个元投票来定义算法 - 即，在尝试选择单个新块时，决定是否考虑单个节点的意见。 我们可以查看节点X的元投票，其中最新约定的块B作为八卦图G的子集H（X，B）的函数，其是作为该元的任何观察者的后代的所有事件的集合。</p>
<pre><code>meta_election(X,B): H(X,B) → {0, 1, ⊥}
</code></pre>
<p>⊥表示在这个顶点，不能够对这个元投票进行决定。</p>
<p>为了计算H（A, B）对事件的元投票信息, 首先定义一些辅助的信息：</p>
<ul>
<li><strong>stage</strong>: 表示计算阶段的计数器 (a counter denoting the calculation stage)</li>
<li><strong>estimates</strong>: 对最终结果估计的单一或者两个的值集 (a set of one or two values estimating the final result)</li>
<li><strong>bin_values</strong>: 二进制的辅助值集 (a helper set of binary values)</li>
<li><strong>aux</strong>: 二进制的辅助值 (a helper binary value)</li>
</ul>
<p>stage是一个整数值，表示我们在查看特定的八卦事件时正在考虑的协议阶段。 一个数字与每个八卦事件相关联，这样观察者的阶段总是为0.任何其他八卦事件的阶段要么是其自我父母的阶段，要么是自我父母在特定条件下的的阶段+1。 稍后将更详细地描述阶段递增的确切条件。 其他变量，如estimates，bin_values和aux都取决于stage。 (round的概念?)</p>
<p>estimates是一组二进制值，表示任何关于元投票结果的八卦事件的创建者的感知意见。 观察者的estimates是仅包含其自己的元投票的集合。 任何后续八卦事件的estimates可以是如下所述的不同集合。</p>
<p>如果事件的自我父母的estimates中包含单个值v，并且该事件在其estimates值中看到超过N/3个事件且其中包含¬v（这意味着至少有一个诚实节点估计为¬v），则会添加此相反值 根据自己的估计（因此它将包含真和假）。 (?)</p>
<p><img src="../static/parsec_fig_5.png" alt="parsec fig_5" /></p>
<a class="header" href="#agreement-about-the-next-block" id="agreement-about-the-next-block"><h5>Agreement about the next block</h5></a>
<a class="header" href="#high-level-algorithm" id="high-level-algorithm"><h3>High level algorithm</h3></a>
<ul>
<li>When a node needs to vote on a new NodeState, it creates a GossipEvent for this with self_parent as the hash of the latest event in its own gossip history and other_parent as None</li>
<li>Periodically, a node gossips to another node
<ul>
<li>Pick a recipient</li>
<li>Send a GossipRequestRpc containing all the GossipEvents that it thinks the recipient hasn't seen according to its gossip graph</li>
</ul>
</li>
<li>On receipt of a GossipRequestRpc, a node will
<ul>
<li>Insert the contained GossipEvents into its gossip graph</li>
<li>Create a new GossipEvent that records receipt of the latest gossip. The self_parent is the hash of the latest event in its own gossip history and other_parent is the hash of the sender's latest event in the GossipRequestRpc. The cause for this GossipEvent is GossipCause::Request</li>
<li>Send a GossipResponseRpc containing all the GossipEvents that it thinks the sender hasn't seen according to its gossip graph. Send it to the sender</li>
<li>Run the current gossip graph through the order consensus algorithm until it returns None. The output of this algorithm is an Option of newly-stable Block</li>
</ul>
</li>
<li>On receipt of a GossipResponseRpc, a node will
<ul>
<li>Insert the contained GossipEvents into its gossip graph</li>
<li>Create a new GossipEvent that records receipt of the latest gossip. The self_parent is the hash of the latest event in its own gossip history and other_parent is the hash of the sender's latest event in the GossipResponseRpc. The cause for this GossipEvent is GossipCause::Response</li>
<li>Run the current gossip graph through the order consensus algorithm until it returns None. The output of this algorithm is an Option of newly-stable Block</li>
</ul>
</li>
<li>On observation of a change in the network structure, a node will
<ul>
<li>Create a new GossipEvent that records observation of said network event. The self_parent is the hash of the latest event in its own gossip history and other_parent is None. The cause for this GossipEvent is GossipCause::Observation</li>
<li>Insert the newly created GossipEvent into its gossip graph</li>
</ul>
</li>
</ul>
<a class="header" href="#signature-free-asynchronous-byzantine-consensus-with-tn3-and-on2-messages" id="signature-free-asynchronous-byzantine-consensus-with-tn3-and-on2-messages"><h3>Signature-Free Asynchronous Byzantine Consensus with t&lt;n/3 and O(n^2) Messages</h3></a>
<p><a href="https://hal.inria.fr/hal-00944019/document">原始论文</a></p>
<p>本文提出了一种新的基于回合的异步共识算法，该算法可以处理多达t &lt; n/3的拜占庭过程，其中n是过程的总数。 除了没有签名且最优于t的值之外，该算法还具有几个值得注意的特性：预期的轮次数为4，每轮由两个或三个通信步骤组成，涉及O（n^2）消息，消息由一个轮数加一个比特组成。 为了实现这一目标，共识算法依赖于Rabin定义的普通硬币，以及适用于二进制值的新的极其简单和强大的广播抽象。 设计该算法时的主要目标是获得廉价且简单的算法。 这是因为在性能至上的现实中，简单-有时被低估甚至忽视。</p>
<a class="header" href="#made-trivial-拜占庭协定" id="made-trivial-拜占庭协定"><h3>MADE TRIVIAL 拜占庭协定</h3></a>
<p><a href="https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Distributed%20Computation/BYZANTYNE%20AGREEMENT%20MADE%20TRIVIAL.pdf">原始论文</a></p>
<a class="header" href="#the-honey-badger-of-bft-protocols" id="the-honey-badger-of-bft-protocols"><h3>The Honey Badger of BFT Protocols</h3></a>
<p><a href="https://eprint.iacr.org/2016/199.pdf">原始论文</a></p>
<a class="header" href="#snowflake-to-avalanchex用于加密货币的新型亚稳定性的共识协议族" id="snowflake-to-avalanchex用于加密货币的新型亚稳定性的共识协议族"><h3>Snowflake to Avalanchex：用于加密货币的新型亚稳定性的共识协议族</h3></a>
<p><a href="http://muratbuffalo.blogspot.com/2018/06/snowflake-to-avalanche-novel-metastable.html">原始论文</a> <a href="https://ipfs.io/ipfs/QmUy4jh5mGNZvLkjies1RWM4YuvJh5o2FYopNPVYwrRVGV">ipfs文件地址</a></p>
<a class="header" href="#sodium加密库" id="sodium加密库"><h3>sodium加密库</h3></a>
<p>包括加密，解密，签名，密码哈希以及其他。</p>
<a class="header" href="#verifiable-random-functions-可验证随机函数" id="verifiable-random-functions-可验证随机函数"><h3>Verifiable Random Functions 可验证随机函数</h3></a>
<a class="header" href="#verifiable-delay-functions---可验证延迟函数" id="verifiable-delay-functions---可验证延迟函数"><h3>Verifiable Delay Functions - 可验证延迟函数</h3></a>
<p><a href="https://eprint.iacr.org/2018/601.pdf">原始论文</a></p>
<a class="header" href="#a门限签名" id="a门限签名"><h3>门限签名</h3></a>
<p>(t, n)形式
... 待加</p>
<a class="header" href="#a环签名技术---匿名签名技术" id="a环签名技术---匿名签名技术"><h3>环签名技术 - 匿名签名技术</h3></a>
<p><a href="https://v-yu.com/lib/2006_Rivest,%20Shamir,%20Tauman.pdf">原始论文</a></p>
<p>当群签名不需要中心的时候，就是环签名。
寻找t的人一起签名一条消息，形成一种环形的方式，外界无法确定是谁发出了这条消息。</p>
<ol>
<li>无群体建立的过程，也没有特殊的管理者</li>
<li>不需要预先加入或者退出群体，群体由签名人自己指定</li>
<li>不能追踪签名人身份，只能推测出这个人在n个人中间</li>
</ol>
<a class="header" href="#homomorphic-encryption-同态加密" id="homomorphic-encryption-同态加密"><h3>Homomorphic Encryption 同态加密</h3></a>
<a class="header" href="#a参考资料" id="a参考资料"><h4>参考资料</h4></a>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Homomorphic_encryption">wiki</a></li>
<li><a href="https://www.zhihu.com/question/27645858/answer/37598506">同态加密的实现原理是什么？在实际中有何应用？ - 刘巍然-学酥的回答 - 知乎</a></li>
</ul>
<a class="header" href="#homomorphic-encryption-同态加密-1" id="homomorphic-encryption-同态加密-1"><h3>Homomorphic Encryption 同态加密</h3></a>
<a class="header" href="#a参考资料-1" id="a参考资料-1"><h4>参考资料</h4></a>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Homomorphic_encryption">wiki</a></li>
<li><a href="https://www.zhihu.com/question/27645858/answer/37598506">同态加密的实现原理是什么？在实际中有何应用？ - 刘巍然-学酥的回答 - 知乎</a></li>
</ul>
<a class="header" href="#bulletproofs-short-proofs-for-confidential-transactions-and-more" id="bulletproofs-short-proofs-for-confidential-transactions-and-more"><h3>Bulletproofs: Short Proofs for Confidential Transactions and More</h3></a>
<p><a href="https://eprint.iacr.org/2017/1066.pdf">原始论文</a></p>
<a class="header" href="#schnorr-系列算法和协议" id="schnorr-系列算法和协议"><h1>Schnorr-系列算法和协议</h1></a>
<a class="header" href="#sigma-系列算法和协议" id="sigma-系列算法和协议"><h1>Sigma-系列算法和协议</h1></a>
<a class="header" href="#ristretto-is-a-technique-for-constructing-prime-order-elliptic-curve-groups-with-non-malleable-encodings" id="ristretto-is-a-technique-for-constructing-prime-order-elliptic-curve-groups-with-non-malleable-encodings"><h3>Ristretto is a technique for constructing prime order elliptic curve groups with non-malleable encodings.</h3></a>
<p><a href="https://ristretto.group/">Ristretto资料地址</a></p>
<a class="header" href="#a-hrefhttpswwwshiftleftorgpapersdecafdecafa" id="a-hrefhttpswwwshiftleftorgpapersdecafdecafa"><h4><a href="https://www.shiftleft.org/papers/decaf/">Decaf</a></h4></a>
<a class="header" href="#sodium加密库-1" id="sodium加密库-1"><h3>sodium加密库</h3></a>
<p>包括加密，解密，签名，密码哈希以及其他。</p>
<a class="header" href="#curve25519ed25519x25519" id="curve25519ed25519x25519"><h3>Curve25519/Ed25519/X25519</h3></a>
<p>著名密码学家Daniel J. Bernstein在2006年独立设计的椭圆曲线加密/签名/密钥交换算法。</p>
<a class="header" href="#curve25519" id="curve25519"><h4>Curve25519</h4></a>
<p>作为基础椭圆曲线的名称。</p>
<a class="header" href="#ed25519" id="ed25519"><h4>Ed25519</h4></a>
<p>一个数字签名算法，签名和验证的性能都极高。签名过程不依赖随机数生成器，不依赖hash函数的防碰撞性，没有时间通道攻击的问题，并且签名很小，只有64字节，公钥也很小，只有32字节。</p>
<a class="header" href="#x25519" id="x25519"><h4>X25519</h4></a>
<p>是目前最高水平的 Diffie-Hellman函数。密钥交换算法。</p>
<a class="header" href="#a前向安全性-forward-secrecyfs" id="a前向安全性-forward-secrecyfs"><h4>前向安全性 Forward Secrecy（FS）</h4></a>
<p>是密码学中通讯协议的安全属性，指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。前向安全能够保护过去进行的通讯不受密码或密钥在未来暴露的威胁。如果系统具有前向安全性，就可以保证在主密钥泄露时历史通讯的安全，即使系统遭到主动攻击也是如此。</p>
<p>主要运用在传输层安全协议（TLS）。</p>
<p>如果采用Perfect Forward Secrecy， 针对每个session客户端和服务器都分别生成临时的(Ephemeral)随机DH/ECDH私钥EPk (DH/ECDH也是一种非对称算法),  根据此随机的私钥EPk和对方传过来的DH/ECDH公钥计算出共享的preMaster key, 再用哈系函数处理preMaster key计算出AES的加密/解密密钥。 由于DH/ECDH私钥不经过网络传输，每次会话结束就被删除，和RAS 私钥Apriv无关，因此即使长期使用的Apriv被非法获取，以往监听到的加密数据也无法被解密(除非有能力拿到每个session的DH私钥，这是不可能的)。  可见密码学安全的随机数生成算法有多重要。</p>
<p>当然除了长期使用的用于身份认证的公钥私钥对Apub/Apriv, 服务器也可以为每次(多次)会话都生成一对新的RSA 公钥/私钥 Tpub/Tpriv用于AES密钥交换。 服务器用证书私钥Apriv签名Tpub的hash值，并传输Tpub和Tpub的hash签名给客户端。 客户端用收到的Tpub加密随机生成的AES密钥K并传给服务器，服务器用Tpriv解密K，双方就可以用K加密解密实际的消息了。 双RSA虽然也能实现PFS，但是效率太差，没有公司会采用， 基本都是RSA+ECDHE。</p>
<p>完美前向安全 Perfect Forward Secrecy（PFS）</p>
<a class="header" href="#a前向安全性-forward-secrecyfs-1" id="a前向安全性-forward-secrecyfs-1"><h4>前向安全性 Forward Secrecy（FS）</h4></a>
<p>前向安全保证了新加入群组的人无法解密之前的信息。</p>
<ul>
<li>强前向安全(Strong Backward Secrecy): 后面进来的人即时知道之前的信息，但是无法解密。</li>
<li>弱前向安全(Weak Backward Secrecy): 后面进来的人完全不知道之前有过什么信息。</li>
</ul>
<a class="header" href="#a后向安全性-backward-secrecybs" id="a后向安全性-backward-secrecybs"><h4>后向安全性 Backward Secrecy（BS）</h4></a>
<p>后向安全保证了新加入群组的人无法解密之后的信息。</p>
<ul>
<li>强后向安全(Strong Forward Secrecy): 前面进来的人，虽然能获取信息，但是无法解密。</li>
<li>弱后向安全(Weak Forward Secrecy): 前面进来的人，无法获知后面发出的信息。</li>
</ul>
<a class="header" href="#a52-things-people-should-know-to-do-cryptography" id="a52-things-people-should-know-to-do-cryptography"><h2>52 Things People Should Know To Do Cryptography</h2></a>
<a class="header" href="#a密码学52个知识点" id="a密码学52个知识点"><h2>密码学52个知识点</h2></a>
<p>What is this?
Cryptography is a highly interdisciplinary area; calling on expertise in Pure Mathematics, Computer Science and Electronic Engineering. At Bristol we cover the full range of these topics and as such our students come with a variety of backgrounds and need to understand a diverse range of topics. Students starting can often feel overwhelmed by the types of knowledge that they feel they need to know; not knowing what they need to remember and what they should not bother remembering.</p>
<p>密码学是一个高度跨学科的领域：包括数学，计算机科学和电子工程方面的知识。在Bristol大学，我们涵盖了所有这些主题，不管我们的学生来自何种背景，都需要了解各种主题。开始的时候，学生往往会对这些知识点不知所措，不知道他们需要记住什么以及他们不应该记住什么。</p>
<p>To aid you, below we have collected a set of 52 short points of things we think that at the end of the first year of a PhD all students should have some familiarity with. There is one point for every week of the year. If you know these things then following seminars, study groups and conference talks will be much easier. It will also help in putting your own work into context. Some of these are somewhat advanced topics, some of these are what one would pick up in certain undergraduate courses. This is deliberate since some are about being a cryptographer, and some are to address the fact that students start with different backgrounds.</p>
<p>为了帮助你，下面我们收集了一系列52个关于我们认为在博士学位第一年结束时的所有学生都应该熟悉的内容。 一年中每周有一分。 如果你知道这些事情，那么在研讨会之后，研究小组和会议谈话将变得更容易。 它也将帮助您将自己的工作置于上下文中。 其中一些是有些高级的话题，其中一些是在某些本科课程中会选择的。 这是故意的，因为学生都是有各自的学习背景，有些人是关于密码学，有些是为了解决这样一个事实。</p>
<p>If at the end of the first year you know the answers to ninety percent of the things we list then you should find that you will get more out of the conferences and talks you attend in your second year. In addition it will be easier to talk to cryptographers (who may be future employers) from other institutions since you will be able to converse with them using a common language. Almost all of the following are discussed in our undergraduate cryptography courses.</p>
<p>如果在第一年结束时，你知道我们列出的百分之九十的答案，那么你应该会发现，你会在第二年参加的会议和谈话中获得更多的回报。 此外，与其他机构的密码学家（可能是未来的雇主）交谈会更容易，因为您可以使用通用语言与他们交谈。 以下几乎所有内容都在我们的本科密码学课程中讨论。</p>
<p>By each section we give a reference to places where the definitions can be found, or where to start your reading. The list of references can be found at the bottom. Not all answers can be found in the references cited, but they should give you a place to start looking.</p>
<p>通过每个部分，我们都会提供可以找到定义的地方或从哪里开始阅读。 参考列表可以在底部找到。 并不是所有的答案都可以在参考文献中找到，但他们应该给你一个开始寻找的地方。</p>
<a class="header" href="#computer-engineering-e" id="computer-engineering-e"><h3>Computer Engineering ([E])</h3></a>
<ul>
<li>1 What is the difference between the following?
<ul>
<li>general-purpose processor.</li>
<li>general-purpose processor with instruction-set extensions.</li>
<li>special-purpose processor (or co-processor).</li>
<li>An FPGA.</li>
</ul>
</li>
<li>2 What is the difference between a multi-core processor and a vector processor?</li>
<li>3 Estimate the relative computational and storage capabilities of...
<ul>
<li>a smart-card</li>
<li>a micro-controller (i.e. a sensor node)</li>
<li>an embedded or mobile computer (e.g., a mobile phone or PDA)</li>
<li>a laptop- or desktop-class computer.</li>
</ul>
</li>
</ul>
<a class="header" href="#a中文计算机工程e" id="a中文计算机工程e"><h3>（中文）计算机工程（[E]）</h3></a>
<ul>
<li>1 以下几点有什么区别？
<ul>
<li>通用处理器。</li>
<li>带指令集扩展的通用处理器。</li>
<li>专用处理器（或协处理器）。</li>
<li>一个FPGA。</li>
</ul>
</li>
<li>2 多核处理器和矢量处理器有什么区别？</li>
<li>3 估计以下设备的相对计算和存储能力
<ul>
<li>一张智能卡</li>
<li>微控制器（即传感器节点）</li>
<li>嵌入式或移动计算机（例如，移动电话或PDA）</li>
<li>一台笔记本电脑或台式电脑。</li>
</ul>
</li>
</ul>
<a class="header" href="#theoretical-computer-science-f" id="theoretical-computer-science-f"><h3>Theoretical Computer Science ([F])</h3></a>
<ul>
<li>4 What is meant by the complexity class P?</li>
<li>5 What is meant by the complexity class NP?</li>
<li>6 How can we interpret NP as the set of theorems whose proofs can be checked in polynomial time?</li>
<li>7 How does randomness help in computation, and what is the class BPP?</li>
<li>8 How does interaction help in computation, and what is the class IP?</li>
<li>9 What are Shannon's definitions of entropy and information?</li>
</ul>
<a class="header" href="#a中文理论计算机科学f" id="a中文理论计算机科学f"><h3>（中文）理论计算机科学（[F]）</h3></a>
<ul>
<li>4 复杂度类P含义是什么？</li>
<li>5 复杂度类NP含义是什么？</li>
<li>6 我们如何将NP解释为可以在多项式时间内检验证明的一组定理？</li>
<li>7 随机性如何帮助计算，什么是BPP类？</li>
<li>8 交互如何帮助计算，什么是类IP？</li>
<li>9 香农对熵和信息的定义是什么？</li>
</ul>
<a class="header" href="#mathematical-background-ab" id="mathematical-background-ab"><h3>Mathematical Background ([A,B])</h3></a>
<ul>
<li>10 What is the difference between the RSA and the Strong-RSA problem?</li>
<li>11 What are the DLP, CDH and DDH problems?</li>
<li>12 What is the elliptic curve group law?</li>
<li>13 Outline the use and advantages of projective point representation.</li>
<li>14 What is a cryptographic pairing?</li>
</ul>
<a class="header" href="#a中文数学背景ab" id="a中文数学背景ab"><h3>（中文）数学背景（[A，B]）</h3></a>
<ul>
<li>10 RSA和Strong-RSA问题有什么区别？</li>
<li>11 什么是DLP，CDH和DDH问题？</li>
<li>12 什么是椭圆曲线群法则？</li>
<li>13 概述投影点表示的用途和优点。</li>
<li>14 什么是密码配对？</li>
</ul>
<a class="header" href="#basic-practical-or-deployed-cryptographic-schemes-and-protocols-a" id="basic-practical-or-deployed-cryptographic-schemes-and-protocols-a"><h3>Basic (Practical or Deployed) Cryptographic Schemes and Protocols ([A])</h3></a>
<ul>
<li>15 Describe the key generation, encryption and decryption algorithms for RSA-OAEP and ECIES.</li>
<li>16 Describe the key generation, signature and verification algorithms for DSA, Schnorr and RSA-FDH.</li>
<li>17 Describe and compare the round structure of DES and AES.</li>
<li>18 Draw a diagram (or describe) the ECB, CBC and CTR modes of operation.</li>
<li>19 Describe the Shamir secret sharing scheme.</li>
<li>20 How are Merkle-Damgaard style hash functions constructed?</li>
</ul>
<a class="header" href="#a中文基本实用或部署密码方案和协议a" id="a中文基本实用或部署密码方案和协议a"><h3>（中文）基本（实用或部署）密码方案和协议（[A]）</h3></a>
<ul>
<li>15 描述RSA-OAEP和ECIES的密钥生成，加密和解密算法。</li>
<li>16 描述DSA，Schnorr和RSA-FDH的密钥生成，签名和验证算法。</li>
<li>17 描述和比较DES和AES的圆形结构。</li>
<li>18 绘制（或描述）ECB，CBC和CTR操作模式的图表。</li>
<li>19 描述沙米尔秘密分享计划。</li>
<li>20 Merkle-Damgaard风格的哈希函数是如何构建的？</li>
</ul>
<a class="header" href="#cryptographic-implementation-details-a" id="cryptographic-implementation-details-a"><h3>Cryptographic Implementation Details ([A])</h3></a>
<ul>
<li>21 How does the CRT method improve performance of RSA?</li>
<li>22 How do you represent a number and multiply numbers in Montgomery arithmetic?</li>
<li>23 Write a C program to implement Montgomery arithmetic.</li>
<li>24 Describe the binary, m-ary and sliding window exponentiation algorithms.</li>
<li>25 Describe methods for modular reduction using &quot;special&quot; primes that define GF(p) and GF(2^n).</li>
<li>26 Describe the NAF scalar multiplication algorithm.</li>
</ul>
<a class="header" href="#a中文加密实现细节a" id="a中文加密实现细节a"><h3>（中文）加密实现细节（[A]）</h3></a>
<ul>
<li>21 CRT方法如何提高RSA的性能？</li>
<li>22 你如何在蒙哥马利算术中表示数字和乘数？</li>
<li>23 写一个C程序来实现蒙哥马利算术。</li>
<li>24 描述二元，m元和滑动窗口指数运算算法。</li>
<li>25 描述使用定义GF（p）和GF（2 ^ n）的“特殊”素数进行模减量的方法。</li>
<li>26 描述NAF标量乘法算法。</li>
</ul>
<a class="header" href="#security-definitions-and-proofs-abc" id="security-definitions-and-proofs-abc"><h3>Security Definitions and Proofs ([A,B,C])</h3></a>
<ul>
<li>27 What is the AEAD security definition for symmetric key encryption?</li>
<li>28 What is the IND-CCA security definition for public key encryption?</li>
<li>29 What is the UF-CMA security definition for digital signatures?</li>
<li>30 Roughly outline the BR security definition for key agreement?</li>
<li>31 Give one proof of something which involves game hopping</li>
<li>32 Outline the difference between a game based and a simulation based security definition.</li>
</ul>
<a class="header" href="#a中文安全定义和证明abc" id="a中文安全定义和证明abc"><h3>（中文）安全定义和证明（[A，B，C]）</h3></a>
<ul>
<li>27 对称密钥加密的AEAD安全定义是什么？</li>
<li>28 公钥加密的IND-CCA安全定义是什么？</li>
<li>29 数字签名的UF-CMA安全定义是什么？</li>
<li>30 粗略概述了密钥协议的BR安全定义？</li>
<li>31 给出一个涉及游戏跳跃的东西的证明</li>
<li>32 概述基于游戏和基于模拟的安全定义之间的区别。</li>
</ul>
<a class="header" href="#mathematical-attacks-ab" id="mathematical-attacks-ab"><h3>Mathematical Attacks ([A,B])</h3></a>
<ul>
<li>33 How does the Bellcore attack work against RSA with CRT?</li>
<li>34 Describe the Baby-Step/Giant-Step method for breaking DLPs</li>
<li>35 Give the rough idea of Pollard rho, Pollard &quot;kangaroo&quot; and parallel Pollard rho attacks on ECDLP.</li>
<li>36 What is meant by index calculus algorithms?</li>
<li>37 Roughly outline (in two paragraphs only) how the NFS works.</li>
</ul>
<a class="header" href="#a中文数学攻击ab" id="a中文数学攻击ab"><h3>（中文）数学攻击（[A，B]）</h3></a>
<ul>
<li>33 Bellcore攻击如何利用CRT对抗RSA？</li>
<li>34 描述打破DLP的Baby-Step / Giant-Step方法</li>
<li>35 给出Pollard rho，Pollard“袋鼠”和平行Pollard rho攻击ECDLP的粗略想法。</li>
<li>36 指数演算算法的含义是什么？</li>
<li>37 粗略地概述（仅在两段中）NFS的工作原理。</li>
</ul>
<a class="header" href="#practical-attacks-d" id="practical-attacks-d"><h3>Practical Attacks ([D])</h3></a>
<ul>
<li>38 What is the difference between a covert channel and a side-channel?</li>
<li>39 What is the difference between a side-channel attack and a fault attack?</li>
<li>40 What is usually considered the difference between DPA and SPA?</li>
<li>41 Are all side channels related to power analysis?</li>
<li>42 Look at your C code for Montgomery multiplication above; can you determine where it could leak side channel information?</li>
<li>43 Describe some basic (maybe ineffective) defences against side channel attacks proposed in the literature for AES.</li>
<li>44 Describe some basic (maybe ineffective) defences against side channel attacks proposed in the literature for ECC.</li>
<li>45 Describe some basic (maybe ineffective) defences against side channel attacks proposed in the literature for RSA.</li>
</ul>
<a class="header" href="#a中文实际攻击d" id="a中文实际攻击d"><h3>（中文）实际攻击（[D]）</h3></a>
<ul>
<li>38 隐蔽频道和旁道之间有什么区别？</li>
<li>39 旁道攻击和故障攻击有什么区别？</li>
<li>40 通常认为DPA和SPA之间的区别是什么？</li>
<li>41 所有旁道都与功率分析有关吗？</li>
<li>42 看看你的C代码上面的蒙哥马利乘法; 你能确定它可能泄露侧面频道信息的位置吗？</li>
<li>43 描述针对AES文献中提出的针对边信道攻击的一些基本（可能无效）的防御措施。</li>
<li>44 描述针对ECC的文献中提出的一些针对旁道攻击的基本（可能无效）防御措施。</li>
<li>45 描述针对RSA文献中提出的针对边道攻击的一些基本（可能无效）的防御措施。</li>
</ul>
<a class="header" href="#advanced-protocols-and-constructions-ab" id="advanced-protocols-and-constructions-ab"><h3>Advanced Protocols and Constructions ([A,B])</h3></a>
<ul>
<li>46 What does correctness, soundness and zero-knowledge mean in the context of a Sigma protocol?</li>
<li>47 What is the Fiat-Shamir transform?</li>
<li>48 What is the purpose and use of a TPM?</li>
<li>49 Describe the basic ideas behind IPSec and TLS.</li>
<li>50 What is the BLS pairing based signature scheme?</li>
<li>51 What is the security model for ID-based encryption, and describe one IBE scheme.</li>
<li>52 Pick an advanced application concept such as e-Voting, Auctions or Multi-Party Computation. What are the rough security requirements of such a system?</li>
</ul>
<a class="header" href="#a中文先进的协议和结构ab" id="a中文先进的协议和结构ab"><h3>（中文）先进的协议和结构（[A，B]）</h3></a>
<ul>
<li>46 在Sigma协议的背景下，正确性，健全性和零知识是什么意思？</li>
<li>47 什么是菲亚特 - 沙米尔变换？</li>
<li>48 TPM的目的和用途是什么？</li>
<li>49 描述IPSec和TLS背后的基本思想。</li>
<li>50 什么是BLS配对签名方案？</li>
<li>51 基于ID的加密的安全模型是什么，并描述了一个IBE方案。</li>
<li>52 选择电子投票，拍卖或多方计算等高级应用程序概念。 这种系统的安全要求是什么？</li>
</ul>
<a class="header" href="#further-reading" id="further-reading"><h2>Further Reading</h2></a>
<ul>
<li>[A] Nigel's book is deliberately informal and tries to give quick flavours of what is important in theory and practice.</li>
<li>[B] The Katz Lindell book is a better formal introduction to modern theoretical cryptography but it is less good in its treatment of what is important in the real world (e.g. the coverage of AES, ECC, implementation, etc is quite limited).</li>
<li>[C] Goldreich's two volume book is a very good introduction to the deep theory, but deliberately does not cover practical cryptography.</li>
<li>[D] Elisabeth's DPA book is the best introduction to all things about side-channels.</li>
<li>[E] Dan's book is a good starting place for computer architecture and learning VHDL.</li>
<li>[F] Goldreich's book on complexity theory is a good place to start. Its approach is much more down-to-earth and sensible than other approaches (i.e. P vs NP is presented in terms of is it easier to check or find proofs?)</li>
</ul>
<a class="header" href="#a-hrefhttpsbristolcryptoblogspotcom20141052-things-number-1-different-types-ofhtml处理器的区别a" id="a-hrefhttpsbristolcryptoblogspotcom20141052-things-number-1-different-types-ofhtml处理器的区别a"><h3><a href="https://bristolcrypto.blogspot.com/2014/10/52-things-number-1-different-types-of.html">处理器的区别</a></h3></a>
<pre><code>1. What is the difference between the following?
    - general-purpose processor.
    - general-purpose processor with instruction-set extensions.
    - special-purpose processor (or co-processor).
    - An FPGA.

1. 以下几点有什么区别？
   - 通用处理器。
   - 带指令集扩展的通用处理器。
   - 专用处理器（或协处理器）。
   - 一个FPGA。
</code></pre>
<p>There is no strict definition of a general-purpose processor, however, it is widely accepted that a processor is general if it is Turing-complete. This captures any processor that is able to compute anything actually computable (i.e. can solve any problem a Turing machine can). I will not delve into the definition of a Turing machine but if I've already lost you then I would recommend brushing up on your Theory of Computation [1]. Note though that this definition has no concept of performance or instruction-set capabilities and, in fact, some researchers have gone through the trouble of proving that you may only need a single instruction to be Turing-complete [2]. In the context of modern processors, most programmable CPUs are considered general purpose.</p>
<p>对通用处理器没有严格的定义，但是，如果处理器是图灵完备的，则该处理器是普遍通用的。这捕获了能够计算任何实际可计算的任何处理器（即，可以解决图灵机可能遇到的任何问题）。 我不会深入研究图灵机的定义，但是如果你完全理解不了我说的东西的化，那么我会建议你刷一下你的计算理论[1]。 请注意，虽然这个定义没有任何性能或指令集功能的概念，事实上，一些研究人员经历了证明您可能只需要一条指令即可完成图灵完成的麻烦[2]。 在现代处理器的情况下，大多数可编程CPU被认为是通用的。</p>
<p>The cost of being general-purpose usually comes at a penalty in performance. Specifically, a general-purpose processor may be able to compute anything computable but, it will never excel at complex repeated tasks. Given a task that is repeated regularly on a general-purpose processor in a wide variety of applications, a processor designer may incorporate instruction-set extensions to the base micro-architecture to accommodate the task. Functionally, there may be no difference in the micro-architecture capabilities but practically there may be huge performance gains for the end-user.</p>
<p>通用性的成本通常会导致性能上的损失。具体来说，通用处理器可能能够计算任何可计算的值，但是，在复杂的重复任务中，它永远不会出类拔萃。 鉴于在各种应用中的通用处理器上定期重复的任务，处理器设计人员可将指令集扩展集成到基本微架构以适应任务。 在功能上，微架构能力可能没有区别，但实际上最终用户可能会获得巨大的性能收益。</p>
<p>As we're all cryptographers here, I will stick to a crypto example for instruction-set extensions. Consider a desktop machine with an AES encrypted disk. Any reads from secondary storage require a CPU interrupt to decrypt the data blocks before being cached. Given disk access from a cache miss is already considered terrible, add the decryption routine over the top and you have a bottleneck worth making you re-consider your disk encryption. It should be clear here that AES is our complex repeated task and given a general-purpose CPU with a simple instruction-set, we have no choice but to implement the decryption as a linear stream operations. Intel and AMD both recognised the demand for disk encryption and the penalty AES adds to secondary storage access and have (since circa 2010) produced the AES-NI x86 instruction-set extension to accelerate disk encryption on the their line of desktop CPUs.</p>
<p>由于我们都是密码技术人员，因此我将坚持使用指令集扩展的加密示例。考虑使用AES加密磁盘的台式机。从辅助存储的任何读取都需要CPU中断才能在缓存之前解密数据块。 考虑到从高速缓存未命中的磁盘访问已被认为是可怕的，请在顶部添加解密例程，并且存在一个值得您重新考虑磁盘加密的瓶颈。 这里应该清楚的是，AES是我们复杂的重复任务，并且通过一个具有简单指令集的通用CPU，我们别无选择，只能将解密作为线性流操作来实现。 英特尔和AMD都认识到磁盘加密的需求以及AES增加二级存储访问的损失，并且（自2010年以来）已经制定了AES-NI x86指令集扩展，以加速其台式机CPU系列上的磁盘加密。</p>
<p>If you want to fully accelerate any computation, the most optimal result will always be a special-purpose processor or an Application-specific integrated circuit (ASIC). Here we lose a significant portion of the flexibility granted by a general-purpose processor in exchange for performance gains. These types of processors are often tightly-coupled to a general-purpose processor, hence the term co-processor. Note, a co-processor may indeed be in the same package as a general-purpose processor but not necessarily integrated into the general-purpose architecture. Once again, if we turn to modern processor architectures, Intel and AMD have both integrated sound cards, graphics processors and DSP engines into their CPUs for some time now. The additional functionality is exposed via special-purpose registers and the co-processor treated as a separate component which the general-purpose processor must manage.</p>
<p>如果您想全面加速任何计算，最佳结果将始终是专用处理器或专用集成电路（ASIC）。 在这里，我们失去了通用处理器授予的灵活性的重要部分，以换取性能提升。 这些类型的处理器通常与通用处理器紧密耦合，因此称为协处理器。 请注意，协处理器可能确实与通用处理器在同一个封装中，但未必集成到通用架构中。 再一次，如果我们转向现代处理器架构，英特尔和AMD现在已经将声卡，图形处理器和DSP引擎集成到了他们的CPU中。 附加功能通过专用寄存器公开，协处理器视为通用处理器必须管理的独立组件。</p>
<p>Finally we turn to Field-Programmable Gate Arrays (FPGAs). The middle-ground between ASIC and general-purpose processors. If an application demands high-performance throughput but also requires (infrequent) modification then an FPGA is probably the answer. To understand how an FPGA works, consider a (very) large electronics breadboard with thousands of logic-gates and lookup tables (multiplexers attached to memory) placed all around the breadboard. If you describe an application as a set of gates and timing constraints then you can wire it together on the breadboard and produce a circuit that will evaluate your application. An FPGA affords the flexibility of being re-programmable whilst producing the dedicated logic to evaluate a target application. The key difference to a general-purpose program is how you design and build your application. In order to get the most out of the hardware you must describe the application as a set of hardware components and events using a hardware description language (Verilog or VHDL). This process is frequently used to prototype general-purpose and special-purpose processors on FPGAs before production. However, it is not without its drawbacks. Designing a program with low-level building blocks becomes very cumbersome for large applications. In addition, the energy consumption and hardware costs are generally higher in comparison to a general-purpose embedded IC. Recently, FPGA manufacturer Xilinx have begun shipping FPGAs with ARM general-purpose cores integrated within a single package [3]. This now makes FPGAs available to the ARM core as a flexible co-processor. As a result, you can build dedicated logic to evaluate your crypto primitives and hence accelerate cryptographic applications.</p>
<p>最后我们转向现场可编程门阵列（FPGA）。 ASIC和通用处理器之间的中间地带。如果一个应用需要高性能的吞吐量，但也需要（不频繁的）修改，那么FPGA可能就是答案。为了理解FPGA的工作原理，考虑一个（非常）大型的电子面包板，在面包板上放置数千个逻辑门和查找表（内存中的多路复用器）。如果您将应用程序描述为一组门和时序约束条件，那么您可以将它连接在面包板上，并生成一个评估应用程序的电路。 FPGA提供了重新编程的灵活性，同时生成用于评估目标应用的专用逻辑。与通用程序的主要区别在于您如何设计和构建您的应用程序。为了充分利用硬件，您必须使用硬件描述语言（Verilog或VHDL）将应用程序描述为一组硬件组件和事件。在生产之前，这个过程经常用于在FPGA上对通用和专用处理器进行原型设计。然而，这并非没有缺点。使用低级构建块设计程序对于大型应用程序来说非常麻烦。另外，与通用嵌入式IC相比，能耗和硬件成本通常较高。最近，FPGA制造商赛灵思公司已经开始提供集成在单个封装内的ARM通用内核的FPGA [3]。现在，这使得FPGA可以作为灵活的协处理器使用FPGA。因此，您可以构建专用逻辑来评估您的加密原语，从而加速加密应用程序。</p>
<p>In summary, general-purpose processors are capable of computing anything computable. Similarly for a general-purpose processor with instruction-set extensions and it may perform better in particular applications. A special-purpose (or co-processor) is very fast at a particular task but is unable to compute anything outside of that. An FPGA can be used to build all of the above hardware but sacrifices speed for flexibility over an ASIC solution.</p>
<p>总之，通用处理器能够计算任何可计算的内容。 类似地，对于具有指令集扩展的通用处理器，它在特定应用中可能表现更好。 特殊用途（或协处理器）在特定任务中速度非常快，但无法计算任何其他内容。 FPGA可用于构建所有上述硬件，但牺牲ASIC解决方案的灵活性。</p>
<ul>
<li>[1] http://www.amazon.co.uk/Introduction-Theory-Computation-Michael-Sipser/dp/0619217642</li>
<li>[2] http://www.cl.cam.ac.uk/~sd601/papers/mov.pdf</li>
<li>[3] http://www.xilinx.com/products/zynq-7000/extensible-virtual-platform.htm</li>
</ul>
<a class="header" href="#a-hrefhttpsbristolcryptoblogspotcom20141052-things-number-2-what-is-differencehtml多核处理器和矢量处理器有什么区别a" id="a-hrefhttpsbristolcryptoblogspotcom20141052-things-number-2-what-is-differencehtml多核处理器和矢量处理器有什么区别a"><h3><a href="https://bristolcrypto.blogspot.com/2014/10/52-things-number-2-what-is-difference.html">多核处理器和矢量处理器有什么区别？</a></h3></a>
<pre><code>What is the difference between a multi-core processor and a vector processor ?
多核处理器和矢量处理器有什么区别？
</code></pre>
<p>What is parallel computing?</p>
<p>什么是并行计算？</p>
<p>Before answering this question we first need to consider the conventional “serial” model of processing. Let's do so by imagining some problem we need to solve. The way serial computing solves this problem is by viewing it as a number of steps (instructions) which the processor deals with in sequential order. The processor deals with each of the instructions and then at the end, the answer comes out and the problem is solved. Whilst being a wonderful way of solving the problem it does however imply a bottleneck in the speed of solving it. Namely, the speed of the processor at executing the individual instructions. This is fine if the problem isn’t too large, but what happens when we have to deal with larger problems or want to compute things faster? Is there a way of increasing the speed of computation without the bottleneck of the speed of the processor?</p>
<p>在回答这个问题之前，我们首先需要考虑传统的“串行”处理模型。让我们通过想象一些我们需要解决的问题来做到这一点。串行计算解决此问题的方式是将其视为处理器按顺序处理的若干步骤（指令）。处理器处理每条指令，最后答案出来，问题就解决了。虽然是解决问题的好方法，但它确实意味着解决问题的速度的瓶颈。即，处理器在执行单个指令时的速度。如果问题不是太大，这很好，但是当我们必须处理更大的问题或想要更快地计算事情时会发生什么？在没有处理器速度瓶颈的情况下，是否可以提高计算速度？</p>
<p>The answer as you might have guessed is yes and it comes in the form of something called parallel computing. What parallel computing does to the problem we are trying to solve is to break it down into smaller problems, each of which can be computed separately at the same time. In this way, the problem is distributed over different processing elements which perform each of these different sub problems simultaneously, providing a potentially significant increase in speed of computation – the amount of speed up depends on the algorithm and can be determined by Amdahl's law [1]. So how does this all work? How can you process things in such a way as this? Well two solutions to the problem are multi-core and vector processors.</p>
<p>您可能已经猜到的答案是肯定的，它以一种称为并行计算的形式出现。并行计算对我们试图解决的问题做的是将其分解成更小的问题，每个问题都可以同时单独计算。通过这种方式，问题分布在不同的处理单元上，这些单元同时执行这些不同的子问题中的每一个，提供了计算速度的潜在显着增加 - 加速的量取决于算法并且可以由Amdahl定律[1]。那么这是如何工作的？你如何以这种方式处理事物？那么问题的两个解决方案是多核和矢量处理器。</p>
<p>What is a multi-core processor?</p>
<p>什么是多核心处理器？</p>
<p>A multi-core processor is a single computing component that carries out parallel computing by using multiple serial processors to do different things at the same time. The sub problems of the bigger problem discussed earlier are each solved by a separate processor allowing programs to be computed in parallel. It's like having multiple people working on a project where each person is given a different task to do, but all are contributing to the same project. This might take some extra organising to do, but the overall speed of getting the project completed is going to be faster.</p>
<p>多核处理器是一个单一的计算组件，它通过使用多个串行处理器同时执行不同的事情来执行并行计算。前面讨论的更大问题的子问题每个都通过一个单独的处理器解决，允许程序并行计算。这就像有多个人在一个项目中工作，每个人都有不同的任务要做，但是所有人都参与了同一个项目。这可能需要一些额外的组织才能完成，但完成项目的总体速度将会更快。</p>
<p>What is a vector processor?</p>
<p>什么是矢量处理器？</p>
<p>A vector processor is a processor that computes single instructions (as in a serial processor) but carries them out on multiple data sets that are arranged in one dimensional arrays (unlike a standard serial processor which operates on single data sets). The idea here is that if you are doing the same thing many times to different data sets in a program, rather than executing a single instruction for each piece of data why not do the instruction to all the sets of data once? The acronym SIMD (Single Instruction Multiple Data) is often used to denote instructions that work in this way.</p>
<p>矢量处理器是一种计算单个指令（如串行处理器中的处理器）的处理器，但将它们传输到多维数据集中，这些数据集以一维阵列排列（不像标准串行处理器，它在单一数据集上运行）。这里的想法是，如果你对程序中的不同数据集多次执行相同的操作，而不是对每一块数据执行单条指令，为什么不对所有数据集执行一次指令呢？首字母缩略词SIMD（单指令多数据）通常用于表示以这种方式工作的指令。</p>
<p>What is the difference?</p>
<p>有什么不同？</p>
<p>So that's the general idea, let's sum up with an example. Let's say we want roll 4 big stones across a road and it takes one minute to do each roll. The serial processor rolls them one by one and so takes four minutes. The multi core processor with two cores has two people to roll stones so each one rolls two stones, it takes two minutes. The vector processor gets a long plank of wood, puts it behind all four stones and pushes them all in one, taking one minute. The multi core processor has multiple workers, the vector processor has a way of doing the same thing to multiple things at the same time.</p>
<p>所以这是总体思路，让我们总结一个例子。比方说，我们希望在路上滚动4块大石头，每分钟完成一个。串行处理器将它们一个接一个地滚动，因此需要四分钟。双核多核处理器有两个人滚动石头，每个人滚动两个石头，这需要两分钟。矢量处理器得到一块长木板，把它放在所有四块石头的后面，并将它们全部放入一块，花费一分钟。多核处理器有多个工作者，矢量处理器可以同时对多件事情做同样的事情。</p>
<p>[1] http://en.wikipedia.org/wiki/Amdahl%27s_law（阿姆达尔定律）</p>
<a class="header" href="#a-hrefhttpsbristolcryptoblogspotcom20141052-things-q3-computational-and-storagehtml计算和存储功率的不同形式因素a" id="a-hrefhttpsbristolcryptoblogspotcom20141052-things-q3-computational-and-storagehtml计算和存储功率的不同形式因素a"><h3><a href="https://bristolcrypto.blogspot.com/2014/10/52-things-q3-computational-and-storage.html">计算和存储功率的不同形式因素</a></h3></a>
<pre><code>Computational and storage power of different form factors

Q3: Estimate the relative computational and storage capabilities of

    a smart-card
    a micro-controller (i.e. a sensor node)
    an embedded or mobile computer (e.g., a mobile phone or PDA)
    a laptop- or desktop-class computer.

Q3 估计以下设备的相对计算和存储能力
    - 一张智能卡
    - 微控制器（即传感器节点）
    - 嵌入式或移动计算机（例如，移动电话或PDA）
    - 一台笔记本电脑或台式电脑。
</code></pre>
<p>To measure the computational capability of a device we could assess the clock speed of its processors. This may be misleading if the processor enables some form of parallelism---two cores running at 2 GHz obviously possess more computational power than a single core running at 2 GHz, and so finding a direct quantitative measure is not a realistic expectation. For specific devices like general purpose graphics cards, often the total FLOPS (floating point operations per second) the device is capable of sustaining is reported (for either single or double precision arithmetic) but even this measure is not a particularly reliable choice when applied to any given problem---indeed, some services facilitate a comparison by benchmarking the performance of different devices on a variety of problem instances---see, for example, CompuBench. Fortunately the range of capabilities of the devices included in the question makes a sufficient answer less dependent on quantitative metrics.</p>
<p>为了测量设备的计算能力，我们可以评估其处理器的时钟速度。如果处理器支持某种形式的并行处理，这可能会产生误导 - 两个以2 GHz运行的内核显然拥有比以2 GHz运行的单内核更高的计算能力，因此找到一个直接的定量测量并不是一个现实的期望。对于像通用图形卡这样的特定设备，通常报告设备能够维持的FLOPS（每秒浮点运算）能力（无论是单精度算法还是双精度算法），但即使采用此方法，该度量也不是特别可靠的选择任何给定的问题---实际上，一些服务通过基准测试不同设备在各种问题实例上的性能来促进比较---例如参见CompuBench。幸运的是，问题中所包含设备的功能范围足以满足量化指标的要求。</p>
<p>A measure for the storage capabilities of each device is much simpler to find: we can simply compare the approximate number of bytes of information the device is capable of holding on permanent storage.</p>
<p>对每个设备的存储能力的衡量要简单得多：我们可以简单地比较设备能够保存在永久存储上的大致信息字节数。</p>
<p>A smart-card is the least computationally powerful device: obviously clock speeds vary for different implementations, but one might expect to see around a 20 MHz core speed. In terms of storage, a typical smart-card might have around 2 kilobytes (KiB) available.</p>
<p>智能卡是计算能力最低的设备：显然不同的实施方式的时钟速度会有所不同，但人们可能会预计会看到20 MHz左右的核心速度。在存储方面，典型的智能卡可能有大约2千字节（KiB）可用。</p>
<p>A microcontroller is &quot;a small computer on a single integrated circuit containing a processor core, memory, and programmable input/output peripherals&quot; [1]. The range of storage and compute capability available will vary significantly according to the exact definition of microcontroller, but taking the suggested sensor node as an example, a typical microcontroller is likely to have similar computational capabilities as a smart-card and slightly more storage available, perhaps in the order of a few KiB to a few megabytes (MiB).</p>
<p>微控制器是“包含处理器内核，存储器和可编程输入/输出外设的单个集成电路上的小型计算机”[1]。根据微控制器的确切定义，可用的存储和计算能力的范围会有很大差异，但以建议的传感器节点为例，典型的微控制器可能具有与智能卡相似的计算能力，也许是几个KiB到几兆字节（MiB）的顺序。</p>
<p>A mobile computer such as a mobile phone has significantly more storage and computing power, and the amount of power available is rapidly increasing over time. Taking the 2008 iPhone and the 2013 Nexus 5 phone as an example, the iPhone used a 412 MHz 32-bit RISC ARM core, and the Nexus 5 CPU used is a 2.3 GHz quad-core processor. In terms of storage, if we ignore the ability of some phones to use removable storage, then a high-end phone in 2013 might expect to provide in the order of 16 to 32 gigabytes (GiB) of storage.</p>
<p>诸如移动电话之类的移动计算机具有显着更多的存储和计算能力，并且随着时间的推移，可用的功率量正在迅速增加。以2008 iPhone和2013 Nexus 5手机为例，iPhone使用了412 MHz 32位RISC ARM内核，所用的Nexus 5 CPU为2.3 GHz四核处理器。在存储方面，如果我们忽略某些电话使用可移动存储的能力，那么2013年的高端手机可能会提供16至32千兆字节（GiB）的存储量。</p>
<p>Finally, most laptop or desktop class computers are likely to have more processing power than a mobile phone: the high-end Intel &quot;Haswell&quot; i7 4960K processor contains 4 cores each clocked at 4 GHz, and the AMD &quot;Piledriver&quot; FX-9590 CPU contains 8 cores at 4.7 GHz---note that a direct comparison between these two processors requires more than just assessing core counts and clock speeds! There are other factors that can affect the computing capabilities of a desktop or laptop computer---in particular, the addition of a graphics processing unit can, for certain problems, provide a large increase in performance. The storage capacity of a laptop or desktop can vary tremendously, but a typical amount of storage in a consumer machine might be between hundreds of gigabytes and several terabytes (TiB)---the largest single hard drive capacities are now around 8 TiB.</p>
<p>最后，大多数笔记本电脑或台式计算机的处理能力可能会高于手机：高端英特尔“Haswell”i7 4960K处理器包含4个核心，每个核心的时钟频率为4 GHz，AMD“Piledriver”FX-9590 CPU包含8个4.7 GHz内核 - 注意，这两个处理器之间的直接比较不仅仅需要评估内核计数和时钟速度！还有其他一些因素可能会影响台式机或笔记本电脑的计算能力 - 特别是，对于某些问题，添加图形处理单元可以大大提高性能。笔记本电脑或台式机的存储容量可能会有很大的差异，但消费机中的典型存储容量可能在数百千兆字节和几千兆字节（TiB）之间---最大的单个硬盘容量现在约为8千兆字节。</p>
<p>[1] https://en.wikipedia.org/wiki/Microcontroller</p>
<a class="header" href="#a-hrefhttpsbristolcryptoblogspotcom20141052-things-number-4-complexity-class-phtml复杂度类pa" id="a-hrefhttpsbristolcryptoblogspotcom20141052-things-number-4-complexity-class-phtml复杂度类pa"><h3><a href="https://bristolcrypto.blogspot.com/2014/10/52-things-number-4-complexity-class-p.html">复杂度类P</a></h3></a>
<pre><code>The Complexity Class P
复杂度类P
</code></pre>
<a class="header" href="#section-1-complexity-and-big-o-notation" id="section-1-complexity-and-big-o-notation"><h4>Section 1: Complexity and Big O Notation</h4></a>
<a class="header" href="#a第一部分-复杂度与大o表示法" id="a第一部分-复杂度与大o表示法"><h4>第一部分: 复杂度与大O表示法</h4></a>
<p>We want to know how difficult a given task is for a computer to do in order to design efficient programs. The trouble is that the processing power of a computer varies massively depending on the hardware (e.g. see last week's '52 Things' blog). So we want a measure of the difficulty of a task that doesn't depend on the specific details of the machine performing the task. One way to do this is to bound the number of operations that a certain model of a computer would take to do it. This is called (time) complexity theory.</p>
<p>我们想知道为了设计高效的程序，计算机要完成的任务是多么困难。 问题在于计算机的处理能力因硬件而异。 所以我们想要衡量一个任务的难度，而这个任务并不依赖于机器执行任务的具体细节。 要做到这一点的一种方法是限制计算机的特定型号执行操作的次数。 这被称为（时间）复杂性理论。</p>
<p>Typically, though, the number of operations required will depend on the input to the task and may vary even with inputs of the same length. As a pertinent example, say we design a computer program which tells you whether or not an integer you input is prime. If we give as input the number 256, the program will probably output 'not prime' sooner than if we had given it the number 323 (even though they both have length 9 when written as binary integers, for example), since the first integer has a very small prime factor (2) and the second has larger factors (17 and 19). Therefore we usually opt for a worst-case analysis where we record the longest running time of all inputs of a particular length. So we obtain an algebraic expression t(n) that reflects the longest running time of all inputs of length n.</p>
<p>但是，通常情况下，所需的操作数量取决于任务的输入，即使输入的长度相同，也可能会有所不同。 作为一个相关的例子，假设我们设计了一个计算机程序，它告诉你你输入的整数是否为素数。 如果我们以256为输入，那么程序可能会比输入数字323更快地输出“not prime”（即使它们的长度为9时，例如写为二进制整数），因为第一个整数 有一个非常小的素因子（2），第二个有更大的因子（17和19）。 因此，我们通常选择最差情况下的分析，记录特定长度的所有输入的最长运行时间。 所以我们得到一个代数表达式t（n），它反映了长度为n的所有输入的最长运行时间。</p>
<p>Furthermore, when the input length n becomes very large, we can neglect all but the most dominant term in the expression and also ignore any constant factors. This is called asymptotic analysis; we assume n is enormous and ask roughly how many steps the model of computation will take to 'finish' when given the worst possible input of length n, writing our answer in the form O(t(n)). For example, if we find that our process takes 6n^3–n^2+1 steps, we write that it is O(n^3), since all other terms can be ignored for very large n.</p>
<p>此外，当输入长度n变得非常大时，我们可以忽略除表达式中最主要的术语之外的所有术语，也忽略任何常数因素。 这被称为渐近分析; 我们假设n是巨大的，并且当给定长度为n的最差可能输入时，计算模型将大致要求“完成”多少个步骤，以O（t（n））的形式写出我们的答案。 例如，如果我们发现我们的过程需要6n^3-n^2 + 1个步骤，我们写它是O（n^3），因为对于非常大的n，所有其他项可以被忽略。</p>
<a class="header" href="#section-2-turing-machines" id="section-2-turing-machines"><h4>Section 2: Turing Machines</h4></a>
<a class="header" href="#a第二部分图灵机器" id="a第二部分图灵机器"><h4>第二部分：图灵机器</h4></a>
<p>Now we give the model that is most often used in the kind of calculations performed in Section 1. First, recall that an alphabet is a non-empty finite set and a string is a finite sequence of elements (symbols) from an alphabet. A language is simply a set of strings.</p>
<p>现在我们给出在第1节中进行的计算中最常用的模型。首先，回顾一下，字母表是一个非空的有限集，而字符串是字母表中元素（符号）的有限序列。 语言只是一组字符串。</p>
<p>A Turing machine models what real computers can do. Its 'memory' is an infinitely long tape. At any time, each square of the tape is either blank or contains a symbol from some specified alphabet. The machine has a tape head that can move left or right along the tape, one square at a time, and read from and write to that square. At first, the tape is all blank except for the leftmost n squares which constitute the input (none of which can be blank so that it is clear where the input ends). The tape head starts at the leftmost square, reads the first input symbol and then decides what to do next according to a transition function. The transition function depends on what it reads at the square it is currently on and the state that the machine is currently in (like a record of what it has done so far) and returns</p>
<ul>
<li>a new state</li>
<li>another symbol to write to the square it is on (though this symbol might be the same as what was already written there)</li>
<li>a direction to move in: left or right.</li>
</ul>
<p>图灵机模拟真正的电脑可以做什么。它的“记忆”是一个无限长的磁带。在任何时候，磁带的每个方块都是空白的或包含某个指定字母表中的符号。机器有一个磁带头，可以沿着磁带向左或向右移动，一次一个方形，读取并写入该方形。首先，除了构成输入的最左边的n个正方形（其中没有一个可以是空白，以便清楚输入端在哪里）之外，磁带全部空白。磁带头从最左边的方块开始，读取第一个输入符号，然后根据转换函数决定下一步该做什么。转换函数取决于它在当前所在的平方上读取的内容以及机器当前处于的状态（如迄今所做的记录）并返回</p>
<ul>
<li>一个新的状态</li>
<li>另一个符号写在它所在的正方形上（虽然这个符号可能与已经写在那里的符号相同）</li>
<li>向左或向右移动的方向。</li>
</ul>
<p>The machine will continue to move one square at a time, read a symbol, evaluate the transition function, write a symbol and move again, until its state becomes some specified accept state or reject state.</p>
<p>机器将一次继续移动一个方块，读取符号，评估转换函数，写入符号并再次移动，直到其状态变为某个指定的接受状态或拒绝状态。</p>
<p>If the machine ends up in the accept state, we say it accepts its input. Similarly it may reject its input. In either case we say the machine halts on its input. But note that it may enter a loop without accepting or rejecting i.e. it may never halt. If a Turing machine accepts every string in some language and rejects all other strings, then we say the machine decides that language. We can think of this as the machine testing whether or not the input string is a member of the language. Given a language, if there is a Turing machine that decides it, we say the language is decidable.</p>
<p>如果机器处于接受状态，我们说它接受它的输入。 同样，它可能会拒绝其输入。 无论哪种情况，我们都会说机器停止输入。 但请注意，它可能会进入循环而不接受或拒绝，即它可能永不停止。 如果图灵机接受某种语言的每个字符串并拒绝所有其他字符串，那么我们说机器决定该语言。 我们可以认为这是机器测试输入字符串是否是该语言的成员。 给定一种语言，如果有一台图灵机来决定它，我们说这种语言是可以确定的。</p>
<p>The power of this model comes from the fact that a Turing machine can do everything that a real computer can do (this is called the Church-Turing thesis [2]). We define the time complexity class TIME(t(n)) to be the collection of all languages that are decidable by an O(t(n)) time Turing machine, then we turn computational problems into questions about language membership (is an input string a member of a certain language? e.g. does this string representing an integer belong to the language of strings representing prime integers?) and can partition computational problems into time complexity classes.</p>
<p>这个模型的强大之处在于图灵机可以完成真实计算机可以完成的任务（这被称为教会图灵论文[2]）。 我们将时间复杂性类TIME（t（n））定义为可由O（t（n））时间图灵机确定的所有语言的集合，然后将计算问题转化为有关语言成员关系的问题 字符串是某种语言的成员？例如，表示整数的字符串是否属于表示整数的字符串的语言？），并且可以将计算问题划分为时间复杂度类。</p>
<a class="header" href="#section-3-the-complexity-class-p" id="section-3-the-complexity-class-p"><h4>Section 3: The Complexity Class P</h4></a>
<a class="header" href="#a第三部分复杂度类p" id="a第三部分复杂度类p"><h4>第三部分：复杂度类P</h4></a>
<p>Finally, we arrive at the purpose of this blog! If t(n)=n^k for some k&gt;0 then O(t(n)) is called polynomial time. The complexity class P is the class of all languages that are decidable in polynomial time by a Turing machine. Since k could be very large, such Turing machines are not necessarily all practical, (let alone 'fast'!), but this class is a rough model for what can be realistically achieved by a computer. Note that the class P is fundamentally different to those languages where t(n) has n in an exponent, such as 2^n, which grow much, much faster as n increases – so fast that even if you have a decider for some language, you may find that the universe ends before it halts on your input!</p>
<p>最后，我们到达这个博客的目的！如果对于某个k&gt; 0，t（n）= n ^ k，那么O（t（n））称为多项式时间。复杂度等级P是图灵机在多项式时间内可确定的所有语言的类。由于k可能非常大，所以这样的图灵机并不一定都是实用的（更不用说'快速'了！），但是这个类是计算机可以实现的粗略模型。请注意，类P与t（n）具有n的指数形式（如2 ^ n）的语言根本不同，后者随着n的增加而增长得更快，速度更快 - 即使您对某种语言有决定因素，你可能会发现宇宙在它停止输入之前就结束了！</p>
<p>We conclude with an example of a polynomial time problem. Suppose you have a directed graph (a set of nodes and edges where there is at most one edge between any pair of nodes and each edge has an arrow indicating a direction). Then if we encode the graph and the two nodes as a single string, we can form a language consisting of those strings representing a graph and two nodes such that it is possible to follow the edges from the first node and eventually arrive at the second. So a decider for this language will effectively answer the question of whether there is a path from the first node A to the second B, called the path problem, by accepting or rejecting the graph and nodes you input. We give a decider for this language and show that it decides in polynomial time.</p>
<ul>
<li>First put a mark on A.</li>
<li>Scan all the edges of the graph. If you find an edge from a marked node to an unmarked node, mark the unmarked node.</li>
<li>Repeat the above until you mark no new nodes.</li>
<li>If B is marked, accept. Otherwise, reject.</li>
</ul>
<p>我们以一个多项式时间问题的例子来结束。假设你有一个有向图（一组节点和边，其中任何一对节点之间至多有一条边，每条边都有一个指示方向的箭头）。然后，如果我们将图形和两个节点编码为一个单独的字符串，我们可以形成一个由代表一个图形和两个节点的字符串组成的语言，从而可以跟随第一个节点的边缘并最终到达第二个节点。因此，这种语言的决策者将通过接受或拒绝您输入的图和节点来有效地回答是否存在从第一个节点A到第二个B的路径，称为路径问题。我们给这个语言的决定因素，并表明它决定多项式时间。</p>
<ul>
<li>首先在A上划一个标记。</li>
<li>扫描图形的所有边缘。如果您发现从标记节点到未标记节点的边缘，请标记未标记节点。</li>
<li>重复上述操作直到您不标记新节点。</li>
<li>如果B被标记，接受。否则，拒绝。</li>
</ul>
<p>This process successively marks the nodes that are reachable from A by a path of length 1, then a path of length 2, and so on. So it is clear that a Turing machine implementing the above is a decider for our language. Now we consider the time complexity of this algorithm. If we couldn't do steps 1 and 4 in polynomial time, our machine would be terrible! So we focus on steps 2 and 3. Step 2 involves searching the input and placing a mark on one square, which is clearly polynomial time in the size of the input. Step 3 repeats step 2 no more times than the number of nodes, which is necessarily less than the size of the input (since the input must encode all the nodes of the graph) and is hence polynomial (in particular, linear) in the size of the input. Therefore the whole algorithm is polynomial time and so we say the path problem is in P.</p>
<p>该过程依次标记可从A到达长度为1的路径，然后是长度为2的路径的节点，以此类推。所以很明显，实现上述功能的图灵机是我们语言的决定者。现在我们考虑这个算法的时间复杂度。如果我们不能在多项式时间内执行步骤1和4，那么我们的机器会很糟糕！因此，我们将重点放在步骤2和步骤3.步骤2涉及搜索输入并在一个正方形上放置标记，该标记显然是输入大小的多项式时间。步骤3重复步骤2的次数不超过节点的数量，节点的数量必须小于输入的大小（因为输入必须对图的所有节点进行编码），因此其大小为多项式（特别是线性）的输入。因此整个算法是多项式时间，所以我们说路径问题在P中。</p>
<ul>
<li>[1] http://www.amazon.co.uk/Introduction-Theory-Computation-Michael-Sipser/dp/0619217642</li>
<li>[2] http://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis</li>
</ul>
<a class="header" href="#a-hrefhttpsbristolcryptoblogspotcom20141152-things-number-5-what-is-meant-byhtml复杂度类npa" id="a-hrefhttpsbristolcryptoblogspotcom20141152-things-number-5-what-is-meant-byhtml复杂度类npa"><h3><a href="https://bristolcrypto.blogspot.com/2014/11/52-things-number-5-what-is-meant-by.html">复杂度类NP</a></h3></a>
<pre><code>Q5 What is meant by the complexity class NP ?
Q5 复杂度类NP含义是什么？

</code></pre>
<p>Last week, Ryan introduced us to complexity classes, and in particular to P:</p>
<ul>
<li>P  is the class of languages decidable in polynomial time by a deterministic Turing machine.</li>
</ul>
<p>This week, we introduce another complexity class:</p>
<ul>
<li>NP is the class of languages decidable in polynomial time by a nondeterministic Turing machine.</li>
</ul>
<p>上周，Ryan向我们介绍了复杂类课程，特别是P：</p>
<ul>
<li>P 是确定性图灵机在多项式时间内可确定的语言类。</li>
</ul>
<p>本周，我们介绍另一个复杂类：</p>
<ul>
<li>NP 是一种非确定性图灵机在多项式时间内可确定的语言类。</li>
</ul>
<a class="header" href="#what-is-a-nondeterministic-turing-machine-ndtm-什么是非确定性图灵机ndtm" id="what-is-a-nondeterministic-turing-machine-ndtm-什么是非确定性图灵机ndtm"><h4>What is a Nondeterministic Turing Machine (NDTM)? 什么是非确定性图灵机（NDTM）？</h4></a>
<p>Well, an NDTM is a Turing Machine for which the transition function can have multiple values for the same tape value/state pair (meaning it is not technically a function any more, so the correct thing would be to call it a transition relation). Thus evaluation of an NDTM on any particular input can be thought of as a tree, branching at each point the transition function provides more than one possible value. Now, an NDTM evaluates all of these possible branches at once, and accepts if at least one of these computations halts in the accept state. This definition generalizes from language membership to decision to computational problems in the same way as P did in last weeks blog.</p>
<p>NDTM是一个图灵机，对于它来说，转换函数对于同一个磁带值/状态对可以有多个值（这意味着它在技术上不再是一个函数，所以正确的做法是将其称为转换关系）。 因此，对任何特定输入的NDTM的评估可以被认为是一棵树，在每个点处，分支转换函数提供了多于一个可能的值。 现在，NDTM一次评估所有这些可能的分支，并接受这些计算中至少有一个是否在接受状态下停止。 这个定义从语言成员到决策到计算问题的泛化，就像P在上周的博客中一样。</p>
<a class="header" href="#some-examples-of-np-problems-np问题的一些例子" id="some-examples-of-np-problems-np问题的一些例子"><h4>Some Examples of NP problems NP问题的一些例子</h4></a>
<p>We begin with an easy example: path finding. Given a directed graph (on n vertices) is there a path from vertex A to vertex B. How do we know this is in NP? Well, there is an NDTM that solves it, which basically works by simply trying every route by branching each time there is a junction. If one of these branches (ie one of the trial routes) reaches B, then that branch terminates in the accept state. Any branch that does not reach B within n steps (ie after traversing n edges) terminates in the reject state. Since any path will involve at most n-1 edges, any valid route will be detected, and so this machine correctly decides whether the path exists.</p>
<p>我们从一个简单的例子开始：寻路。 给定一个有向图（在n个顶点上）有一条从顶点A到顶点B的路径。我们怎么知道这是NP？ 那么，有一个NDTM可以解决这个问题，它基本上是通过在每次有分支时通过分支尝试每条路径来工作的。 如果其中一个分支（即其中一条试验路线）达到B，则该分支终止于接受状态。 任何在n步内未达到B的分支（即在遍历n个边之后）终止于拒绝状态。 由于任何路径最多会涉及n-1条边，因此将检测到任何有效的路由，因此此机器会正确判断路径是否存在。</p>
<p>One of the key examples of an NP problem is the satisfiability problem:</p>
<ul>
<li>SAT: Given an expression in n boolean variables, is there an assignment of the variables such that the expression evaluates to True?</li>
</ul>
<p>NP问题的一个关键例子是可满足性问题：</p>
<ul>
<li>SAT：给定n个布尔变量中的表达式，是否有变量赋值，以使表达式求值为True？</li>
</ul>
<p>For example, the expression (A∧B)∨(A∧¬B) is satisfiable, with one valid assignment being A=B=True. Note that in it's standard form, SAT is a decision problem: it suffices to decide whether such an assignment exists, we don't have to find it.</p>
<p>例如，表达式 (A∧B)∨(A∧¬B) 可以满足，一个有效赋值是A = B = True。 请注意，在标准形式中，SAT是一个决策问题：决定是否存在这样的任务就足够了，我们不需要找到它。</p>
<a class="header" href="#ok-so-there-are-problems-in-np-what-is-interesting-about-it-ok所以np是有问题的-有趣的是什么" id="ok-so-there-are-problems-in-np-what-is-interesting-about-it-ok所以np是有问题的-有趣的是什么"><h4>Ok, so there are problems in NP. What is interesting about it? OK，所以NP是有问题的。 有趣的是什么？</h4></a>
<p>Firstly, we see that P ？= NP since a DTM is an NDTM that just happens not to ever branch (in fact, our first example can actually be solved by a DTM and so is within P). So, the real question is what sort of things can we do in NP that we couldn't do in P? Well, this is the root of the P=?NP millenium problem, which is a major open problem. There are certainly problems that we have found that are known to be in NP that we do not know to be in P, but perhaps future research will show that these are also in P.</p>
<p>首先，我们看到 P ？= NP 自DTM是一个NDTM，它恰好不会分支（事实上，我们的第一个例子实际上可以通过DTM解决，因此在P内）。所以，真正的问题是我们可以在NP中做什么样的事情，我们在P中无法做到？那么，这是P =？NP千年问题的根源，这是一个重大的开放问题。当然，我们发现存在一些问题，我们发现这些问题存在于NP中，而我们不知道这些问题存在于P中，但是也许未来的研究将显示这些问题也出现在P中。</p>
<p>Lots of interesting cryptographic systems (particularly in the public key setting) are secure based on the assumption that a computational problem is &quot;hard&quot;, which generally means &quot;at least as hard as any problem in NP&quot;. That is, many schemes are based on problems which we think are difficult to solve, and that if you can create an algorithm that solves them you could also use this algorithm to solve lots of other problems that we currently believe to be difficult.</p>
<p>许多有趣的密码系统（特别是在公钥设置中）基于计算问题是“硬”的假设是安全的，这通常意味着“至少与NP中的任何问题一样困难”。也就是说，许多方案都基于我们认为难以解决的问题，并且如果您可以创建一个可以解决这些问题的算法，那么您也可以使用此算法来解决许多其他我们目前认为很困难的问题。</p>
<p>The Cook-Levin theorem provides an interesting result in this direction: No problem in NP is any harder than SAT. What his means is that if I had an oracle (basically an algorithm that I can see the input/output of but none of the workings) that solved SAT, by asking it to solve cleverly constructed queries I could use it to solve any other NP problem. This made SAT the first example of an NP-complete problem. So, to show that a problem X is at least as hard as solving an NP problem (it is NP-hard), it suffices to show that if I could solve X, I could use it to solve SAT.</p>
<p>Cook-Levin定理在这个方向上提供了一个有趣的结果：在NP中没有问题比SAT更难。他的意思是，如果我有一个解决SAT问题的oracle（基本上是一种算法，我可以看到输入/输出但没有任何工作），通过要求它解决巧妙构造的查询，我可以使用它来解决任何其他NP问题。这使得SAT成为NP完全问题的第一个例子。因此，为了表明问题X至少与解决NP问题一样困难（这是NP难题），只要证明如果我能解决X，就可以用它来解决SAT。</p>
<a class="header" href="#a-hrefhttpsbristolcryptoblogspotcom20141152-things-number-6-how-can-we-interprethtml我们如何将np解释为可以在多项式时间内检验证明的一组定理a" id="a-hrefhttpsbristolcryptoblogspotcom20141152-things-number-6-how-can-we-interprethtml我们如何将np解释为可以在多项式时间内检验证明的一组定理a"><h3><a href="https://bristolcrypto.blogspot.com/2014/11/52-things-number-6-how-can-we-interpret.html">我们如何将NP解释为可以在多项式时间内检验证明的一组定理？</a></h3></a>
<pre><code>Q6 How can we interpret NP as the set of theorems whose proofs can be checked in polynomial time?
Q6 我们如何将NP解释为可以在多项式时间内检验证明的一组定理？
</code></pre>
<p>This question is very much a follow up question to the previous one. Last week Guy answered the question of 'What is meant by the complexity class NP?', while this week I will be answering the related question of 'How can we interpret NP as the set of theorems whose proofs can be checked in polynomial time?'.</p>
<p>这个问题是前一个问题的后续问题。 上个星期，Guy回答了“复杂类NP是什么意思”的问题，而本周我将回答相关问题“我们如何解释NP作为一组定理，其证明可以用多项式时间来检验？”。</p>
<p>Now to me this is a more intuitive definition of what it means for a problem to be in NP. Not only is it a more intuitive definition but it should (hopefully) also be clearer as to why this is a complexity class that is useful both for cryptography and the wider world. Now before we go into what we can use the class of problems for, the definition is as follows:</p>
<p>现在对我来说，这是一个更直观的定义，说明NP中的问题意味着什么。 它不仅是一个更直观的定义，而且它应该（希望）也更清晰，为什么这是一个对密码学和更广泛的世界都有用的复杂类。在我们进入我们可以使用的问题类之前，定义如下：</p>
<pre><code>NP is the class of languages that have polynomial time verifiers.
NP是具有多项式时间验证器的语言类。
</code></pre>
<p>OK but what does this actually mean? Basically if we have an element x and we want to know if x∈L (where L is some NP language) we have a prover P which given x outputs a witness w, this may take exponential time to find w given x. Then if we give x and w to our verifier V, V can tell if x∈L in polynomial time.</p>
<p>好的，但这实际上意味着什么？基本上，如果我们有一个元素x，并且我们想知道是否x∈L（其中L是某种NP语言），我们有一个证明者P，它给出x输出证人w，这可能需要指数时间来找到给定的x。那么，如果我们将x和w给予我们的验证者V，那么V可以在多项式时间内判断x∈L。</p>
<p>This definition seems very different from the one given last week but they are in fact equivalent. Informally they are equivalent because the witness w can just be the sequence of decisions the NDT made at each branching point to show that x∈L. For a (slightly) more formal proof of their equalence [1] is a reasonable online source (with references to textbooks).</p>
<p>这个定义与上周给出的定义非常不同，但它们实际上是等价的。非正式地，它们是等价的，因为证人w可以是NDT在每个分支点做出的决定序列，以表明x∈L。对于一个（略）更正式的等式证明[1]是一个合理的在线来源（参考教科书）。</p>
<p>So why might this be useful in cryptography? Well essentially we have a class of languages which can take exponential time to check if you do not know a witness but with a witness it can be done in polynomial time. This has the 'feel' of a lot of cryptographic algorithms - take Encryption (formalisation to follow in future weeks blogs) for example; you want it to be exponentially hard to get the message from ciphertext without the key (similar to a witness) but with the key you want it to be efficient (polynomial time) to extract the message.</p>
<p>那么为什么这可能会在密码学中有用呢？基本上，我们有一类语言可以花费指数的时间来检查你是否不知道证人，但是证人可以在多项式时间内完成。这有很多加密算法的“感觉” - 例如，采用加密技术（未来几周的博客将采用正式化）;你希望它是指数级地难以从没有密钥的密文（类似于证人）获得密文的信息，但是希望它有效的密钥（多项式时间）来提取消息。</p>
<p>A warning: While it sounds like a good move to use an NP problem for cryptography it may not be as simple as it first appears. This is because languages are in NP based on the worse case complexity where as for encryption we need it to be hard on average. For example we may have an NP language which has one element that takes exponential time to solve but all others are really efficient to solve - this will not make a good basis for an encryption scheme because we want encryption to be secure for all messages not just one.</p>
<p>警告：虽然这听起来像是一个很好的举动来使用密码学的NP问题，但它可能并不像第一次出现那样简单。这是因为语言是基于最坏情况复杂度的NP，而对于加密我们需要它平均很难。例如，我们可能有一种NP语言，其中一种元素需要指数时间来解决，但其他所有解决方案都非常有效 - 这不会为加密方案奠定良好的基础，因为我们希望加密对所有消息都是安全的，而不仅仅是一。</p>
<p>Now I am aware that integer factorization isn't known to be NP-complete and isn't known to be in P (See Ryan's blog here for a description) but it makes for a nice example of the point I am trying to make about choosing your NP instances carefully. In general finding a factor of a number is easy (half of them are divisible by two!) but if we choose something sensible we can make it hard to factor. Let us focus on numbers of the form N=p⋅q for p,q prime (a.k.a numbers with only two proper factors). Now if either of these numbers is small then it is again easy, so we want the numbers to be of equal size (this is what we do for RSA). From this it is possible to build an encryption scheme over the top.</p>
<p>现在我意识到整数因子分解并不是NP完全的，并且不知道是在P中（请参阅Ryan的博客以获取描述），但它提供了一个很好的例子，说明了我正试图提出的观点仔细选择你的NP实例。一般来说，找出一个数字的因素很容易（其中一半可以被两个整除！）但是如果我们选择一些合理的东西，我们可以使其难以分解。让我们把注意力集中在p，q素数（只有两个适当因子的a.k.a数）的形式N =p⋅q的数字上。现在，如果这些数字中的任何一个都很小，那么它很容易，所以我们希望这些数字具有相同的大小（这是我们为RSA所做的）。由此可以在顶层建立一个加密方案。</p>
<ul>
<li>[1] - http://en.wikipedia.org/wiki/NP_(complexity)#Equivalence_of_definitions</li>
</ul>
<a class="header" href="#a-hrefhttpsbristolcryptoblogspotcom20141152-things-number-7-how-does-randomnesshtml随机性对计算有什么帮助和什么是bppa" id="a-hrefhttpsbristolcryptoblogspotcom20141152-things-number-7-how-does-randomnesshtml随机性对计算有什么帮助和什么是bppa"><h3><a href="https://bristolcrypto.blogspot.com/2014/11/52-things-number-7-how-does-randomness.html">随机性对计算有什么帮助和什么是BPP？</a></h3></a>
<pre><code>Q7 How does randomness help in computation, and what is the class BPP?
Q7 随机性对计算有什么帮助，以及什么是BPP类？
</code></pre>
<p>So far, during this blog series Ryan has introduced us to complexity classes, and in particular to P:</p>
<ul>
<li>P  is the class of languages decidable in polynomial time by a deterministic Turing machine.</li>
</ul>
<p>到目前为止，在这个博客系列中，Ryan向我们介绍了复杂类，特别是P：</p>
<ul>
<li>P是确定性图灵机在多项式时间内可确定的语言类。</li>
</ul>
<p>Then, Guy introduced us to complexity class NP:</p>
<ul>
<li>NP is the class of languages decidable in polynomial time by a nondeterministic Turing machine.</li>
</ul>
<p>然后，Guy向我们介绍了复杂类NP：</p>
<ul>
<li>NP是一种非确定性图灵机在多项式时间内可确定的语言类。</li>
</ul>
<p>This week I am going to introduce the complexity class BPP:</p>
<ul>
<li>BPP is the class of languages that are recognised by a probabilistic polynomial time Turing machine with an error probability of 1/3.</li>
</ul>
<p>本周我将介绍复杂类BPP：</p>
<ul>
<li>BPP是由概率多项式时间图灵机识别的错误概率为1/3的语言类。</li>
</ul>
<a class="header" href="#probabilistic-turing-machine-概率图灵机" id="probabilistic-turing-machine-概率图灵机"><h4>Probabilistic Turing Machine 概率图灵机</h4></a>
<p>A probabilistic Turing Machine[1] is a type of nondeterministic Turing Machine which randomly chooses between the available transitions at each point according to a probability distribution. What this means is that a probabilistic Turing machine can have stochastic results. On the same input, it could have different run times, accept it on one occasion and reject it on another. It could also never stop. This Turing Machine gives rise to other complexity classes such as RP, ZPP and, the one we're discussing in this post, BPP.</p>
<p>概率图灵机[1]是一种非确定性图灵机，它根据概率分布在每个点的可用转换之间随机选择。 这意味着概率图灵机可以有随机结果。 在相同的输入上，它可能有不同的运行时间，一次接受它，另一次拒绝。 它也永远不会停止。 这个图灵机引出了其他复杂类，如RP，ZPP和我们在这篇文章中讨论的BPP。</p>
<a class="header" href="#a-little-about-the-complexity-class-bpp-关于复杂类bpp的一点点内容" id="a-little-about-the-complexity-class-bpp-关于复杂类bpp的一点点内容"><h4>A little about the complexity class BPP 关于复杂类BPP的一点点内容</h4></a>
<p>So as we have seen from the definition, the class BPP (Bounded-Error probabilistic polynomial time) contains the decision problems that are solvable in polynomial time by a probabilistic Turing machine with error probability 13. Note that this error probability can be chosen to be any value strictly between 0 and 12 due to a result named the amplification lemma which I will not discuss further here. The class BPP contains P, the class of problems solvable in polynomial time by a deterministic Turing Machine, this is due to the fact that a deterministic Turing Machine is a special case of the probabilistic Turing Machine (taking the only possible path with probability 1). As talked about in Guy's post, there is an open (Millennium) problem conjecturing as to whether P = NP. There is a similar question with BPP, being P = BPP? The number of problems known to be in BPP but not known to be in P is decreasing.</p>
<p>正如我们从定义中看到的那样，类BPP（有界误差概率多项式时间）包含可由多项式时间通过概率图灵机以13的错误概率解决的决策问题。注意，这个错误概率可以选择为 由于命名为放大引理的结果，任何值都严格限定在0到12之间，这里我将不再进一步讨论。 BPP类包含P，这是一个确定性图灵机在多项式时间可解的问题类，这是由于确定性图灵机是概率图灵机的一个特例（以概率1采用唯一可能的路径）。 正如Guy的文章所谈到的那样，对于P = NP是否存在一个开放的（千年）问题进行猜测。 BPP有一个类似的问题，即P = BPP？ 已知在BPP中但未知在P中的问题正在减少。</p>
<a class="header" href="#an-example-of-a-bpp-problem-一个bpp问题的例子" id="an-example-of-a-bpp-problem-一个bpp问题的例子"><h4>An example of a BPP Problem 一个BPP问题的例子</h4></a>
<p>One of the most famous problems known to be in BPP  but not known to be in P was determining whether a number was prime. However, recently (2002) a deterministic polynomial time algorithm was found[2] for this problem meaning that it is indeed in P. Another problem known to be in BPP and currently still not known to be in P is polynomial identity testing[3], the problem of determining whether a polynomial is identically equal to the zero polynomial.</p>
<p>已知的BPP中最着名的问题之一，但不知道在P中是确定一个数字是否为素数。 然而，最近（2002年）发现了一个确定性多项式时间算法[2]，因为这个问题意味着它确实存在于P中。另一个已知的问题是在BPP中，并且目前还不知道在P中是多项式身份测试[3] ，确定多项式是否等于零多项式的问题。</p>
<p>There are still many very important unanswered questions on the topic of Complexity Classes. Some of which, if answered, could have a large impact on shaping the future of Cryptography and Computer Science.</p>
<p>关于复杂类的主题仍然有许多非常重要的未解答的问题。 其中一些如果得到解答，可能会对塑造未来密码学和计算机科学产生巨大影响。</p>
<ul>
<li>[1] - http://en.wikipedia.org/wiki/Probabilistic_Turing_machine</li>
<li>[2] - http://en.wikipedia.org/wiki/AKS_primality_test</li>
<li>[3] - http://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma</li>
</ul>
<a class="header" href="#dht全称叫分布式哈希表distributed-hash-table" id="dht全称叫分布式哈希表distributed-hash-table"><h1>DHT全称叫分布式哈希表(Distributed Hash Table).</h1></a>
<p>Chord, Pastry还是Kademlia.  CAN（Content Addressable Network）, Tapestry.
BT采用Python的Kademlia实现叫作khashmir, eMule采用C++的Kademlia实现干脆就叫作Kad.</p>
<a class="header" href="#coral-dsht" id="coral-dsht"><h3>Coral DSHT</h3></a>
<a class="header" href="#skademlia-dht" id="skademlia-dht"><h3>S/Kademlia DHT</h3></a>
<a class="header" href="#chord-httpsenwikipediaorgwikichord_peer-to-peer" id="chord-httpsenwikipediaorgwikichord_peer-to-peer"><h3>Chord https://en.wikipedia.org/wiki/Chord_(peer-to-peer)</h3></a>
<a class="header" href="#a一致哈希--httpsenwikipediaorgwikiconsistent_hashing" id="a一致哈希--httpsenwikipediaorgwikiconsistent_hashing"><h4>一致哈希  https://en.wikipedia.org/wiki/Consistent_hashing</h4></a>
<a class="header" href="#dht" id="dht"><h2>DHT</h2></a>
<p>◇“散列算法”的选择
◇同构的“node ID”与“data key”
◇“拓扑结构”的设计
◇“路由算法”的权衡
◇距离算法
◇数据定位</p>
<a class="header" href="#dht全称叫分布式哈希表distributed-hash-table-1" id="dht全称叫分布式哈希表distributed-hash-table-1"><h1>DHT全称叫分布式哈希表(Distributed Hash Table).</h1></a>
<p>Chord, Pastry还是Kademlia.  CAN（Content Addressable Network）, Tapestry.
BT采用Python的Kademlia实现叫作khashmir, eMule采用C++的Kademlia实现干脆就叫作Kad.</p>
<a class="header" href="#coral-dsht-1" id="coral-dsht-1"><h3>Coral DSHT</h3></a>
<a class="header" href="#skademlia-dht-1" id="skademlia-dht-1"><h3>S/Kademlia DHT</h3></a>
<a class="header" href="#chord-httpsenwikipediaorgwikichord_peer-to-peer-1" id="chord-httpsenwikipediaorgwikichord_peer-to-peer-1"><h3>Chord https://en.wikipedia.org/wiki/Chord_(peer-to-peer)</h3></a>
<a class="header" href="#a一致哈希--httpsenwikipediaorgwikiconsistent_hashing-1" id="a一致哈希--httpsenwikipediaorgwikiconsistent_hashing-1"><h4>一致哈希  https://en.wikipedia.org/wiki/Consistent_hashing</h4></a>
<a class="header" href="#dht-1" id="dht-1"><h2>DHT</h2></a>
<p>◇“散列算法”的选择
◇同构的“node ID”与“data key”
◇“拓扑结构”的设计
◇“路由算法”的权衡
◇距离算法
◇数据定位</p>
<a class="header" href="#kademlia" id="kademlia"><h3>Kademlia</h3></a>
<p>https://web.archive.org/web/20051211011605/http://www.cs.rice.edu/Conferences/IPTPS02/109.pdf<br />
https://github.com/bmuller/kademlia</p>
<a class="header" href="#a拓扑结构二叉树" id="a拓扑结构二叉树"><h4>◇拓扑结构——二叉树</h4></a>
<p>在映射之前，先做一下预处理。</p>
<ol>
<li>先把 key 以二进制形式表示。</li>
<li>把每一个 key 缩短为它的【最短唯一前缀】。
然后</li>
<li>先把 key 以二进制形式表示，然后从高位到低位依次处理。</li>
<li>二进制的第 n 个数位就对应了二叉树的第 n 层</li>
<li>如果该位是1，进入左子树，是0则进入右子树（这只是人为约定，反过来处理也可以）</li>
<li>全部数位都处理完后，这个 key 就对应了二叉树上的某个【叶子】</li>
</ol>
<a class="header" href="#a距离算法异或xor" id="a距离算法异或xor"><h4>◇距离算法——异或（XOR）</h4></a>
<p>DHT算法都是采用某种逻辑上的距离，在Kademlia则采用简单的异或计算来衡量两节点间的距离，它和地理上的距离没有任何关系，但却具备几何公式的绝大特征：<br />
（1）节点和它本身之间的异或距离是0<br />
（2）异或距离是对称的：即从A到B的异或距离与从B到A的异或距离是等同的<br />
（3）异或距离符合三角形不等式：给定三个顶点A B C，假如AC之间的异或距离最大,那么AC之间的异或距离必小于或等于AB异或距离和BC异或距离之和.<br />
（4）对于给定的一个距离，距离A只存在有唯一的一个节点B，也即单向性，在查找路径上也是单向的，这个和地理距离不同。</p>
<a class="header" href="#a路由机制" id="a路由机制"><h4>◇路由机制</h4></a>
<p>对每一个节点，都可以【按照自己的视角】对整个二叉树进行拆分。<br />
　拆分的规则是：先从根节点开始，把【不包含】自己的那个子树拆分出来；然后在剩下的子树再拆分不包含自己的下一层子树；以此类推，直到最后只剩下自己。<br />
　Kad 默认的散列值空间是 m=160（散列值有 160 比特），因此拆分出来的子树【最多】有 160 个（考虑到实际的节点数【远远小于】2160，子树的个数会明显小于 160）。<br />
　对于每一个节点而言，当它以自己的视角完成子树拆分后，会得到 n 个子树；对于每个子树，如果它都能知道里面的一个节点，那么它就可以利用这 n 个节点进行递归路由，从而到达整个二叉树的【任何一个】节点</p>
<a class="header" href="#k-桶k-bucket" id="k-桶k-bucket"><h4>K-桶（K-bucket）</h4></a>
<p>前面说了，每个节点在完成子树拆分后，只需要知道每个子树里面的一个节点，就足以实现全遍历。但是考虑到健壮性（请始终牢记：分布式系统的节点是动态变化滴），光知道【一个】显然是不够滴，需要知道【多个】才比较保险。<br />
所以 Kad 论文中给出了一个“K-桶（K-bucket）”的概念。也就是说：每个节点在完成子树拆分后，要记录每个子树里面的 K 个节点。这里所说的 K 值是一个【系统级】的常量。由使用 Kad 的软件系统自己设定（比如 BT 下载使用的 Kad 网络，K 设定为 8）。<br />
K 桶其实就是【路由表】。对于某个节点而言，如果【以它自己为视角】拆分了 n 个子树，那么它就需要维护 n 个路由表，并且每个路由表的【上限】是 K。<br />
说 K 只是一个【上限】，是因为有两种情况使得 K 桶的尺寸会小于 K。<br />
1. 距离越近的子树就越小。如果整个子树【可能存在的】节点数小于 K，那么该子树的 K 桶尺寸永远也不可能达到 K。<br />
2. 有些子树虽然实际上线的节点数超过 K，但是因为种种原因，没有收集到该子树足够多的节点，这也会使得该子树的 K 桶尺寸小于 K。</p>
<a class="header" href="#k-桶k-bucket的刷新机制" id="k-桶k-bucket的刷新机制"><h4>K-桶（K-bucket）的刷新机制</h4></a>
<p>刷新机制大致有如下几种：</p>
<ol>
<li>
<p>主动收集节点<br />
　　任何节点都可以主动发起“查询节点”的请求（对应于协议类型 FIND_NODE），从而刷新 K 桶中的节点信息（下面聊“节点的加入”时，会提及这种）</p>
</li>
<li>
<p>被动收集节点<br />
　　如果收到其它节点发来的请求（协议类型 FIND_NODE 或 FIND_VALUE），会把对方的 ID 加入自己的某个 K 桶中。</p>
</li>
<li>
<p>探测失效节点<br />
　　Kad 还是支持一种探测机制（协议类型 PING），可以判断某个 ID 的节点是否在线。因此就可以定期探测路由表中的每一个节点，然后把下线的节点从路由表中干掉。<br />
　　“并发请求”与“α 参数”<br />
　　“K桶”的这个设计思路【天生支持并发】。因为【同一个】“K桶”中的每个节点都是平等的，没有哪个更特殊；而且对【同一个】“K桶”中的节点发起请求，互相之间没有影响（无耦合）。<br />
　　所以 Kad 协议还引入了一个“α 参数”，默认设置为 3，使用 Kad 的软件可以在具体使用场景中调整这个 α 因子。<br />
　　当需要路由到某个“子树”，会从该子树对应的“K桶”中挑选【α 个节点】，然后对这几个节点【同时】发出请求。</p>
</li>
</ol>
<a class="header" href="#a节点的加入" id="a节点的加入"><h4>◇节点的加入</h4></a>
<ol>
<li>任何一个新来的节点（假设叫 A），需要先跟 DHT 中已有的任一节点（假设叫 B）建立连接。</li>
<li>A 随机生成一个散列值作为自己的 ID（对于足够大的散列值空间，ID 相同的概率忽略不计）</li>
<li>A 向 B 发起一个查询请求（协议类型 FIND_NODE），请求的 ID 是自己（通俗地说，就是查询自己）</li>
<li>B 收到该请求之后，（如前面所说）会先把 A 的 ID 加入自己的某个 K 桶中。然后，根据 FIND_NODE 协议的约定，B 会找到【K个】最接近 A 的节点，并返回给 A。（B 怎么知道哪些节点接近 A 捏？这时候，【用 XOR 表示距离】的算法就发挥作用啦）</li>
<li>A 收到这 K 个节点的 ID 之后，（仅仅根据这批 ID 的值）就可以开始初始化自己的 K 桶。</li>
<li>然后 A 会继续向刚刚拿到的这批节点发送查询请求（协议类型 FIND_NODE），如此往复（递归），直至 A 建立了足够详细的路由表。</li>
</ol>
<a class="header" href="#a节点的退出" id="a节点的退出"><h4>◇节点的退出</h4></a>
<p>　　与 Chord 不同，Kad 对于节点退出没有额外的要求（没有“主动退出”的说法）。<br />
　　所以，Kad 的节点想离开 DHT 网络不需要任何操作（套用徐志摩的名言：悄悄的我走了，正如我悄悄的来）</p>
<a class="header" href="#a保存数据" id="a保存数据"><h3>保存数据</h3></a>
<p>（以下只是大致原理，具体的协议实现可能会有差异）</p>
<ol>
<li>当某个节点得到了新加入的数据（K/V），它会先计算自己与新数据的 key 之间的“距离”；然后再计算它所知道的其它节点与这个 key 的距离。</li>
<li>如果计算下来，自己与 key 的距离最小，那么这个数据就保持在自己这里。</li>
<li>否则的话，把这个数据转发给距离最小的节点。</li>
<li>收到数据的另一个节点，也采用上述过程进行处理（递归处理）。</li>
</ol>
<a class="header" href="#a获取数据" id="a获取数据"><h3>获取数据</h3></a>
<p>（以下只是大致原理，具体的协议实现可能会有差异）</p>
<ol>
<li>当某个节点接收到查询数据的请求（key），它会先计算自己与 key 之间的“距离”；然后再计算它所知道的其它节点与这个 key 的距离。</li>
<li>如果计算下来，自己与 key 的距离最小，那么就在自己这里找有没有 key 对应的 value。有的话就返回 value，没有的话就报错。</li>
<li>否则的话，把这个数据转发给距离最小的节点。</li>
<li>收到数据的另一个节点，也采用上述过程进行处理（递归处理）。</li>
</ol>
<p><a href="https://ieeexplore.ieee.org/document/4447808/">原始论文</a></p>
<a class="header" href="#a针对kademlia攻击" id="a针对kademlia攻击"><h4>针对Kademlia攻击</h4></a>
<ul>
<li>在下层网络的攻击，包括IP/TCP攻击形式，监听，窃取，伪造数据包</li>
<li>在覆盖网络上的攻击
<ul>
<li>Elicpse Attack 日蚀攻击 —— 防护要求：1. 不能免费生成ID，必须付出代价；2. 不能随意更改别人的路由表</li>
<li>Sybil Attack 女巫攻击 —— 防护要求：1. 无法完全杜绝，只能减弱；2. 付出代价生成ID</li>
<li>Churn Attack 搅动攻击 反复生成或者调整自己的ID —— 防护要求：1. 优先考虑长时间在先的节点</li>
<li>Adversarial Routing 对抗路由 —— 防护要求：1. 设计多条路径选择和长度优化算法</li>
</ul>
</li>
<li>其他的攻击
<ul>
<li>Denial-of-Service (DoS)</li>
<li>Attacks on data storage</li>
</ul>
</li>
</ul>
<a class="header" href="#a设计" id="a设计"><h4>设计</h4></a>
<a class="header" href="#a1-安全的生成id" id="a1-安全的生成id"><h5>1. 安全的生成ID</h5></a>
<ol>
<li>
<p>Hash函数主体</p>
<ul>
<li>针对硬件的信息(IP, PORT)</li>
<li>针对公钥(Public Key) —— 优先选择</li>
</ul>
</li>
<li>
<p>签名强度</p>
<ul>
<li>Weak Sign 只对IP地址等信息进行签名</li>
<li>Strong Sign 对整个消息体进行签名</li>
</ul>
</li>
<li>
<p>签名可信</p>
<ul>
<li>CA 第三方可信机构的签名 —— 联盟链形式可行</li>
<li>Crypto puzzle sign 解决密码学难题 (PoW) —— 公链形式可行</li>
</ul>
</li>
</ol>
<a class="header" href="#a2-构建稳固安全的sibling信息" id="a2-构建稳固安全的sibling信息"><h5>2. 构建稳固安全的sibling信息</h5></a>
<ul>
<li><strong>sibling</strong>:可靠存储着DHT中的确定的K-V信息的那些节点</li>
<li>因此，在S/Kademlia中，路由表由包含距离为d且具有 2^(i-1) ≤ d &lt; 2^i, 0 ≤ i ≤ n 的节点的n个k桶的列表组成。大小η·s。由于新引入的同级列表，特殊子树处理可以省略。由于Kademlia中的路由表通过传入的查找请求隐式刷新，并且我们sibling表中的许多节点必须存储在Kademlia的k-桶中，因此维护sibling表的额外通信开销很小。</li>
</ul>
<a class="header" href="#a3-安全维护路由表" id="a3-安全维护路由表"><h5>3. 安全维护路由表</h5></a>
<p>Kademlia使用被动方法来维护路由表。由于异或度量确保所有迭代查找沿着相同的路径收敛，Kademlia可以从传入的RPC中了解新节点的存在。为了保护S/Kademlia中的路由表维护，我们将信令消息分类到以下类：传入签名的RPC请求，响应或未签名的消息。每条消息都包含发件人地址。如果消息是弱签名或强签名，则该地址不能伪造或与另一个nodeId相关联。如果发件人地址有效并且来自RPC响应，我们称该发件人地址有效，如果该邮件已签名并且主动有效。 Kademlia使用这些发件人地址来维护他们的路由表。</p>
<p>当活动有效的发件人地址未满时，会立即将其添加到相应的存储区中。如果nodeId前缀在适当的位数χ中不同（例如，x&gt; 32），则有效的发件人地址只能添加到存储桶中。这是必要的，因为攻击者可以很容易地生成与受害者nodeId共享前缀并溢出他的桶的nodeId，因为靠近自己的nodeId的桶只在Kademlia中稀疏填充。来自未签名消息的发件人地址将被忽略。如果消息包含有关其他节点的更多信息，则可以通过调用它们上的ping RPC来添加每个节点。如果一个节点已经存在于路由表中，它将在桶的尾部移动。</p>
<a class="header" href="#a4-通过不相交的路径进行查找" id="a4-通过不相交的路径进行查找"><h5>4. 通过不相交的路径进行查找</h5></a>
<p>我们已经展示了使用多条不相交路径来查找具有对抗节点的网络中的密钥的重要性。原始的Kademlia查找通过FIND_NODE RPC迭代查询α节点，以找到与目标密钥最近的k个节点。α是系统范围的冗余参数，在每个步骤中，将来自先前RPC的返回节点合并到排序列表中，从中选择下一个α节点。这种方法的一个主要缺点是，只要查询单个敌对节点，查找就会失败。</p>
<p>我们将此算法扩展为使用d不相交路径，从而提高了具有对抗节点的网络中的查找成功率。发起者通过从其本地路由表中取出距离目的密钥的k个最近节点并将其分布到d个独立的查找桶中来开始查找。从那里继续进行类似于传统Kademlia查找的d个并行查找。查找是独立的，除了一个重要的事实，即每个节点在整个查找过程中仅使用一次，以确保生成的路径真正不相交。通过使用同级列表，查找不会收敛于单个节点，而是终止于邻近邻居，这些邻居都知道目标密钥的完整同胞。因此，即使邻居的k-1是敌对的，查找仍然是成功的。</p>
<a class="header" href="#a评估" id="a评估"><h4>评估</h4></a>
<p>在本节中，我们用<a href="http://netsec.cs.uoregon.edu/gi2007/papers/1569026972.pdf">OverSim</a>评估S/Kademlia，这是一个用于覆盖模拟的灵活框架。我们描述了仿真设置和程序，并最终描述了我们的仿真结果。</p>
<a class="header" href="#simulation-assumptions-模拟假设" id="simulation-assumptions-模拟假设"><h5>Simulation assumptions 模拟假设</h5></a>
<p>We simulate adversarial nodes with the following assumptions: An adversarial node returns data that compromises the network in a worst case scenario. So in the case of a FIND_NODE RPC the worst behaviour would only return other collaborating nodes which are closer to the target nodeId. The adversarial also harvest other existing valid nodeIds in order to map them to a false transport addresses. This is the worst case since other reactions like an empty result or invalid data can be detected and the node would be removed from the network, i.e. the node would be considered as a stale contact.</p>
<p>On the other hand we assume that well behaving nodes return adversarial node information in an equally distributed manner. This assumption is confirmed in section 4 because it is nearly impossible for an adversarial node to influence other nodes’ routing tables.</p>
<p>With these assumptions we expect that a lookup of a node or siblings is successful if no adversarial node is on one path to the responsible node. In the case of a parallel lookup on multiple paths we simply stop pursuing each path that hit an adversarial node and the lookup is only considered successful, if one path is free of any adversarial nodes.</p>
<p>我们用以下假设模拟敌对节点：敌对节点在最坏情况下返回损害网络的数据。因此，在FIND_NODE RPC的情况下，最差的行为只会返回更接近目标nodeId的其他协作节点。对手还会收获其他现有的有效nodeIds，以便将它们映射到虚假的传输地址。这是最坏的情况，因为可以检测到诸如空结果或无效数据之类的其他反应，并且将该节点从网络中移除，即该节点将被视为陈旧联系人。另一方面，我们假设良好行为的节点以平均分布的方式返回对抗节点信息。这个假设在第4节中得到证实，因为敌对节点几乎不可能影响其他节点的路由表。通过这些假设，我们预计如果没有对抗节点位于负责节点的一条路径上，则节点或兄弟节点的查找是成功的。在多条路径上进行并行查找的情况下，我们只需停止追踪遇到敌对节点的每条路径，并且只有一条路径没有任何敌对节点时，才会将查找视为成功。</p>
<a class="header" href="#simulation-procedure-模拟过程" id="simulation-procedure-模拟过程"><h5>Simulation procedure 模拟过程</h5></a>
<p>To keep the simulation efficient we first create a static Kademlia overlay network with N nodes that is fully stabilized. Then we continue by processing N node lookups and evaluate the fraction of successful queries. This process is repeated with increasing adversarial nodes by 5% until 90% of the nodes are adversarial. Since we do not evaluate churn all simulations are done with a parameter of α = 1 and we assume that the network stays in a stable state after the bootstrapping phase, but under the influence of adversarial nodes.</p>
<p>为了保持仿真效率，我们首先创建一个静态Kademlia覆盖网络，其中包含N个完全稳定的节点。 然后我们继续处理N个节点查找并评估成功查询的比例。 随着对抗节点增加5％重复该过程，直到90％的节点是对抗的。 由于我们不评估流失，所有仿真都是在α= 1的参数下完成的，并且我们假定网络在引导阶段后保持稳定状态，但是在对抗节点的影响下。</p>
<a class="header" href="#results" id="results"><h5>Results</h5></a>
<p>We simulated two setups with a network size of N = 10000 nodes, s = 16 siblings using d ∈{1, 2, 4, 8} disjoint paths. In Figure 4 we show the fraction of success- ful lookups dependant on the number of adversarial nodes for a fixed bucket size of k = 16. For d = 1 the lookup process is similar to a standard Kademlia lookup. The figure clearly shows that by increasing the number of parallel disjoint paths d the fraction of successful lookups can be considerably improved. In this case the communication overhead increases linearly with d. We also see that with k = 16 there is enough redundancy in the k-buckets to actually create d disjoint paths.</p>
<p>我们使用d∈{1，2，4，8}不相交的路径模拟了网络规模为N = 10000个节点，s = 16个兄弟的两个设置。在图4中，我们展示了对于k = 16的固定桶大小，取决于敌对节点数量的成功查找的比例。对于d = 1，查找过程类似于标准的Kademlia查找。该图清楚地表明，通过增加并行不相交路径的数量d，成功查找的比例可以大大提高。在这种情况下，通信开销随着d线性增加。我们还可以看到，当k = 16时，k桶中有足够的冗余来实际创建不相交的路径。</p>
<p>In the second setup we adapted k = 2·d to the number of disjoint paths to keep a minimum of redundancy in the routing tables and consequently reduce communication overhead. The results in figure 5 show, that a smaller k leads to a smaller fraction of successful lookups compared to figure 4. The reason for this is the increased average path length due to the smaller routing table as shown in the path length distribution diagram.</p>
<p>在第二种设置中，我们将k = 2·d调整为不相交路径的数量，以保持路由表中的最小冗余度，并因此减少通信开销。图5中的结果显示，与图4相比，较小的k导致成功查找的一小部分。其原因是由于路径表中较小的路由表增加了平均路径长度，如路径长度分布图中所示。</p>
<p>We conclude that d = 4..8 with a k = 8..16 is a good choice for S/Kademlia. Higher values of d and k seem not worth the additional communication costs. Larger values for k would also increase the probability that a large fraction of buckets are not full for a long time. This unnecessarily makes the routing table more vulnerable to Eclipse attacks.</p>
<p>我们得出结论，d = 4..8，k = 8..16对S / Kademlia来说是个不错的选择。较高的d和k值似乎不值得额外的通信成本。较大的k值也会增加很大一部分桶长时间不满的概率。这不必要地使路由表更容易受到Eclipse攻击。</p>
<p>Since we present simulations with N = 10000 nodes only, one might argue that this is a rather small number of nodes and not comparable to huge networks. In fact the path length highly corelates with the fraction of successful lookups. On the other hand the network topology can be easily tuned to have a smaller diameter and therefore a shorter average path length. This is usually done by considering multiple bits b of the nodeId in each step. So the network can be tuned to the level of security needed in different scenarios.</p>
<p>由于我们仅提供了N = 10000个节点的模拟，有人可能会认为这是一个相当少的节点，并不能与大型网络相媲美。事实上，路径长度与成功查找的比例高度相关。另一方面，网络拓扑结构可以很容易地调整为具有较小的直径，因此较短的平均路径长度。这通常通过在每个步骤中考虑nodeId的多个位b来完成。因此，可以将网络调整到不同情况下所需的安全级别。</p>
<a class="header" href="#a相关工作" id="a相关工作"><h4>相关工作</h4></a>
<p>Castro et al. study attacks on routing of messages in structured peer-to-peer overlays. They propose several defenses to secure the join process, routing table maintenance and message forwarding. The secure assignment of nodeIds is delegated to a central trusted certification authority.</p>
<p>卡斯特罗等人。研究对结构化对等覆盖中的消息路由的攻击。他们提出了一些防御措施来确保加入过程，路由表维护和消息转发。将nodeIds的安全分配委托给中央信任的证书颁发机构。</p>
<p>Sit and Morris [16] present a categorization of attacks against peer-to-peer distributed hash tables on the basis of Chord, CAN and Pastry. They state that an important step to defend these attacks is detection by defining verifiable system invariants. For example nodes can detect incorrect lookup routing by verifying that the lookup gets “closer” to the destination key.</p>
<p>Sit和Morris [16]在Chord，CAN和Pastry的基础上提出了针对点对点分布式哈希表的攻击分类。他们表示，防御这些攻击的重要步骤是通过定义可验证的系统不变量进行检测。例如，节点可以通过验证查找是否“接近”目标密钥来检测不正确的查找路由。</p>
<p>Srivatsa and Liu [17] investigate three security threats in DHT-based P2P systems. First they present an attack on the routing scheme, in which a single adversarial node can block all lookup requests in the absence of alternate paths. Therefore they highlight the importance of several alternate optimal paths in conjunction with the feasibility to detect incorrect lookup results. Furthermore they present an attack on the data placement scheme and show that replication alone is not sufficient to tolerate attacks by adversarial nodes, but has to be combined with cryptographic techniques to be effective. Finally they show that the nodeId selection process has to be restricted to prevent adversarial nodes from corrupting specific data items.</p>
<p>Srivatsa和Liu [17]研究了基于DHT的P2P系统中的三种安全威胁。首先，他们对路由方案提出攻击，其中单个敌对节点可以在没有备用路径的情况下阻止所有查找请求。因此，他们强调了几种备选最佳路径的重要性，以及检测不正确查找结果的可行性。此外，他们对数据放置方案提出了攻击，并表明单靠复制不足以容忍敌对节点的攻击，但必须与密码技术相结合才能有效。最后，他们显示必须限制nodeId选择过程，以防止敌对节点破坏特定的数据项。</p>
<p>Awerbuch and Scheideler [1] present a theoretical DHT which is provably robust against adversarial join-leave as well as insert-lookup attacks. The design of the DHT is high level and it is an open question how hard it would be to transform their ideas into a practicable protocol. Another DHT which can provably deal with join-leave attacks is S-Chord, though it is limited to a linear number of adversarial join requests.</p>
<p>Awerbuch和Scheideler [1]提出了一种理论上的DHT，它可以抵抗对抗式加入假以及插入式查找攻击。 DHT的设计是高层次的，它是一个开放的问题，将它们的想法转化为可行的协议是多么困难。另一个可以处理加入 - 离开攻击的DHT是S-Chord，尽管它仅限于线性数量的对抗加入请求。</p>
<p>Cerri et al. focus on attacks that arise from the unlimited choice of nodeIds and exemplify their findings with the Kademlia protocol. They propose to limit free nodeId selection by coupling IP address and port to the nodeId by a hash function. To make it harder for adversarial nodes to attack specific data items, they propose that data items should be stored at a temporary key, which is regularly rotated. This is done by hashing the data item’s key with some temporal information to compute the temporary key.</p>
<p>Cerri等人重点关注无限选择nodeIds引起的攻击，并用Kademlia协议举例说明他们的发现。他们建议通过散列函数将IP地址和端口耦合到nodeId来限制空闲的nodeId选择。为了使敌对节点难以攻击特定的数据项，他们建议将数据项存储在一个临时密钥中，该密钥会定期轮换。这是通过用一些时间信息对数据项的密钥进行散列来计算临时密钥来完成的。</p>
<p>There are several papers in which countermeasures against Sybil attacks are proposed: In Rowaihy et al. present an admission control system for structured peer-to-peer systems. The systems constructs a tree-like hierarchy of cooperative admission control nodes, from which a joining node has to gain admission. Another approach to limit Sybil attacks is to store the IP addresses of participating nodes in a secure DHT. In this way the number of nodeIds per IP address can be limited by querying the DHT if a new node wants to join.</p>
<p>有几篇文章提出了针对Sybil攻击的对策：在Rowaihy et al。为结构化的点对点系统提供一个准入控制系统。这些系统构建了协作接纳控制节点的树状分层结构，从中加入节点必须获得接纳。限制Sybil攻击的另一种方法是将参与节点的IP地址存储在安全的DHT中。通过这种方式，每个IP地址的nodeIds数量可以通过查询DHT来限制，如果新节点想要加入。</p>
<p>Singh et al. [15] study the impacts of Eclipse attacks on structured overlay networks and propose to defend against this attack by letting nodes audit each others connectivity. The idea is, that a node mounting an Eclipse attack has a node degree higher than average.</p>
<p>Singh等人[15]研究Eclipse攻击对结构化覆盖网络的影响，并提出通过让节点互相审计连接来抵御这种攻击。这个想法是，一个挂载Eclipse攻击的节点的节点度高于平均值。</p>
<p>Nielson et al. regard the class of rational attacks. They assume that a large fraction of nodes in a peer-to-peer system are selfish and try to maximize their consumption of system ressources while minimizing the use of their own.</p>
<p>Nielson等人视为理性的攻击类。他们认为对等系统中很大一部分节点是自私的，并试图最大限度地消耗系统资源，同时尽量减少自己的使用。</p>
<a class="header" href="#a结论" id="a结论"><h4>结论</h4></a>
<p>In this paper we presented a secure key-based routing protocol based on Kademlia. Although the elegant routing table maintenance makes Kademlia already insusceptible to some attacks, we have shown that there are several vulnerability that make it easy for adversarial nodes to gain control of the network.</p>
<p>在本文中，我们提出了一个基于Kademlia的基于安全密钥的路由协议。尽管优雅的路由表维护使得Kademlia已经不易受到某些攻击，但我们已经表明，存在多个易受攻击节点控制网络的漏洞。</p>
<p>We propose several practicable solutions to make Kademlia more resilient.  First we suggest to limit free nodeId generation by using crypto puzzles in combination with public key cryptography. Furthermore we extend the Kademlia routing table by a sibling list. This reduces the complexity of the bucket splitting algorithm and allows a DHT to store data in a safe replicated way. Finally we propose a lookup algorithm which uses multiple disjoint paths to increase the lookup success ratio.</p>
<p>我们提出几个切实可行的解决方案，使Kademlia更具弹性。首先，我们建议通过结合公钥密码术使用加密谜题来限制免费的nodeId生成。此外，我们通过兄弟列表扩展Kademlia路由表。这降低了桶分裂算法的复杂性，并允许DHT以安全复制的方式存储数据。最后，我们提出了一种查找算法，该算法使用多条不相交路径来提高查找成功率。</p>
<p>The evaluation of S/Kademlia in the simulation framework OverSim has shown, that even with 20% of adversarial nodes still 99% of all lookups are successful if disjoint paths are used. We believe that the proposed extensions to the Kademlia protocol are practical and could be used to easily secure existing Kademlia networks.</p>
<p>在模拟框架OverSim中对S / Kademlia的评估表明，如果使用不相交的路径，即使有20％的敌对节点仍然有99％的所有查找都是成功的。我们相信，对Kademlia协议的建议扩展是实用的，可以用来轻松保护现有的Kademlia网络。</p>
<a class="header" href="#nat---network-address-translators-网络地址转换" id="nat---network-address-translators-网络地址转换"><h3>NAT - Network Address Translators (网络地址转换)</h3></a>
<p>原因：局域网的设备要想访问国际互联网，必须有国际IP（全球固定IP），所以设备需要先链接到有国际IP的设备，才能通过国际IP访问全球资源。</p>
<a class="header" href="#a命名" id="a命名"><h5>命名</h5></a>
<ul>
<li>本地设备 A(IPa, PORTa), 例如 192.168.0.2:5000</li>
<li>NAT服务（路由器/ISP设备） R(IPr, PORTr)，例如 33.23.12.32:60000</li>
<li>远程单一公共服务器 S(IPs, PORTs)，例如 8.8.8.8:80</li>
<li>远程STUN辅助探测服务器 T1(IPt1, PORTt1),T2（IPt2, PORTt2） 例如 123.123.123.1:8080, 123.123.123.2:8080</li>
</ul>
<a class="header" href="#nat-种类" id="nat-种类"><h5>NAT 种类</h5></a>
<ul>
<li>Cone 同一个设备的相同端口发送的被分配到同一个国际IP和端口
<ul>
<li>Full cone -&gt; 来者不拒</li>
<li>Restricted cone -&gt; 必须先向对方发送，对方才能发送</li>
<li>Port restricted cone -&gt; 端口也必须一致</li>
</ul>
</li>
<li>Symmertric 同一个设备每次发送都重新分配另一个国际IP和端口</li>
</ul>
<a class="header" href="#a第一种方式-直连式---单ip服务器" id="a第一种方式-直连式---单ip服务器"><h4>第一种方式 直连式 - 单IP服务器</h4></a>
<ol>
<li>中央服务器记录下设备A访问的时候的 国际IP和端口，记录下设备B的 国际IP和端口</li>
<li>S 命令 B 向 A 的国际IP打洞, 这样负责B的NAT上就有了洞口，A再通过B的NAT洞口访问B，成功后，A与B就可以相互发送</li>
</ol>
<a class="header" href="#a第二种方式-stun---2个ip服务器" id="a第二种方式-stun---2个ip服务器"><h4>第二种方式 STUN - 2个IP服务器</h4></a>
<ol>
<li>需要有一个公开的STUM服务器（两个IP，T1, T2）</li>
<li>设备A -&gt; NAT -&gt; T1</li>
<li>T1(将收到的NAT信息包装起来) -&gt; NAT -&gt; A 保证NAT设备正常和鉴定自己是不是有公网的IP地址</li>
<li>T1 收到 T1的信息后，从T2发送一个包给设备A，如果能收到 说明 NAT 是一个Full cone.</li>
<li>如果收不到，B 再次发送 -&gt; NAT -&gt; T2, T2(将收到的NAT信息包装起来) -&gt; NAT -&gt; A</li>
<li>比较T2传输过来的NAT信息和T1传输过来的NAT信息对比</li>
<li>如果一致，NAT则是Cone类型，否则无法使用P2P通信了已经</li>
<li>判断是 Restricted 还是 Port Cone。设备A -&gt; NAT -&gt; T1, T1改变端口，返回数据包, 如果成功，则是Restricted, 否则是Port Cone</li>
</ol>
<a class="header" href="#cache-replacement-policies-缓存置换机制" id="cache-replacement-policies-缓存置换机制"><h3>cache replacement policies 缓存置换机制</h3></a>
<p>cache algorithms (also frequently called cache replacement algorithms or cache replacement policies)</p>
<p><strong>常见方法有：</strong></p>
<ol>
<li>先进先出算法（FIFO）：最先进入的内容作为替换对象</li>
<li>最近最少使用算法（LFU）：最近最少使用的内容作为替换对象</li>
<li>最久未使用算法（LRU）：最久没有访问的内容作为替换对象</li>
<li>非最近使用算法（NMRU）：在最近没有使用的内容中随机选择一个作为替换对象</li>
<li>Belady's Min</li>
</ol>
<p><strong>各种算法</strong></p>
<ol>
<li>Bélády's algorithm</li>
<li>First in first out (FIFO)</li>
<li>Last in first out (LIFO)</li>
<li>Least recently used (LRU)</li>
<li>Time aware least recently used (TLRU)</li>
<li>Most recently used (MRU)</li>
<li>Pseudo-LRU (PLRU)</li>
<li>Random replacement (RR)</li>
<li>Segmented LRU (SLRU)</li>
<li>Least-frequently used (LFU)</li>
<li>Least frequent recently used (LFRU)</li>
<li>LFU with dynamic aging (LFUDA)</li>
<li>Low inter-reference recency set (LIRS)</li>
<li>Adaptive replacement cache (ARC)</li>
<li>Clock with adaptive replacement (CAR)</li>
<li>Multi queue (MQ)</li>
<li>Pannier: Container-based caching algorithm for compound objects</li>
</ol>
<a class="header" href="#cache-replacement-policies-缓存置换机制-1" id="cache-replacement-policies-缓存置换机制-1"><h3>cache replacement policies 缓存置换机制</h3></a>
<p>cache algorithms (also frequently called cache replacement algorithms or cache replacement policies)</p>
<p><strong>常见方法有：</strong></p>
<ol>
<li>先进先出算法（FIFO）：最先进入的内容作为替换对象</li>
<li>最近最少使用算法（LFU）：最近最少使用的内容作为替换对象</li>
<li>最久未使用算法（LRU）：最久没有访问的内容作为替换对象</li>
<li>非最近使用算法（NMRU）：在最近没有使用的内容中随机选择一个作为替换对象</li>
<li>Belady's Min</li>
</ol>
<p><strong>各种算法</strong></p>
<ol>
<li>Bélády's algorithm</li>
<li>First in first out (FIFO)</li>
<li>Last in first out (LIFO)</li>
<li>Least recently used (LRU)</li>
<li>Time aware least recently used (TLRU)</li>
<li>Most recently used (MRU)</li>
<li>Pseudo-LRU (PLRU)</li>
<li>Random replacement (RR)</li>
<li>Segmented LRU (SLRU)</li>
<li>Least-frequently used (LFU)</li>
<li>Least frequent recently used (LFRU)</li>
<li>LFU with dynamic aging (LFUDA)</li>
<li>Low inter-reference recency set (LIRS)</li>
<li>Adaptive replacement cache (ARC)</li>
<li>Clock with adaptive replacement (CAR)</li>
<li>Multi queue (MQ)</li>
<li>Pannier: Container-based caching algorithm for compound objects</li>
</ol>
<a class="header" href="#write-ahead-logging-预写式日志" id="write-ahead-logging-预写式日志"><h3>Write-Ahead Logging 预写式日志</h3></a>
<p><a href="https://en.wikipedia.org/wiki/Write-ahead_logging">wiki</a></p>
<p>在计算机科学中，预写式日志（Write-ahead logging，縮寫 WAL）是数据库系统中用于提供原子性和持久性（ACID属性中的两个）的一系列技术。在使用WAL的系统中，所有的修改在提交之前都要先写入log文件中。</p>
<p>log文件中通常包括redo和undo信息。这样做的目的可以通过一个例子来说明。假设一个程序在执行某些操作的过程中机器掉电了。在重新启动时，程序可能需要知道当时执行的操作是成功了还是部分成功或者是失败了。如果使用了WAL，程序就可以检查log文件，并对突然掉电时计划执行的操作内容跟实际上执行的操作内容进行比较。在这个比较的基础上，程序就可以决定是撤销已做的操作还是继续完成已做的操作，或者是保持原样。</p>
<p>WAL允许用in-place方式更新数据库。另一种用来实现原子更新的方法是shadow paging，它并不是in-place方式。用in-place方式做更新的主要优点是减少索引和块列表的修改。</p>
<p>ARIES是WAL系列技术常用的算法。</p>
<p>在文件系统中，WAL通常称为journaling。</p>
<p>PostgreSQL也是用WAL来提供point-in-time恢复和数据库复制特性。</p>
<a class="header" href="#hdd-与-ssd-不同存储介质的单片存储大小" id="hdd-与-ssd-不同存储介质的单片存储大小"><h3>HDD 与 SSD 不同存储介质的单片存储大小</h3></a>
<a class="header" href="#l0-l1-target-file-size" id="l0-l1-target-file-size"><h5>L0-L1 target file size</h5></a>
<ul>
<li>HDD: 192 * 1024 * 1024 = 192M</li>
<li>SSD: 32 * 1024 * 1024 = 32M</li>
</ul>
<a class="header" href="#l2-ln-target-file-size-multiplier" id="l2-ln-target-file-size-multiplier"><h5>L2-LN target file size multiplier</h5></a>
<ul>
<li>HDD: 1</li>
<li>SSD: 2</li>
</ul>
<a class="header" href="#rate-limiter-for-background-flushes-and-compactions-bytessec-if-any" id="rate-limiter-for-background-flushes-and-compactions-bytessec-if-any"><h5>rate limiter for background flushes and compactions, bytes/sec, if any</h5></a>
<ul>
<li>HDD: 8 * 1024 * 1024 = 8M</li>
<li>SSD: None</li>
</ul>
<a class="header" href="#overlay-database" id="overlay-database"><h3>Overlay Database</h3></a>
<p>将信息以文件的形式存储，并以一定的数据结构组织，通过在上面封装一层类数据库的程序，像数据库一样提供用户使用的接口。</p>
<ul>
<li>第一层：User interface 用户接口</li>
<li>第二层：Database interface to files 对文件的数据库接口</li>
<li>第三层：Existing hierarchical filesystem 现有的分层文件系统</li>
<li>第四层：Storage media 存储媒介</li>
</ul>
<p>两个著名的实现:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/WinFS">WinFS</a>: 以NTFS作为底层文件存储系统</li>
<li><a href="http://dbfs.sourceforge.net/">DBFS</a>： 开源的实现</li>
</ul>
<p><img src="../static/dbfs-overview.png" alt="DBFS Overview" /></p>
<a class="header" href="#a区块链底层技术入门指北----持续更新" id="a区块链底层技术入门指北----持续更新"><h3>区块链底层技术入门指北 -- 持续更新</h3></a>
<p>区块链开发分为上层应用层开发和底层基础开发。</p>
<p>上层应用层开发主要集中在智能合约编写和RPC接口调用。</p>
<ul>
<li>智能合约（DAPP）
<ul>
<li>主要关于运用<a href="http://solidity.readthedocs.io/en/latest/index.html">Solidity Language</a>的以太坊生态系统</li>
<li>主要采取WASM的虚拟机生态系统，包括EOS等</li>
</ul>
</li>
<li>RPC接口调用 （钱包，区块浏览器）
<ul>
<li>传统后端技能</li>
<li>区块链节点部署能力</li>
</ul>
</li>
<li>FORK型区块链
<ul>
<li>编程语言</li>
<li>学会更改基本的创世区块或者辨识标识</li>
<li>学会更改P2P系统的相关配置</li>
</ul>
</li>
<li>区块链行业应用开发
<ul>
<li>智能合约开发</li>
<li>区块链框架的使用搭配和简单的配置</li>
</ul>
</li>
</ul>
<p>区块链底层基础开发主要分为四大模块：</p>
<ul>
<li>身份体系模块（密码学相关）</li>
<li>网络模块(P2P, RPC交互)</li>
<li>存储模块(高性能全量存储，去中心化存储)</li>
<li>共识模块（交易结构和共识算法）</li>
</ul>
<a class="header" href="#a前期预备学习资料" id="a前期预备学习资料"><h4>前期预备学习资料</h4></a>
<a class="header" href="#a比特币系列" id="a比特币系列"><h5>比特币系列</h5></a>
<ol>
<li>白皮书: <a href="https://bitcoin.org/bitcoin.pdf">原文</a>, <a href="http://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system">中文</a></li>
<li><a href="https://github.com/bitcoin/bitcoin">源码地址</a></li>
<li>Mastering Bitcoin书籍: <a href="https://github.com/bitcoinbook/bitcoinbook">原文第二版-好</a>, <a href="http://book.8btc.com/books/6/masterbitcoin2cn/_book/">中文</a></li>
<li><a href="https://bitcointalk.org/">社区讨论</a></li>
</ol>
<a class="header" href="#a以太坊系列" id="a以太坊系列"><h5>以太坊系列</h5></a>
<ol>
<li><a href="https://github.com/ethereum/wiki/wiki">Ethereum Wiki (whitepaper, yellowpaper)</a></li>
<li><a href="https://github.com/trufflesuite/truffle">Develop Framework</a></li>
<li><a href="https://consensys.github.io/smart-contract-best-practices/">Best Practices</a></li>
<li><a href="https://github.com/ConsenSys/smart-contract-best-practices/blob/master/README-zh.md">中文</a></li>
<li><a href="https://github.com/Scanate/EthList">Resource Awesome</a></li>
</ol>
<a class="header" href="#a后期强化底层知识" id="a后期强化底层知识"><h4>后期强化底层知识</h4></a>
<a class="header" href="#a共识算法系列" id="a共识算法系列"><h5>共识算法系列</h5></a>
<ol>
<li>BFT-拜占庭容错协议</li>
<li>PoW-工作量证明</li>
<li>PoS(DPoS)-权益证明</li>
<li>密码学相关-零知识证明</li>
<li>List结构</li>
<li>Tree结构</li>
<li>DAG结构</li>
</ol>
<a class="header" href="#p2p系列" id="p2p系列"><h5>P2P系列</h5></a>
<ol>
<li>DHT</li>
<li>UDP or TCP</li>
<li>异步网络通信</li>
<li>网络模型</li>
<li>RPC接口实现</li>
</ol>
<a class="header" href="#a存储系列" id="a存储系列"><h5>存储系列</h5></a>
<ol>
<li>K-V存储结构</li>
<li>内存型存储</li>
<li>缓存型存储</li>
<li>硬盘型存储</li>
<li>去中心化存储</li>
</ol>
<a class="header" href="#a密码学系统" id="a密码学系统"><h5>密码学系统</h5></a>
<ol>
<li>对称加密</li>
<li>非对称加密</li>
<li>同态加密</li>
</ol>
<a class="header" href="#a分布式系统-1" id="a分布式系统-1"><h5>分布式系统</h5></a>
<ol>
<li>著名理论
<ul>
<li>CAP</li>
<li>FLP</li>
</ul>
</li>
<li>同步时钟与非同步时钟</li>
<li>CRDT账户模型</li>
</ol>
<a class="header" href="#a真实项目源码参考" id="a真实项目源码参考"><h4>真实项目源码参考</h4></a>
<a class="header" href="#a标准代码组织结构-主要rust实现" id="a标准代码组织结构-主要rust实现"><h4>标准代码组织结构 (主要Rust实现)</h4></a>
<ul>
<li>src/main/{name} =&gt; 启动文件主目录</li>
<li>consensus =&gt; 共识算法</li>
<li>chain =&gt; 区块与交易结构</li>
<li>verification =&gt; 验证机制</li>
<li>witness/miner =&gt; 见证和打包机制</li>
<li>network =&gt; 网络模块</li>
<li>p2p =&gt; p2p网络以及穿透</li>
<li>rpc =&gt; rpc接口</li>
<li>sync =&gt; 同步模块</li>
<li>db =&gt; 数据库交互</li>
<li>storage =&gt; 存储机制</li>
<li>account =&gt; 账户体系</li>
<li>crypto  =&gt; 加密模块</li>
<li>serialization =&gt; 序列化模块</li>
<li>serialization_derive =&gt; 序列化派生</li>
<li>logs =&gt; 日志</li>
<li>tools =&gt; 工具</li>
<li>primitives =&gt; 参数</li>
<li>test-data =&gt; 测试数据</li>
<li>bencher =&gt; 基准测试</li>
<li>doc =&gt; 文档</li>
</ul>
<a class="header" href="#a区块链底层技术入门指北----持续更新-1" id="a区块链底层技术入门指北----持续更新-1"><h3>区块链底层技术入门指北 -- 持续更新</h3></a>
<p>区块链开发分为上层应用层开发和底层基础开发。</p>
<p>上层应用层开发主要集中在智能合约编写和RPC接口调用。</p>
<ul>
<li>智能合约（DAPP）
<ul>
<li>主要关于运用<a href="http://solidity.readthedocs.io/en/latest/index.html">Solidity Language</a>的以太坊生态系统</li>
<li>主要采取WASM的虚拟机生态系统，包括EOS等</li>
</ul>
</li>
<li>RPC接口调用 （钱包，区块浏览器）
<ul>
<li>传统后端技能</li>
<li>区块链节点部署能力</li>
</ul>
</li>
<li>FORK型区块链
<ul>
<li>编程语言</li>
<li>学会更改基本的创世区块或者辨识标识</li>
<li>学会更改P2P系统的相关配置</li>
</ul>
</li>
<li>区块链行业应用开发
<ul>
<li>智能合约开发</li>
<li>区块链框架的使用搭配和简单的配置</li>
</ul>
</li>
</ul>
<p>区块链底层基础开发主要分为四大模块：</p>
<ul>
<li>身份体系模块（密码学相关）</li>
<li>网络模块(P2P, RPC交互)</li>
<li>存储模块(高性能全量存储，去中心化存储)</li>
<li>共识模块（交易结构和共识算法）</li>
</ul>
<a class="header" href="#a前期预备学习资料-1" id="a前期预备学习资料-1"><h4>前期预备学习资料</h4></a>
<a class="header" href="#a比特币系列-1" id="a比特币系列-1"><h5>比特币系列</h5></a>
<ol>
<li>白皮书: <a href="https://bitcoin.org/bitcoin.pdf">原文</a>, <a href="http://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system">中文</a></li>
<li><a href="https://github.com/bitcoin/bitcoin">源码地址</a></li>
<li>Mastering Bitcoin书籍: <a href="https://github.com/bitcoinbook/bitcoinbook">原文第二版-好</a>, <a href="http://book.8btc.com/books/6/masterbitcoin2cn/_book/">中文</a></li>
<li><a href="https://bitcointalk.org/">社区讨论</a></li>
</ol>
<a class="header" href="#a以太坊系列-1" id="a以太坊系列-1"><h5>以太坊系列</h5></a>
<ol>
<li><a href="https://github.com/ethereum/wiki/wiki">Ethereum Wiki (whitepaper, yellowpaper)</a></li>
<li><a href="https://github.com/trufflesuite/truffle">Develop Framework</a></li>
<li><a href="https://consensys.github.io/smart-contract-best-practices/">Best Practices</a></li>
<li><a href="https://github.com/ConsenSys/smart-contract-best-practices/blob/master/README-zh.md">中文</a></li>
<li><a href="https://github.com/Scanate/EthList">Resource Awesome</a></li>
</ol>
<a class="header" href="#a后期强化底层知识-1" id="a后期强化底层知识-1"><h4>后期强化底层知识</h4></a>
<a class="header" href="#a共识算法系列-1" id="a共识算法系列-1"><h5>共识算法系列</h5></a>
<ol>
<li>BFT-拜占庭容错协议</li>
<li>PoW-工作量证明</li>
<li>PoS(DPoS)-权益证明</li>
<li>密码学相关-零知识证明</li>
<li>List结构</li>
<li>Tree结构</li>
<li>DAG结构</li>
</ol>
<a class="header" href="#p2p系列-1" id="p2p系列-1"><h5>P2P系列</h5></a>
<ol>
<li>DHT</li>
<li>UDP or TCP</li>
<li>异步网络通信</li>
<li>网络模型</li>
<li>RPC接口实现</li>
</ol>
<a class="header" href="#a存储系列-1" id="a存储系列-1"><h5>存储系列</h5></a>
<ol>
<li>K-V存储结构</li>
<li>内存型存储</li>
<li>缓存型存储</li>
<li>硬盘型存储</li>
<li>去中心化存储</li>
</ol>
<a class="header" href="#a密码学系统-1" id="a密码学系统-1"><h5>密码学系统</h5></a>
<ol>
<li>对称加密</li>
<li>非对称加密</li>
<li>同态加密</li>
</ol>
<a class="header" href="#a分布式系统-2" id="a分布式系统-2"><h5>分布式系统</h5></a>
<ol>
<li>著名理论
<ul>
<li>CAP</li>
<li>FLP</li>
</ul>
</li>
<li>同步时钟与非同步时钟</li>
<li>CRDT账户模型</li>
</ol>
<a class="header" href="#a真实项目源码参考-1" id="a真实项目源码参考-1"><h4>真实项目源码参考</h4></a>
<a class="header" href="#a标准代码组织结构-主要rust实现-1" id="a标准代码组织结构-主要rust实现-1"><h4>标准代码组织结构 (主要Rust实现)</h4></a>
<ul>
<li>src/main/{name} =&gt; 启动文件主目录</li>
<li>consensus =&gt; 共识算法</li>
<li>chain =&gt; 区块与交易结构</li>
<li>verification =&gt; 验证机制</li>
<li>witness/miner =&gt; 见证和打包机制</li>
<li>network =&gt; 网络模块</li>
<li>p2p =&gt; p2p网络以及穿透</li>
<li>rpc =&gt; rpc接口</li>
<li>sync =&gt; 同步模块</li>
<li>db =&gt; 数据库交互</li>
<li>storage =&gt; 存储机制</li>
<li>account =&gt; 账户体系</li>
<li>crypto  =&gt; 加密模块</li>
<li>serialization =&gt; 序列化模块</li>
<li>serialization_derive =&gt; 序列化派生</li>
<li>logs =&gt; 日志</li>
<li>tools =&gt; 工具</li>
<li>primitives =&gt; 参数</li>
<li>test-data =&gt; 测试数据</li>
<li>bencher =&gt; 基准测试</li>
<li>doc =&gt; 文档</li>
</ul>
<a class="header" href="#a区块链世界的可视化入口--类比浏览器" id="a区块链世界的可视化入口--类比浏览器"><h4>区块链世界的可视化入口 =&gt; 类比浏览器</h4></a>
<p>浏览器是互联网世界的一个可视化入口，区块浏览器是区块链上信息的可视化入口</p>
<a class="header" href="#exchange-coin" id="exchange-coin"><h1>Exchange Coin:</h1></a>
<p><em>non-center/center</em></p>
<a class="header" href="#taker" id="taker"><h3>taker</h3></a>
<ol>
<li>take a order to trade.</li>
<li>trade status.</li>
</ol>
<a class="header" href="#maker" id="maker"><h3>maker</h3></a>
<ol>
<li>make a order.</li>
<li>order status.</li>
</ol>
<a class="header" href="#geter" id="geter"><h3>geter</h3></a>
<ol>
<li>get all orders.</li>
<li>get all trades.</li>
<li>get self trades.</li>
</ol>
<a class="header" href="#deposit-withdraw" id="deposit-withdraw"><h3>deposit, withdraw</h3></a>
<ol>
<li>in amounts.</li>
<li>out amounts.</li>
</ol>
<p><em>center</em></p>
<a class="header" href="#user---center" id="user---center"><h3>user -&gt; Center</h3></a>
<ol>
<li>login, logout</li>
<li>register</li>
<li>resetpassword</li>
<li>message notification</li>
</ol>
<a class="header" href="#match-engine" id="match-engine"><h3>Match Engine</h3></a>
<ol>
<li>auto sells, buys match</li>
</ol>
<a class="header" href="#eclipse-attack-日蚀攻击" id="eclipse-attack-日蚀攻击"><h3>Eclipse attack 日蚀攻击</h3></a>
<p><a href="https://eprint.iacr.org/2015/263.pdf">原始论文</a></p>
<a class="header" href="#targeted-attack-定向攻击" id="targeted-attack-定向攻击"><h3>targeted attack 定向攻击</h3></a>
<a class="header" href="#a攻击方式" id="a攻击方式"><h4>攻击方式</h4></a>
<p>攻击者事先推测出下一个区块的生成者们（小范围），然后对他们发动攻击。</p>
<a class="header" href="#a抵御方式" id="a抵御方式"><h4>抵御方式</h4></a>
<p>隐秘而且无交互的选举策略。</p>
<a class="header" href="#a常见区块链说明" id="a常见区块链说明"><h4>常见区块链说明</h4></a>
<ul>
<li>比特币：理论上不可被攻击，因为无法事先知道，但是随着算力加大，可以预测下一区块肯定掌握在部分矿场中。</li>
<li>以太坊：跟比特币同理。
。。。</li>
</ul>
<a class="header" href="#the-rust-programming-language" id="the-rust-programming-language"><h3>The Rust Programming Language</h3></a>
<a class="header" href="#books" id="books"><h5>Books</h5></a>
<ol>
<li>awesome: https://github.com/rust-unofficial/awesome-rust</li>
<li>官方书籍: https://doc.rust-lang.org/book</li>
<li>中文书籍（社区书）: https://rustcc.gitbooks.io/rustprimer/content</li>
<li>中文翻译: https://www.gitbook.com/@kaisery</li>
<li>Programming Rust</li>
</ol>
<a class="header" href="#a未经研究的书" id="a未经研究的书"><h5>未经研究的书</h5></a>
<ol start="6">
<li>Step Ahead With Rust: 中高级的Rust书: https://www.amazon.com/Step-Ahead-Rust-Systems-Programming/dp/0999361805/ref=sr_1_1?ie=UTF8&amp;qid=1523651277&amp;sr=8-1&amp;keywords=Step+ahead+with+rust</li>
<li>Rust High Performance https://www.packtpub.com/application-development/rust-high-performance</li>
</ol>
<a class="header" href="#a区块链相关" id="a区块链相关"><h5>区块链相关</h5></a>
<ol>
<li>Parity: (Ethereum and Bitcoin) https://github.com/paritytech</li>
<li>Midsafe: very cool Autonomous Data Network https://github.com/maidsafe</li>
<li>Cita: a blockchain https://github.com/cryptape/cita</li>
<li>Protocol Labs's libp2p https://github.com/libp2p/rust-libp2p</li>
<li>Exonum: A framework for private blockchains https://github.com/exonum/exonum</li>
<li>Solana： 想要做一条高性能区块链的项目 https://github.com/solana-labs/solana</li>
<li>Ristretto Bulletproofs: 零知识证明的实验库 https://github.com/chain/ristretto-bulletproofs</li>
<li>Dalek: 专门研究椭圆加密学的项目 https://github.com/dalek-cryptography</li>
<li>Grin: MimbleWimble协议的实现(比特币扩容方案) https://github.com/mimblewimble/grin</li>
</ol>
<a class="header" href="#trait" id="trait"><h3>Trait</h3></a>
<a class="header" href="#a常见trait" id="a常见trait"><h4>常见Trait</h4></a>
<a class="header" href="#default" id="default"><h5>Default</h5></a>
<pre><code>impl Default for Kind {
    fn default() -&gt; Kind { Kind::A }
}

</code></pre>
<a class="header" href="#from" id="from"><h5>From</h5></a>
<pre><code>impl From for Kind {
    fn from() -&gt; Kind { Kind::A }
}

//when use
&quot;xxx&quot;.into()

</code></pre>
<a class="header" href="#pip-国内镜像的正确使用姿态" id="pip-国内镜像的正确使用姿态"><h3>pip 国内镜像的正确使用姿态</h3></a>
<a class="header" href="#a国内镜像站点" id="a国内镜像站点"><h4>国内镜像站点</h4></a>
<ol>
<li>pypi.doubanio.com    Nanning, Guangxi CN</li>
<li>pypi.tuna.tsinghua.edu.cn    Xicheng, Beijing CN</li>
<li>mirrors.aliyun.com/pypi  Hangzhou, Zhejiang CN</li>
<li>pypi.pubyun.com  Changzhou, Jiangsu CN</li>
<li>pypi.mirrors.ustc.edu.cn     Hefei, Anhui CN</li>
</ol>
<p>个人使用的清华的源</p>
<a class="header" href="#a配置" id="a配置"><h5>配置</h5></a>
<ol>
<li>单次使用: pip install -i https://pypi.tuna.tsinghua.edu.cn/simple flask (flask包为例)</li>
<li>用户级别的全局使用: 打开或创建 <code>~/.pip/pip.conf</code></li>
</ol>
<pre><code>  [global]
  timeout = 60
  index-url = https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>
<ol start="3">
<li>还有就是全局所有用户共享的配置: 打开或创建 <code>/etc/pip.conf</code>(linux为例), 配置信息如上。常用于系统自带的python, 需要使用su和sudo命令来操作的情况下。</li>
</ol>
<p>#####<a href="https://pip.pypa.io/en/stable/user_guide/#config-file">官方参考文档</a></p>
<a class="header" href="#pip-国内镜像的正确使用姿态-1" id="pip-国内镜像的正确使用姿态-1"><h3>pip 国内镜像的正确使用姿态</h3></a>
<a class="header" href="#a国内镜像站点-1" id="a国内镜像站点-1"><h4>国内镜像站点</h4></a>
<ol>
<li>pypi.doubanio.com    Nanning, Guangxi CN</li>
<li>pypi.tuna.tsinghua.edu.cn    Xicheng, Beijing CN</li>
<li>mirrors.aliyun.com/pypi  Hangzhou, Zhejiang CN</li>
<li>pypi.pubyun.com  Changzhou, Jiangsu CN</li>
<li>pypi.mirrors.ustc.edu.cn     Hefei, Anhui CN</li>
</ol>
<p>个人使用的清华的源</p>
<a class="header" href="#a配置-1" id="a配置-1"><h5>配置</h5></a>
<ol>
<li>单次使用: pip install -i https://pypi.tuna.tsinghua.edu.cn/simple flask (flask包为例)</li>
<li>用户级别的全局使用: 打开或创建 <code>~/.pip/pip.conf</code></li>
</ol>
<pre><code>  [global]
  timeout = 60
  index-url = https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>
<ol start="3">
<li>还有就是全局所有用户共享的配置: 打开或创建 <code>/etc/pip.conf</code>(linux为例), 配置信息如上。常用于系统自带的python, 需要使用su和sudo命令来操作的情况下。</li>
</ol>
<p>#####<a href="https://pip.pypa.io/en/stable/user_guide/#config-file">官方参考文档</a></p>
<a class="header" href="#a通过-selenium-加上-headless-chrome-来测试网页爬虫神器" id="a通过-selenium-加上-headless-chrome-来测试网页爬虫神器"><h2>通过 selenium 加上 headless Chrome 来测试网页(爬虫神器)</h2></a>
<p>废话无多，上码</p>
<pre><code>from selenium import webdriver

options = webdriver.ChromeOptions()
options.binary_location = &quot;/usr/sbin/chromium&quot;
options.add_argument(&quot;headless&quot;)
options.add_argument(&quot;window-size=1200x600&quot;)
driver = webdriver.Chrome(chrome_options=options)

driver.get('https://lovesun.xyz')
print(driver.title)
driver.get_screenshot_as_file('main-page.png')
driver.close()

</code></pre>
<ol>
<li>需要安装 <code>pip install selenium</code></li>
<li>本机有chrome浏览器， 我的是在linux下，用的chromium， 所以路径是<code>/usr/sbin/chromium</code></li>
</ol>
<p>后续还在接着写呢。。。</p>
<a class="header" href="#a按功能分层次" id="a按功能分层次"><h4>按功能分层次</h4></a>
<pre><code>test-demo
├── config.py
├── instance
│   └── config.py
├── requirements.txt
├── run.py
└── test_demo
    ├── forms
    │   └── __init__.py
    ├── __init__.py
    ├── models
    │   ├── __init__.py
    │   └── User.py
    ├── static
    │   └── style.css
    ├── templates
    │   ├── admin
    │   │   └── base.html
    │   ├── api
    │   │   └── base.html
    │   └── base.html
    ├── utils
    │   └── __init__.py
    └── views
        ├── admin
        │   ├── __init__.py
        ├── api
        │   ├── __init__.py
        └── __init__.py
</code></pre>
<a class="header" href="#a按模块分层次" id="a按模块分层次"><h4>按模块分层次</h4></a>
<pre><code>.
├── config.py
├── instance
│   └── config.py
├── requirements.txt
├── run.py
└── test_demo
    ├── admin
    │   ├── forms
    │   │   └── __init__.py
    │   ├── models
    │   │   ├── __init__.py
    │   │   └── User.py
    │   ├── templates
    │   │   └── base.html
    │   ├── utils
    │   │   └── __init__.py
    │   └── views
    │       └── __init__.py
    ├── api
    │   ├── forms
    │   │   └── __init__.py
    │   ├── models
    │   │   ├── __init__.py
    │   │   └── User.py
    │   ├── static
    │   │   └── style.css
    │   ├── templates
    │   │   └── base.html
    │   ├── utils
    │   │   └── __init__.py
    │   └── views
    │       └── __init__.py
    └── __init__.py
</code></pre>
<a class="header" href="#a各自优点" id="a各自优点"><h4>各自优点：</h4></a>
<ol>
<li>按功能分层次的优点是各种功能联系紧密， 公用的代码易于管理。 适合中小型的项目。 比如blog, cms, 简易的网上商城。</li>
<li>按模块分层次的优点是将各个功能分离出来， 适合模块化的迁移和公用。 适合稍大的项目, 模块间联系不是很紧密的情况。</li>
</ol>
<a class="header" href="#a各自的缺点" id="a各自的缺点"><h4>各自的缺点：</h4></a>
<ol>
<li>功能分层的话， 代码后期的迁移难度增加， 代码间的公用性太强， 容易牵一发而动全身。 而且当代码量增加之后， 维护性较差。</li>
<li>模块分层的话， 代码的冗余太多， 许多可以公用的地方无法很好处理， 构造繁琐， 工期较长。</li>
</ol>
<a class="header" href="#flask结构常见文件的作用" id="flask结构常见文件的作用"><h4>flask结构常见文件的作用</h4></a>
<ol>
<li><strong>config.py</strong> 主要存放配置信息。 比如DEBUG, mysql, sercertkey等。 可以通过flask的 app.config.from_object('config') 自动导入。</li>
<li><strong>instance/config.py</strong> 主要是私人的信息， 可以通过 flask 提供的 app.config.from_pyfile('config.py') 覆盖前者的配置。</li>
<li><strong>requirements</strong> 存放所需要引入的包。</li>
<li><strong>run.py</strong> 运行文件， 加入一些运行配置， 比如使用gunicorn配置， 也可以通过添加manager.py文件管理。</li>
<li><strong>views</strong> 文件存放路由信息， 俗称蓝图。 类似于MVC架构中的controllers。</li>
<li><strong>models</strong> 数据存放与处理的信息。 类似MVC中的Models。</li>
<li><strong>forms</strong> 表单存放的位置。</li>
<li><strong>static</strong> 静态文件的存放。 images/js/css</li>
<li><strong>templates</strong> jinja模板文件。</li>
<li><strong>utils</strong> 一些常用的方法集合。</li>
</ol>
<p>后续还有...</p>
<ul>
<li><a href="https://github.com/sunhuachuang/emacs.d">个人的emacs配置</a> *</li>
</ul>
<a class="header" href="#this-is-personal-fork-from-purcells-config-thx-him" id="this-is-personal-fork-from-purcells-config-thx-him"><h2>This is personal fork from purcell's config, Thx him.</h2></a>
<a class="header" href="#add-some-useful-for-me" id="add-some-useful-for-me"><h4>add some useful for me</h4></a>
<ul>
<li>rust (racer) =&gt; <code>lisp/init-rust.el</code></li>
<li>golang (gocode company-go) =&gt; <code>lisp/init-go.el</code></li>
<li>python =&gt; <code>lisp/init-python.el</code></li>
<li>php (compnay eldoc) =&gt; <code>lisp/init-php.el</code></li>
<li>china mirrors (nlinum package is missing, set it in missing dir)</li>
<li>snippets =&gt; <code>lisp/init-snippets.el</code></li>
<li>web-mode (use web-mode to replace html &amp; template) =&gt; <code>lisp/init-web.el</code></li>
</ul>
<a class="header" href="#a在emacs中开发python" id="a在emacs中开发python"><h3>在emacs中开发python</h3></a>
<p>直接看代码 <a href="https://github.com/sunhuachuang/emacs.d/blob/master/lisp/init-python-mode.el">点击查看自用配置详情</a></p>
<pre><code class="language-lisp">(setq auto-mode-alist
      (append '((&quot;SConstruct\\'&quot; . python-mode)
                (&quot;SConscript\\'&quot; . python-mode))
              auto-mode-alist))

(require-package 'pip-requirements)

;; flycheck use python flake8
;; pip install flake8  =&gt; C-c ! s
(when (maybe-require-package 'anaconda-mode)
  (after-load 'python
    (add-hook 'python-mode-hook 'anaconda-mode)
    (add-hook 'python-mode-hook 'anaconda-eldoc-mode))
  (when (maybe-require-package 'company-anaconda)
    (after-load 'company
      (add-hook 'python-mode-hook
                (lambda () (sanityinc/local-push-company-backend 'company-anaconda))))))

;; auto pep8 style format
;; need pip install autopep8
(defcustom python-autopep8-path (executable-find &quot;autopep8&quot;)
  &quot;Autopep8 executable path.&quot;
  :group 'python
  :type 'string)

(defun python-autopep8 ()
  &quot;Automatically formats Python code to conform to the PEP 8 style guide.
$ autopep8 --in-place --aggressive --aggressive &lt;filename&gt;&quot;
  (interactive)
  (when (eq major-mode 'python-mode)
    (shell-command
     (format &quot;%s --in-place --aggressive %s&quot; python-autopep8-path
             (shell-quote-argument (buffer-file-name))))
    (revert-buffer t t t)))

(eval-after-load 'python
  '(if python-autopep8-path
       (add-hook 'after-save-hook 'python-autopep8)))

(provide 'init-python-mode)

</code></pre>
<a class="header" href="#a注意点" id="a注意点"><h4>注意点</h4></a>
<ol>
<li>因为emacs的配置是fork自purcell的基础配置，所以外部不作介绍，就看python的配置</li>
<li>外部需要安装的pip包 有: flake8 (检查代码规范), autopep8 (格式化代码)</li>
<li>主体的python环境用的是anaconda包，并且使用comapany-anaconda来完成自动补全，保存时候自动进行pep8的format操作</li>
<li>关于autopep8 如果format一个文件夹而不是单个文件，在外部命令行下执行 <code>autopep8 --in-place --recursive your_dir</code></li>
<li>如丝般润滑~</li>
</ol>
<p>##现代私塾的发展研究
###摘 要</p>
<p>现代私塾，经过十年的发展为越来越多的人所熟知。民众长久以来所担忧的精神与
道德危机，找到了解决之道。21 世纪需要中国传统文化，而中国传统文化的继承与发展，
离不开私塾几千年的教育支撑。现代私塾以古代私塾为依托，融合现代教育特色，成为
众多中上层民众的选择。
本篇论文将从现代私塾的基本概念与作用谈起，解读现代私塾的教学方式与内容，
分析私塾从古至今的发展历程，阐明现代私塾的发展现状。着重分析了现代私塾在发展
过程中遇到的关于办学理念、教学内容、教学方式、家长期望的问题与产生原因，并将
自己的思想认知与私塾教育相整合，针对现代私塾教育的未来发展，提出了终身学习、
德智均衡、自主思考、目光长远四大建议并对此做出详细解释。本论文希望能对民众了
解私塾，关注教育发展，关注人类精神道德世界贡献自己的一份力量。
关键字： 现代私塾； 精神道德培养； 中国传统文化； 教育模式</p>
<p>###ABSTRACT
Modern private school, after ten years of development, is well known by more and more
people. The spirit and moral crisis that people have worried for a long time have found the way
to solve it. Twenty-first Century needs Chinese traditional culture, and Chinese traditional
culture inheritance and development cannot do without private school for thousands of years to
support education. Modern private school based on the ancient old style private school and the
integration of modern education, become the choice by many people.
This paper first talk about the basic concept and role of modern private schools and the
interpretation of modern private school’s teaching content and method. Then tell about analysis
of the development of the modern private school and clarify the current modern private school.
Focuses on the analysis of the problem encountered by the modern private schools in the
development process of educational philosophy, teaching content, teaching methods, parents'
expectations and the cause and will integrate their own ideological cognition and private
education and for the future development of modern private education, the lifelong learning,
comprehensive equilibrium, inspiration, four suggestions to long-term vision and this made
detailed explanation. This paper hopes to the public understand private school, pay attention to
the development of education, pay attention to a human spiritual and moral world with its own
strength.
Key words: Modern private school; Spiritual and moral culture; Chinese traditional culture;
Education model</p>
<p>###目 录
1.前 言 ........................................................................ 1<br />
1.1 选题原因与意义............................................................... 1<br />
1.1.1 选题原因 .................................................................. 1<br />
1.1.2 选题意义 .................................................................. 1<br />
1.2 研究目的与方法............................................................... 1<br />
1.2.1 研究目的 .................................................................. 1<br />
1.2.2 研究方法 .................................................................. 2<br />
1.3 基本概念与主要研究问题....................................................... 2<br />
1.3.1 现代私塾定义 .............................................................. 2<br />
1.3.2 现代私塾存在的必要性 ...................................................... 2<br />
1.3.2 主要研究内容 .............................................................. 2<br />
1.3.3 国内外的研究 .............................................................. 2<br />
2.现代私塾的背景及概述 .......................................................... 4<br />
2.1 现代私塾复苏的背景........................................................... 4<br />
2.2 现代私塾复苏的原因........................................................... 4<br />
2.3 现代私塾的教学方式与内容..................................................... 5<br />
2.3.1 教学方式更加丰富 .......................................................... 5<br />
2.3.2 教学内容范围更广 .......................................................... 6<br />
3.现代私塾的发展历史与现状 ...................................................... 7<br />
3.1 私塾的发展历程............................................................... 7<br />
3.1.1 私塾的由来 ................................................................ 7<br />
3.1.2 私塾的历史发展 ............................................................ 7<br />
3.1.3 现代私塾的复苏 ............................................................ 8<br />
3.2 现代私塾的发展现状.......................................................... 10<br />
3.2.1 兴奋期的快速发展 ......................................................... 10<br />
3.2.2 变革期的热度降低 ......................................................... 10<br />
4.现代私塾存在的问题 ........................................................... 12<br />
4.1 办学理念存在偏差............................................................ 12<br />
4.2 教学内容略显片面............................................................ 12<br />
4.3 教学方法不够开明............................................................ 13<br />
4.4 家长期望过于急切............................................................ 14<br />
5.现代私塾的未来发展之道 ....................................................... 16<br />
5.1 树立终身教育的办学理念...................................................... 16<br />
5.2 完善德智均衡的教学内容...................................................... 17<br />
5.3 采取自主思考的教学方式...................................................... 18<br />
5.4 引导家长树立长远的目光...................................................... 18<br />
结 论 ......................................................................... 20<br />
致 谢 ......................................................................... 21<br />
参考文献 ....................................................................... 22</p>
<p>##1.前 言
###1.1 选题原因与意义
####1.1.1 选题原因
本篇论文以现代私塾的发展研究为题，主要原因有三：首先，经常在报纸期刊中阅
读到关于现代私塾的报道，并对此有不同的观点，引起了自身的关注；其次，在大学四
年中，广泛接受中国传统文化的熏陶，时刻关注着中国传统文化的继承与发展，而现代
私塾的目的之一就有继承传统文化；最后，在课题选择时，发现学院允许写关于传统文
化方面的论题，因此在与导师的商榷之后，定下了论文选题。
####1.1.2 选题意义
此研究不仅是为了说明现代私塾发展过程中的问题，更是想借此探索一种新的教育
模式，构造一种以中式私塾教育为主的中西结合的教育模式，以期解决国民在精神与文
化素质方面的欠缺，同时，希望将这种教育模式推广到全世界，为实现全人类的美好而
和平的未来打下道德与精神基础。
罗素说过：“天性的幸福与生活的快乐，是我们在工业革命与生活坏境的重压下丢
失的最重要而又最平常的东西之一”。现代私塾作为新时代变革下的产物，其产生与发
展必有一定的道理，这不仅对于现代教育的改良，甚至是教育变革都有很大的参考意义，
中国传统的教育方式之所以能够持续几千年之久，与中国人的生活方方面面都有很大的
关联，中国人精神的继承与发展都离不开私塾的帮助，可以说，从私塾教育中，可见中
国人精神一斑。现代私塾，作为构造精神世界与传承传统文化受到了社会关注，而对于
现代私塾的研究，大部分都停留于报纸期刊，没有关于此的详细而具体的研究，并且最
重要的是，在阅读相关的资料后，笔者分析并提出了自己对此的一套看法，总结出了一
种教育改革模式。因此笔者希望将其研究下去，不仅是对为了更好的说明这个新兴事物，
更是希望对未来社会教育有所帮助。
###1.2 研究目的与方法
####1.2.1 研究目的
研究现代私塾的目的有三：首先，介绍现代私塾的发展、教学内容、教学形式等方
方面面，并向社会推广；其次，现在私塾发展过程中遇到的各种问题，需要加以修正，
对此提出了自己的一套看法与意见，并对此进行解释。本文是从传统文化与普通大众的
角度，看待现代私塾发展中遇到的问题与未来趋势。
####1.2.2 研究方法
研究的方法有三，首先文献查询法，通过将各种资料整合，与中国的国学大师，与
东西方哲学思想进行交融，得出自己的理论依据与意见看法。再者理论联系实践法，对
现行的教育模式与现代私塾的教育模式进行考究，弥补互相之间的不足。最后案例分析
法，通过对现实中案例进行观察，查询网络报刊上的真人真事，为写作提供参考依据。
###1.3 基本概念与主要研究问题
####1.3.1 现代私塾定义
现代私塾是指发起于 20 世纪 90 年代末，创建于 21 世纪初，以读经诵典为主要学
习内容，通过言传身随的教育方式，融合了现代自由式教育的特点而形成的一种新的教
育模式。
####1.3.2 现代私塾存在的必要性
现代私塾存在有两点必要性。一是在现代教育背景下，教育偏向于数理化的智育，
偏向于以金钱与利益为目的。现代人因此没有了思想根基，遇到问题无法寻找到行为判
断的准则。通过读经诵典，可以给人以精神寄托，平时的一言一行均可以找到来源，不
会盲目而不知所措。经典有着自己的一套理论认知与精神解说，与宗教有着异曲同工之
妙。二是时代的要求，21 世纪是中国传统文化的世纪，全世界都在兴起学习中国传统文
化的热潮，而中国作为发源地，能够将中国传统文化传承千年而不断，靠的就是私塾教
育，因此通过现代私塾教育，可以更近一步融入 21 世纪，先人一步了解到传统文化的
魅力。
####1.3.2 主要研究内容
在本次的论文写作中，主要针对现代私塾的办学理念的偏差、教学内容失衡、教学
方式不够开明、家长急于求成四个方面作探讨，并对此提出自己的一套看法与原因分析。
####1.3.3 国内外的研究
对于中国传统的教育模式的研究颇多，而对于现代私塾的研究所涉及甚少，主要集
中在报纸期刊上，因此本篇论文针对现代私塾的所有观点均为笔者原创。国外对于现代
私塾的研究，只是在于东南亚国家在法律上肯定了在家教育的合法性。台湾地区的现代
私塾研究，与中国大陆差异较大，而且资料甚少，不作具体比较分析。</p>
<p>##2.现代私塾的背景及概述
私塾，无疑是历史上中华文化传承与精神文明建设的最重要的贡献者，作为封建时
代的产物，私塾教育在建国后慢慢消失在人们的视野中，但是就在近十几年时间里，私
塾借助现代的人文与科学方法得以重生，现代私塾走向了历史的舞台。现代私塾即是以
现代儿童教育理论为基石，传统私塾的教育内容与方法为核心而形成的一种教育体系。
###2.1 现代私塾复苏的背景
从上世纪九十年代开始，一批专门从事于国学研究的学者，开始在台湾地区兴起读
经运动，读经运动主要是鼓励青少年，特别是处于幼儿时期的孩子，参与到对中国传统
经典的背诵中。其中的代表人物是王财贵，他是牟宗三先生的弟子，他推广的这项读经
运动，受到了南怀瑾先生的大力支持，与南怀瑾先生的教育观念不谋而合，因此，在台
湾造成了很大的影响。到 2000 年的时候，在台湾地区，读经的青少年已经达到几百万，
并且在东南亚国家的华人社区快速传播。
在 2000 年的时候，王财贵来到了北京师范大学演讲，诸多有识之士称之为“一场
演讲，百年震撼”。在此之后，大陆的诸多有识之士开始了探索读经诵典的路途，也因此
一些现代私塾开始陆续出现。在 21 世纪的今天，国家大力提倡弘扬传统文化，特别是
习近平总书记对于传统文化在中国的传承寄予了很大的期望，因而各种各样的现代私塾
借着改革的春风开始陆续出现，引起了社会中上层的广泛关注。接着社会名人郑渊洁与
韩寒等都公开表示，孩子将会由他们自己进行教育，引起了更多的社会民众关注现代私
塾。
###2.2 现代私塾复苏的原因
现代私塾的复苏，源于人们对于现代生活方式与心理健康的担忧，通过对家长采访
与相关的报道，总结出了以下三点原因。首先，现代教育体制对于儿童的身心发展不利。
引用南怀瑾先生的话“现代教育就是在摧残孩子”，这句话虽然说的偏激，但是有一定
的道理。现代的教育方式与教学过程不符合孩子正常的身心发展的需要，是对孩子心智
的破坏，使得孩子厌恶学习。但是通过背诵经典这种最经济的投入，有益于开发孩童的
智力与记忆力，通过婴儿时期的音乐与美术，及其他教育，可以使孩子在很小的时候，
就开始开发大脑对于艺术的感觉。其次，读经有助于对中国传统文化的继承。现代诸如
文化侏儒症的新式名词，均在强调中国人在文化传承上的断层，通过读经，可以在内心
留下很多的经典知识与语言，对于以后的写作说话，都能起到一个很好的帮助。最后，
读经诵典有助于培养健全的人格与积极的思想。现代教育成长出来的孩子，在思想上往
往都是跟随西方的玩乐主义，西方文化也有优良的地方，比如科学探索精神，但对此孩
子并没有学到多少，也因而犯了东施效颦的毛病。也是因为现代教育下的儿童没有自己
的独立的人格与思想体会，造成了社会上众多青少年的奇葩现象，人们开始认识到思想
教育的重要性。经典之作是开阔人的，是为了给人树立高远的胸怀的，而不是为了顽固
人。因此，受到了诸多人的追捧。
许多的民众在思考之后，便将自己的孩子送去读经，因此，很多的现代私塾性质的
教育班开始出现，发展到今天，不仅有各种教育培训班，还有全日制的现代私塾也逐渐
增多。现代私塾的主要教育对象是创办者自己的孩子，以及亲属朋友间的孩子。
###2.3 现代私塾的教学方式与内容
现代私塾通过对教学内容与教学方式的创新，赢得了很多家长的认同，与古代私塾
相比，其在教学方式上变化很大，与现代教育相比，其在教学内容上也有很大的创新之
处。下文将从比较中阐述现代私塾的教育方式与内容。
####2.3.1 教学方式更加丰富
相对于过去，它的形式发生了一些变化，笔者搜集到一份关于清朝私塾的教学内容，
如下：每天早起温习读书，背诵。上生书时，老师讲解完毕后，“命学生复述一遍，乃就
位念一百遍”。午后，主要是写字与温书，然后背诵。晚上练习作对，灯下读古诗。隔日
学写诗，逢三、八日作文，每逢初一、十五作史论诗赋。
在此份私塾课表中，我们可以发现，此时的学业主要集中在书本上，不管是对经典
的背诵，还是对于诗词歌赋的练习，均是在一个学堂中完成的，并没有开辟更多的空间
的进行其他的学习，但是现代的私塾，学习地点与时间发生了很大的变化。不再是过去
严厉环境下的刻板教学，而是多了许多的自由空间，孩子们每天放学之后，并没有手机
电脑的干扰，而是一起爬山或者互相娱乐。同时教学地点也不仅仅是课堂上，而是很随
意性的，席地而坐，行走中，都可以进行教授。采用的课堂教学方式，主要是王财贵的
六字真言“小朋友，跟我念”，通过言传身随的方式，让孩子们背诵经典。这与古代私
塾并不二话。在此，也略提古代私塾，并没有那些不懂得人们认识的那样，充满古老腐
朽的气味，其在听说读写方面都有很大的重视。对理性与才艺的关注更为重视，与现代
教育只关注理智，即科学技术水平是有很大差别的。</p>
<p>####2.3.2 教学内容范围更广
现代私塾在教学内容上与现代教育有着很大区别。现代私塾教学的课本主要是四书
五经之类的传统典籍，而且主要学习是背诵，没有很多对于文字的讲解工作，除了背诵
经典，现代私塾还开设了与传统艺术相关的课程，注重学生的精神世界。在画家张中和
开办的私塾中，除了背诵经典的课程外，还有武术，美术，音乐等兴趣课程，也有艺术
的必须课程，大部分私塾每天也会花 20 到 30 分钟给孩子讲讲数学，使他们能与体制内
学校的学生水平相当。据采访资料显示，私塾的学生，在琴棋书画上的造诣相比于体制
内学生要高出很大的一筹。要说艺术是否能与科学技术有一比，当然仁者见仁，智者见
智，但是无可厚非，艺术造诣的提高乃文化的一大进步。再者，现代私塾不仅教授学生
中国的经典作品，还教授国外的经典，比如莎士比亚的十四行诗，美国的《独立宣言》
等，都是学生必背的文章，这也是与体制内英文教学内容相去甚远的地方。</p>
<p>##3.现代私塾的发展历史与现状
现代私塾的起源是古代的私塾教育，私塾教育源远流长，为了彻底了解现代私塾的
特色，对古代私塾发展研究是十分必要的，并且相比于古代私塾，现代私塾在教育形式
与内容上也产生了诸多变化。
###3.1 私塾的发展历程
####3.1.1 私塾的由来
《礼记·学记》载：“古之教者，家有塾。”郑玄注：“古云仕焉而已者，归教于闾里，
朝夕坐于门，门侧之堂谓之塾。”孔颖达疏：“周礼百里之内二十五家为闾，共同一巷，
巷首有门，门边有塾。民在家之时，朝夕出入，恒就教于塾。”据裘锡圭先生考证，在殷
墟出土的卜辞中，有多处提到了塾。塾在卜辞中作“孰”，两个字旁为上下结构。不过，
商代的塾不是教育儿童的场所，而是宫门侧之堂。说文解字中，亦将塾子作该解，清人
顾震福的解释是：“臣朝君至门外，当就舍更详熟所应对之事。塾之言熟也，是塾本以熟
思得名。”（《隶经杂箸》甲编卷下）。综合上面的考证之后，我们大致可以将私塾的出现
定义在西周时期。塾，即是西周乡试中的一种形式，是教学的地址，而私塾则是指私人
开办的塾，与之相应的还有家塾，指富裕家庭或家族开办的塾。在此论文中，我所指的
私塾指广义的私塾，是包括狭义的私塾与家塾。现代历史学家，普遍同意：孔子所开办
的私学，即是私塾的一种，因此，孔子乃最有名的塾师。
####3.1.2 私塾的历史发展
私塾从春秋战国之后开始大量出现，特别是孔子的私学形式的教学方式，在各个流
派和国家中开始兴起。在秦朝统一六国之后，私塾的发展进入波动期，原因是秦朝的焚
书坑儒，对私塾推广最盛的儒家造成致命打击。到了汉武帝时期，汉儒的出现使得儒家
性质的私塾开始站住了脚，特别是董仲舒宣扬的“天人感应”、“大一统”，受到了统治者
汉武帝的赞许，在其的大力推广下，开始了浩大的“罢黜百家，独尊儒术”的运动。从
此之后的几千年时光，儒家性质的私塾，成为了封建教育的正统。但是也顺便提一下，
自汉儒之后，儒学的性质开始了转变，从孔子的仁爱，追求人性的美好初衷，开始沦为
封建统治者治理国家的伦理手段。
在汉朝之后，进入了魏晋南北朝时期，这个时候的选举人才的制度，变成了九品中
正制，选官任官主要是士族大夫的事情。对于贫穷的中下层人民，耕种养殖成为了世代
相传的事情，因此，在农村与贫苦地区的私塾，此时教授的内容也变成了基本的蒙学。
所谓蒙学，则是指识文断句，以最基本的伦理与简单的识字为主体，对于高深的儒家思
想或者百家思想都没有了解，论语能学半部尚属困难，何谈诸子百家。这时候的私塾的
发展受到了冲击，很多人都无需上私塾，或者上不起私塾。
在此之后，战乱少了，五胡乱中原也结束了，隋朝开始成为大一统的王朝。在隋文
帝杨广的政策下，一个延续千年，直到清末的科举制正式确立。不管是士族大夫，还是
穷苦小民，都可以通过学习，来改变自己的生命轨迹，社会上下层的流动开始出现。在
此的利益驱动下，各种乡间私塾成片兴起，不管再如何清苦，也要将孩子送进私塾读书，
读书改变命运的时代来临，自此“书中自有黄金屋，书中自有颜如玉”成为了每一个少
年、青年的人生准则。正是因为私塾的出现，文化也进入了兴盛的时期，从前文化名人
主要是世家大族中的人，现在贫苦自学、“偷学”的人开始走向历史舞台，促成了唐代诗
歌的巅峰表现。此后的宋朝，人民物质极大丰富，家家能用金银，家家更能够上的起私
塾，更甚者家塾。此现象到了宋朝朱熹之后，统治者为了加强统治，将朱子的四书集注
等强行纳入科举考试的范本，开始了八股文的强力统治时期，此多为后人所诟病。
到了清朝末年，国门打开，西方的先进科学技术接踵而来，洋务运动、明治维新，
在一大批改革家的推动下，科举结束了。私塾慢慢转变成现代学堂，特别是五四运动，
新文化、新思想的注入下，新的教学形式与内容开始取代私塾。民国时期，私塾与现代
学堂的斗争进入了针锋相对的时期，二者半斤八两。到了解放以后，在新中国的土地改
革与教育变迁之下，私塾逐渐消失在了历史长河中。
####3.1.3 现代私塾的复苏
本来在新中国已经消失的私塾，近年来，随着读经运动的推广，人们对于精神生活
的追求，对于传统文化的传承，对于现代体制内教育的诟病，在诸多的因素作用下，私
塾开始了复苏趋势，我们将其名为现代私塾。此阶段状况下文做详细探讨。在此，提出
一个本文重要思想基础：中国传统文化的复兴是时代的要求，不随人的意志为转移。
为了说明读经运动对于儿童教育的意义，现代私塾支持者举例了很多的中外大家在
年少的时候读经诵典的实例，甚至于搬出了新文化运动的“始作俑者”胡适之先生。胡
先生一生中，对古文化的态度提出两种截然不同的观点。年青的时候，在新文化运动时
期，他是打倒孔家店的先锋，他是提倡新文化代替旧文化的最有力量的人物。而在其垂
暮之年，则一改以前坚信的新文化，提倡中国应该继承传统文化，复兴中国的文化。胡
适之先生的弟子在其传记中批注，希望能够重新开始私塾教育，并表达自己对于中国文
化断层的担忧。对此，笔者也有一些观点，在新文化运动时期，之所以传统文化受到了
很大的冲击，主要是因为其乃国民革命时期，中国需要的是奋起反抗的斗争精神，而中
国传统文化所宣扬的则是一种散漫的态度，散漫即是和平，越和平则越散漫。所以在这
种精神状态下，想要取得与外国列强斗争的胜利，文化需要变革，人民的精神世界需要
重铸。现代很多提倡古文化的专家学者，总是喜欢将新文化运动批评为中国文化断层的
罪魁祸首，其实不然，虽然新文化运动对中国文化形成了强有力的打击，甚至全盘否定，
但是这是历史发展的无奈，也是中国人能够取得后来成功，新中国能够成立的基石。而
后来胡适之先生的态度发生转折，也不难看出。毕竟胡适之先生是对中国文化有深刻研
究的学者，虽说他是一个革命党人，在国民党中举足轻重，但是说到底，他还是一个文
人，只要是文人，特别是从小就接受中国传统教育的文人，骨子里有一种悲天悯人的气
息，对于国家与人民有相当强的担当精神，这即是儒家的修身、齐家、治国、平天下。
在胡适之先生的晚年时期，台湾地区的经济已经得到了相当快的发展，而新生在台湾的
一辈人，因为他们接受的都是西方的新式教育，这时候的台湾几乎已经全盘西化了。这
时候胡适之先生发现台湾人民的生活与人际关系出现了不和谐，出现了斗争冲突，出现
了靡靡之音，出现了西方的享乐主义与自我中心主义，因而他又将目光转向了中国传统
文化，从中发现了诸多可以治理现代怪乱的精神指引。这正是他晚年的思想改变的缘由。
详细解说了胡适之先生的思想变迁，主要是为了说明：中国文化的复兴与传承是时
代的要求，不会因为某些专家学者的大力反对而改变，也不会因为古文化提倡者的大力
吹捧而改变。时代的客观需要，不会因为个人的意志而转移的。当普通的人民大众发现
自己需要这种文化来完善人格或者和谐相处的话，他自己就会从心底去寻找这种精神的
寄托。这也就解释了为什么了现代私塾与读经运动一兴起，就有很多的社会中上层的精
英开始关注，并将自己的孩子送入其中，因为他们是最先体会到社会的变迁的，最先感
受到需要改变的人。而普通的大众还在为生活奔跑的时候，哪里有时间来想那么多精神
与思想上的事情，只有当物质世界足够发达，人们开始关注周围的人与物的时候，人们
就会主动去寻找，而中国传统的文化，特别是先秦时期的诸子百家，无疑是为了这个时
代而创造的，因而梁漱溟先生说，中国文化是早熟的文化，跨越了千年之久才能够得以
繁荣昌茂。</p>
<p>###3.2 现代私塾的发展现状
据网络上、期刊上的统计数据，现代私塾的发展可以分为兴奋期与转变期。兴奋期
指的是，在本世纪初几年到 2013 年。之所以将其在 2013 年分割，主要是因为在读经推
广的时间里面，完成了诸多私塾所认可的十三岁教育的理论，该理论详情，此乃后话。
经过十来年的发展，很多家长从开始的疯狂热衷，开始转入了冷静思考，并且随着很多
儿童的毕业，一些问题也随之出现，变革期也即将到来。
####3.2.1 兴奋期的快速发展
严格来说，现代私塾发起于上世纪 90 年代末，主要是因为台湾的读经运动是从那
时候开始的。此时台湾开始出现诸多私塾教育，而大陆并没有出现其复苏迹象，大陆地
区的私塾，真正应该考究到 2000 年以后，第一个出现的私塾出现在深圳地区，名为儒
愿学堂，2001 年创办，并于此后 2005 年开始招收外来学生。从此刻起，深圳的梧桐山
开始逐渐成为现代私塾的集中地。于此同时，上海的“孟母堂”、北京的“国学馆”、广
州的“六艺私塾”、深圳的“鹿鸣学堂”、苏州的“菊斋私塾”、武汉的“今日学堂”和沈
阳的“九雯学堂”等相继在此后的几年内成立起来。到了 2013 年的时候，全国将近有
3000 所现代私塾成立起来，其中学生人数不一定，人数最多的鹿鸣学堂有 100 人左右，
而一些小的私塾就只有 3 到 4 人而已。因为现代私塾都是没有经过政府教育部门审批
的，因此在数量上很难完全准确的统计。这些私塾刚开始主要分布于深圳、上海、北京
等一线大城市，而后开始向二线城市苏州、武汉、成都、重庆、沈阳等开始蔓延。
现在全国私塾分布已经基本达到了各省会城市均有的地步，宏观形势是：南多北少，
东多西少，大城市多、小城市少，规模小的多、规模大的少。私塾的教学所在地，也不
尽相同，深圳梧桐山的读经村，是在风景秀丽的山脚下，而全国其他的私塾主要位于城
市的住宅区，不谈风景如何，但是相对安静一些。随着国学热的继续汹涌与越来越多民
众的关注了解，相信现代私塾增多的情况还会继续下去。
####3.2.2 变革期的热度降低
在 2013 年之后的变革期，对于已经读了几年的私塾学生，他们以后的学习教育生
涯受到了各方关注。有些家长发现孩子读了几年之后，并没有表现出有什么特别显而易
见的文化积淀，因此开始将孩子送到现代教育体制下。也有家长觉得只是经过读经，并
不能满足孩子以后的日常生活，特别是数理化方面的能力，也因此将孩子领出私塾。也
有很多的孩子虽然以前能够背诵，但是一段时间之后便会忘记，使得家长很不满意，甚
至于有的家长发现孩子学了几年，竟然在认字上还有一定的问题的时候，便领着孩子开
始逃离私塾。相对于兴奋期来说，这个时候的家长，开始慢慢理性认识现代私塾与现代
教育体制，发现了诸多的问题。
在此现实下，诸多现代私塾也开始了相应的变革。比如，很多的私塾以前只教授读
经，而现在也开始进行数理化的教授。但是，也有很多的私塾下定决心，绝不会在十三
岁之前接触数理化。与此同时，为了解决孩子在完成十三岁教学以后的教育问题，王先
生在北京创办了文礼书院。该学院只接受读经出来的孩子，成为了读经孩子的清华北大，
但是招生要求只有一个，即是能够背诵三十万字（中文二十万，外文十万）的经典。这
渐渐使得一些私塾的创办者将背诵提高到了相当的程度，这又造成了另类的应试教育，
起到了极其恶劣的影响。全国很多地区的现代私塾，人数开始了减少。还是拿梧桐山的
读经村为例，张中和先生创办的得谦学堂，人数最多的时候有几十人，而现在人数下降
了一半。因此，现代私塾的教育慢慢走到了变革的地步。</p>
<p>##4.现代私塾存在的问题
现代私塾与古代私塾不尽相同，又与现代的教育体制有很大的区别，可以说这是一
个既老又新的事物。在其发展过程中不免出现很多的问题，亟待解决，马克思曾经也说
过：新事物的出现于成长总是充满波折与艰难的。因而，现代私塾想要在社会上占有一
席可容之地，还需要更多的变革与改进，下文从理念、教学内容、教学方式、家长认知
四个方面阐述出现的问题与原因。
###4.1 办学理念存在偏差
现代私塾诸多创办者所认可的是王财贵的关于儿童读经运动的理念，认为读经只能
从很小的时候开始，或者说必须在十三岁之前完成，而如果超过了这个时间，则人生都
已经成为了定局，不必再费周章教授。对此，笔者认为该理念不可取，人的认知与道德
思想的塑造，并不局限于少儿时期，只要教授的好，改变一个人亦非难事。
诸多的家长，在孩童很小的时候便急于送去私塾学习，无可厚非，但是任何时期，
只要想学想要改变，均未尝不可。国学大师梁漱溟先生，小儿时期上的是学堂(现代教育
的小学雏形)，根据其个人的传记，美国教授艾凯所著的《最后一位儒者》以及个人的访
谈记录，用他自己的话说：我从小没读过什么古书，对古文学的研究也不多，比不得文
学研究的大家，我只是在一些书本中学习，我只是爱思考，说我是哲学家的话，则更为
贴切。无论说梁漱溟先生是不是一个另类的存在，但是据其思想的挖掘，我们可以很容
易的发现，他对儒家、佛家的思想的理解，已经到了一个十分高深的程度，而就是这样
一个新派儒学的三大圣人之一的人物，则承认自己并没有背过所谓的经典。于此，我们
可以发现诸多人称颂的所谓：想要传承传统文化，想要有一个完整的人格，必须通过十
三岁前完成对经典的背诵这一理论基石，出现了与现实的偏差。
只此一例，即可直接指出现代私塾在教育对象的年龄上严格要求有所偏差，虽说，
十三岁之前是教育的黄金阶段，但是人的性格与道德的培养，还有文化的积淀，并不能
因为年龄而有所限制。
###4.2 教学内容略显片面
教学内容方面的主要问题反应在儿童结束私塾学习之后，表现出比其他同龄儿童数
理化成绩方面的差异，与现代的教育所提倡的自由全面发展之间的冲突。
在此问题上，现代私塾采用的是德的培养，是理性优先的培养。对于理智方面的知
识，在他们看来，完全可以放到十三岁以后，因为十三岁时人类心理与生理上的一个转
折点。现代的教育理论普遍认为十三岁之后，孩子会开始有自己判断世界的标准，对世
间的问题，开始有了自己的看法，由完全模仿的儿童期成长到自己认知的少年期。而这
个时候，儿童的大脑发育也就达到了一个水平，能够理解一些抽象的思维，比如数学物
理等。因此现代私塾倡导的教学内容也不难理解，他们想通过在十三岁之前，让孩子背
诵完经典，将未来的为人做事的准则率先注入到孩子的思想中。
这种内容教学还是欠妥的，首先，在其教育德与智的选择上，笔者还是很同意的，
因为在儿童的模仿期间学到的思想，会直接影响未来一辈子的行为与道德水平，通过后
期的强行教导改变是十分困难的，新闻媒体经过有如下报道：夫妻有一孩子，在其很小
的时候，由夫妻的父母带大，但是父母的教育方式着实不可取，是一种溺爱性质的教育，
因而在孩子长大后，回到父母身边，其性格已经变得格外的调皮。虽说调皮是孩子的天
性，但是任由孩子调皮而置之不理，到最后，培养出来的肯定是一个疯狂原始人，极限
放养的结果即是原始人。虽然花了很大的力气来改正孩子的性格，想让其起码学会一些
道德标准与行为适宜程度，结果收效甚微。想必今天的孩子，凡是通过老一辈带大的，
均可能出现生活方面惹人心烦的事情。所以，笔者支持，在婴幼儿期就对其进行正确的
伦理思想与道德的塑造，这并不是所谓的压制儿童的成长，更不是对儿童心灵的虐待，
这是正常社会人的起码的基础。但是对于其教育内容上，还可以适当添加一些理智教学，
后文的建议中将详细叙述。
###4.3 教学方法不够开明
教学方法上存在的问题，在于只通过“小朋友，跟我念”，来完成教学的工作，并不
考虑儿童理解与否。对此很多家长反映，儿童在上完之后，有许多汉字，他会写，但是
不懂什么意思，更谈不上如何使用，这也就导致了很多家长对此的不满。
对此，儿童不理解、不会用的原因显然是因为儿童没学过。儿童是否需要学习，每
一个字的意思，甚至是否需要理解其背诵的文章的意思呢？对此，笔者的理解是不需要
完全懂得。之所以要读经典，背诵经典，主要的目的，还是从经典中学习其做人做事的
道理，寻找到未来心灵的一种寄托，该寄托于西方的宗教寄托有异曲同工之效，只不过
根源方法上却又天壤之别。西方的宗教是为了用神的意志来强加到人的身上，用神的审
判来使人恐惧，进而来达到教化人民的目的，而中国的儒学，传统文化中，没有宗教色
彩，虽然现代有儒教这一说法，但其也只是形式上有宗教感觉，而且这还是封建统治者
意志的强加，与儒学有很大的区别，孔子说：“未竟人，何竟鬼”、“子不语怪力乱神”，
意思是人自己都没有明白之所以为人，还去谈论牛鬼蛇神，因此可以看出，孔子思想中，
是不相信神鬼之说的，因而他倡导的儒家思想，是不可能有神鬼祭祀的，这只是后来儒
者强加的。因此，也可以发现，儒家，传统文化的核心，是教导人之所以为人的。对儿
童塑造其一生的性格与道德水平的促进作用是显而易见的。回到刚才之所以说，不需要
完成理解，还因为，既然选择了读经诵典，那么在经典中徜徉的久了，就可以用自己的
思维去读一些古文了，而不是要将其翻译成现代白话文来理解，这才是传统文化传承的
核心要求，能够读懂古文，甚至能够模仿古文作文章。笔者觉得，对于文言文的翻译是
对中国人的最大侮辱。自己祖先的文章都看不懂，而且用的还是从魏晋时期就已经基本
定型的汉字。孔子有言：好读书，不求甚解。就是这个意思，并不是要懂得字面的意思，
而是懂得其中蕴含的道理即可。
###4.4 家长期望过于急切
现在摆在私塾面前最大的问题，想必是儿童与家长对于现实与期望没有符合的冲突。
上文写到，有的家长发现，如果按照私塾老师的计划，孩子可以在十三岁之前，起码能
够背诵三十万字的经典，而现在过去几年之后，孩子虽然反复在背诵，但是背完了又会
忘记，并不能达到理想的期望。对于这个问题，需要分析以下二点：背诵经典的目的与
背诵经典是否值得。
首先，背诵经典的目的。按照诸多先生的考究，背诵经典，是为了孩子的一辈子打
下坚实的基础，这是一种隐形的变化，不能因为一时的不明显而感到失败或者放弃。其
次是背诵经典是否值得。在此，章太炎先生在一篇《论读经有利而无益》中提到：读经
在于修己治人，夫读史之效，在于发扬祖德，巩固国本，只为西方学的话，只能终为奴
掳而已矣。现代的很多国人均认可了，读经是对儿童有益的。那么此刻的问题，是背诵
经典是否值得的问题，经典是否需要背诵，是否只有通过背诵才能够达到修己利人的程
度，个人觉得不必，经典之所以为经典，并不是因为它的语言文学的水准有多高，而是
其中富含的经典解释与人生的哲理，才是经典最大的特色，而只通过背诵经典，囫囵吞
枣地话，那么收获到的只是词句罢了，但是，这与推广读经的儿童之见出现的最大的问
题之处是儿童并不能理解其中的道理，甚至于，给予他解释，他可能也并不了解成人世
界中的各种准则。对此，在读经推广们看来，只有强行背诵，以后慢慢回味即可。在笔
者看来，此乃下下之策，上上之策为何，是让儿童自己领悟，这与现阶段的儿童心理的
成长理论是完成符合的，也与现阶段人性的解放，追求个性发展，追求创新相符合的。
但是需要老师把握住教授解释时的原则。</p>
<p>##5.现代私塾的未来发展之道
对于现代私塾的发展，结局只有两条路，而且都是与现代教育相结合的。其一是以
现代私塾为主体，通过将现代的一些观点与理论加入到其中，发展出的一种中式教育。
二是以现代教育为主的教育方式，其在体制内进行改革，将传统文化与经典融入到日常
的学习中去，该方式与现在的教育一样，依旧参考的是西式教育模式。对于我对人类未
来文化融合的看法来说，笔者坚信第一种，中式教育更能成为时代的需要，也是复兴中
国传统文化的最强有力的教育模式。这并不是说是中国人的自豪，或者说是为了争一口
气，而是时代的文化将是以东方文化为主，融合西方文化，这样的条件下，以东方教育
为主也就不难理解了。对于以现代私塾为主体的中式教育，主要有四个方面的改良建议。
###5.1 树立终身教育的办学理念
任何人在任何时候，均可接受传统经典的教授，现代私塾理应开办面向儿童的全日
制教育与面向成人的文化修养兴趣班。
这就涉及到该教育是否定义为完全的婴幼儿教育和儿童教育。正如上文所分析那样，
对于成人的思想改造与文化传承，通过经典的学习，也还是能起到很大的效果的，除非
放任不管，不采用中式教育，否则将同新闻报道的孩子一样，变得难以教导，难以改变。
因此，建议将现代私塾扩展到适应所有的年龄层。可以将现代的私塾打造成一个立体全
方面的经典教育基地，包括儿童的教育，成人的教育以及对于那些选择其他教育模式的
儿童的辅导性教育，但是那些教育必然是儿童教育的副产品，主要的作用还是全日制的
儿童教育，相信在中国发展愈演愈烈的时候，中国的立法部门与政府部门肯定会将现代
私塾纳入到合法的范围中去，这不仅是对传统文化的继承，更是这个时代对于中国传统
文化的需要。而对于一些现代私塾未来出现的各种不良情况，只要在立法与政府部门肯
定之后，那么也将进入监管的范围。
一般在大城市的私塾的收费均在每年 2万元左右，这与众多的高质幼儿园价格接近，
由新加坡倡导的爱儿坊幼儿园，每年的花费也在 2 万多左右，但是与现阶段的幼儿园最
大的差别之处在于，现代私塾都不是在所谓的学区房中，可以省下一大笔开支。当然，
现阶段私塾的价格，对于普通家庭来说，还是很高的，难以接受，原因就在于现代私塾
在很大程度上沿袭了古代私塾的特点，就是因材施教，都是小班形式的，导致了价格的
高昂，对此，未来的私塾模式教育，想要成为中国普通类教育来说，要解决的是两个问
题:一个是数量，一个是价格。在笔者看来这都不是最要紧的，可以通过市场的调节机制
与现代的租赁形式加以解决设施设备的问题，而最要紧的上文已经言明，在于教学内容
与方式上。
###5.2 完善德智均衡的教学内容
德以中为主，智以西为主。中国传统经典在于塑造人的精神与道德，开阔人心理与
认知；西方现代科学在于开发智力，丰富民众的物质生活。德智均衡，是以德为主，以
智为辅，再经过艺术与美的熏陶，来达到一个人的全面发展。
教学内容的多样化， 将中西结合的结果用来培育现代社会人，这是未来的趋势，有
很多的私塾创办者坚称：我们只教授背诵经典，不会去教授数学之类的。这种心理很奇
怪，难道在他们的心目中，经典所带来的理性与科学赋予的理智是完全不可兼容的东西
么？你学经典的同时，就不能去学习数理化，就不能参与科学教育中？这种想法是极其
错误，德与智是相辅相成的，这也反映了中国文化的一大特色，那即是融合能力。纵观
历史，多次的外来文化的入侵，最终的结果都是被传统文化所同化了，不管是印度的佛
学，还是西方的基督教。佛学传来已久，早已形成了中国本土的佛教与佛学，而基督教
因为传入时间不长，特别是清末民初的动荡时期，为了侵蚀中国人的信仰，而流传也很
广，但是至今的作用已然甚微，就算中国的建筑、服装、饮食，甚至行为都受到西方的
强烈影响，但是西方的根基宗教思想还未对中国形成普遍的威胁。对此，可见一斑，中
国的同化能力是不可阻挡的，因此，将东西方的教育相结合，想必是一种趋势，特别是
国外的教育改革，国外的很多教育学家，针对西方的教育的弊端开始寻找改变的时候，
都不约而同的将目光放到中国来。现在的西方学者，很多也同意：中国传统文化将成为
下一世界的指导思想。对此，中国传统文化如何继承与发展受到西方的关注，私塾亦走
入西方人的视野中。对此，我们国家比任何的地区与国家都更能深刻理解，与更加容易
尝试将两者相结合。结合的方式，主要是教学内容上的融合，背诵经典的同时，拿出时
间来传授现代的数理化等科学知识，西方的数理化系统是最完善的，这点毋庸置疑，所
以不必刻意学习中国的传统数学，诸如《九章算术》之类。
现代的大部分私塾，开设了很多德智体美劳全面发展的课程，特别是艺术的培养，
这些都是在儿童教育中尤为重要的，儿童需要美学的熏陶。同时，开设基本的计算机学
习也是必不可少的，但是不能花太多时间用于计算机课程，这对儿童的身心发展都是不
利的。</p>
<p>###5.3 采取自主思考的教学方式
现代私塾教育不谈对错，只谈善恶。自主思考，方能解放人。
教学方式的自主化，这也是东西方文明的结晶，西方过度强调自由和个性的发展，
中国过于强调规范与行为准则，因而结合二者，能够得到的效果，无疑是最好的。在教
授经典的时候，需要儿童的自我思考，加上老师的稍加引导，老师不评对错，只评善恶。
启发学生的独立思考与乐于思考的习惯，为其自主学习，热爱学习打下思想基础。老师
的教授过程中对于学生的指引，需要老师有较好的文学水准与道德基础，能够在儿童的
理解出现重大恶劣倾向的时候给予纠正。甚至于私塾的老师也不能自以为是的了解其语
句的正确答案，便随意强加给学生，特别是翻译文言文，翻译文言文都是字面的解释，
无法将其意思与意境完全表达出来，如同外文一般，翻译即是一种破坏，需要的是领悟，
而古今的领悟数不胜数，谁的领悟更深一层，谁的领悟出现偏差，都需要儿童自己思考。
有一教学实例是成都明德书院的教学场景，其做法很是优良，摘录如下：
“朝闻道夕可死矣。什么意思？请说说你们自己的理解。”年轻的盛老师领过早读
后，赵钦任老师给孩子们讲解国学经典。
堂上七至八岁的学生，共坐了三排，个个都很踊跃，全部举手抢着要回答问题。
振宇第一个站起来说：“昨天晚上道理都死了，我今天早上才听说。”
孩子们笑得拍桌子，同学一凡称他是“搞笑大王”。
赵老师也笑：“是这个意思吗？请坐。”
珊珊的答案很简洁：“要珍惜时间。”
赵婉云则认为：“如果早上听说道理，晚上就死了，好是好，但是多活几天会更好。”
###5.4 引导家长树立长远的目光
文化在于积淀，思想在于自省。高瞻远瞩方能成就人生，且圣人非一日之功。
家长想要立马发现自己孩子的思想深度与文化底蕴，显然是不可能的，因为中式的
私塾教育强调的是思想与道德的塑造，而不像科学那样，可以计算，通过分数来衡量的。
因此，要求孩子的父母相信这种教育，并且关注孩子的心理教育与全面发展，关注孩子
未来的道德水平与文化水平，而不是只关注与孩子的考试，这样的话，才能解决很多现
实中的冲突问题。儿童在学习了一段时间的现代私塾之后，家长与老师可以根据儿童是
否乐于其中，是否希望更深入学习，来判断儿童是否应该继续在现代私塾中学习，如果
儿童抵制这种教育模式的话，则可以为其选择更适合的教学模式，因为人是生而不同的，
资料显示，在现代私塾上过学的孩子，在琴棋书画中展示出来的能力十分超群。因
此支持与鼓励私塾学生参与艺术类比赛于表扬，向别人展示自身独特的地方。在自身的
一个实例中，可以发现现代中国人遗失传统文化的可悲，特别是汉族人。在一次旅游中，
导游是一位白族的少数民族，她是她们寨子的第一个大学生，她曾向我们挑战说：你们
汉族人丢失了太多的传统文化，在座的各位有谁敢与我一比书法，不比打字速度。结果，
一车有二十多位年轻的俊杰们，没有一人敢吭声，这是对自己的无奈，也是现实的无奈，
要说书法有什么用，对一般人确实没有什么用，但是这是中国传统的东西，并不能用现
代人的是否有用的观念来看待的。现代人就是多了那么多，有没有用，而忘了自己之所
以为人，为何不问，作为一个人有什么用呢？</p>
<p>##结 论
现代私塾的发展愈演愈烈，欧美国家十几年前便已经以立法的形式，肯定了在家教
育的合法性，台湾地区以及东南亚国家，都在近几年也以法律的形式肯定了现代私塾的
教育地位。但是在大陆地区，并没有在法律上与政策上给予这种教育模式合法地位。随
着改革的深入，教育改革也势在必行，多样化教育模式也会陆续出现，不管是欧美国家
传过来的西式自由式教育，还是本土产生的现代私塾教育都将成为未来民众的选择。
此研究，不仅详细阐明了现代私塾的教育方式与内容，更说明了现代私塾变革的方
向。注重全民教育，终身教育，将教育普及到人生的每一阶段，没有不能教育的对象，
也不应该有排斥现象。现代私塾的教育内容上必须是德智均衡，特别是德智体美劳的全
面发展，完善的人格和优良的道德品质需要身心的全面发展。现代教育讲究自由民主教
育，现代私塾也应该如此，教育方式的多种多样，利用人类的身心发展理论完善每一教
育阶段的方式方法。现代私塾教育需要全民的正确理解，需要民众的积极参与，需要从
上层精英推广到中下层普通民众。新事物的发展总是曲折前进的，通过实践的反复检验，
必能成长壮大。中国传统文化将是二十一世纪的主流文化，现代私塾教育也必将大放异
彩。</p>
<p>##致 谢
在论文的写作过程中遇到了诸多问题，感谢指导老师黄建军老师的耐心讲解与建议，
特别是标题与文章段落结构的意见，对于写作的帮助无疑甚大，同时感谢诸多同学对于
我语言错误的指正，也感谢全体宿舍给了我充满学术气息的写作坏境，最后感谢给予自
己思想源泉的梁漱溟、章太炎、熊十力、胡适、罗素、季羡林、南怀瑾、王财贵等大师
们的精彩论著，以及孔孟诸子的言论均对文章起到了重要帮助。希望阅读到此的读者，
均能秉持一颗开放的心态看待现代私塾的发展，并开始关注现代的道德与精神危机。当
无法找到精神寄托的时候，可以学习一下孔孟经典与诸子百家，以期收获精神慰藉。</p>
<p>###参考文献
[1] 梁漱溟. 这个世界会好吗. 天津：天津教育出版社，2011，309～357<br />
[2] 黑格尔，康德，韦伯等.中国印象（下）. 广西：广西师范大学出版社，2001，81～108<br />
[3] 章太炎. 章太炎讲国学. 北京: 华文出版社，2009，237～242<br />
[4] 南怀瑾. 南怀瑾著作珍藏本 第六卷：历史的经验 亦新亦旧的一代 中国文化泛言. 上海: 复
旦大学出版社，2000，237～336<br />
[5] 熊十力. 原儒. 北京：中国人民出版社，2011，81～140<br />
[6] 梁漱溟. 人心与人生. 上海：学林出版社，2005，14～95<br />
[7] 季羡林. 季羡林说国学. 北京：中国书店出版社，2007，13～75<br />
[8] 涂芳莹. 浅议现代私塾教育. 教育科学，2014（12）：212～213<br />
[9] 邓婷. 现代私塾：体制外的教育. 新华网重庆频道，2013（0325）<br />
[10] 卞文超. 现代私塾,教育的另一种可能? 大众网特稿，2014（1124）<br />
[11] 刘晓东. “儿童读经运动”质疑. 南京师大学报(社会科学版)，2004.5（3），63～70<br />
[12] 王兆璟，苏尧. “在家上学”的教育逻辑与反思. 当代教育与文化，2015.3（7.2），11～15<br />
[13] 秦红梅. “现代私塾”缘何兴起. 合作经济与科技，2010.11（405），108～109<br />
[14] 熊贤君. 私塾教学方法的现代价值. 课程教材教法，1999（9），60～62<br />
[15] 张步峰，蒋卫君. 现代私塾“孟母堂”能否见容于法治. 法学，2006（9），6～11<br />
[16] 佚名. 语感训练太少了. 文汇报，1992.5.1（7）</p>
<p>##现代私塾的发展研究
###摘 要</p>
<p>现代私塾，经过十年的发展为越来越多的人所熟知。民众长久以来所担忧的精神与
道德危机，找到了解决之道。21 世纪需要中国传统文化，而中国传统文化的继承与发展，
离不开私塾几千年的教育支撑。现代私塾以古代私塾为依托，融合现代教育特色，成为
众多中上层民众的选择。
本篇论文将从现代私塾的基本概念与作用谈起，解读现代私塾的教学方式与内容，
分析私塾从古至今的发展历程，阐明现代私塾的发展现状。着重分析了现代私塾在发展
过程中遇到的关于办学理念、教学内容、教学方式、家长期望的问题与产生原因，并将
自己的思想认知与私塾教育相整合，针对现代私塾教育的未来发展，提出了终身学习、
德智均衡、自主思考、目光长远四大建议并对此做出详细解释。本论文希望能对民众了
解私塾，关注教育发展，关注人类精神道德世界贡献自己的一份力量。
关键字： 现代私塾； 精神道德培养； 中国传统文化； 教育模式</p>
<p>###ABSTRACT
Modern private school, after ten years of development, is well known by more and more
people. The spirit and moral crisis that people have worried for a long time have found the way
to solve it. Twenty-first Century needs Chinese traditional culture, and Chinese traditional
culture inheritance and development cannot do without private school for thousands of years to
support education. Modern private school based on the ancient old style private school and the
integration of modern education, become the choice by many people.
This paper first talk about the basic concept and role of modern private schools and the
interpretation of modern private school’s teaching content and method. Then tell about analysis
of the development of the modern private school and clarify the current modern private school.
Focuses on the analysis of the problem encountered by the modern private schools in the
development process of educational philosophy, teaching content, teaching methods, parents'
expectations and the cause and will integrate their own ideological cognition and private
education and for the future development of modern private education, the lifelong learning,
comprehensive equilibrium, inspiration, four suggestions to long-term vision and this made
detailed explanation. This paper hopes to the public understand private school, pay attention to
the development of education, pay attention to a human spiritual and moral world with its own
strength.
Key words: Modern private school; Spiritual and moral culture; Chinese traditional culture;
Education model</p>
<p>###目 录
1.前 言 ........................................................................ 1<br />
1.1 选题原因与意义............................................................... 1<br />
1.1.1 选题原因 .................................................................. 1<br />
1.1.2 选题意义 .................................................................. 1<br />
1.2 研究目的与方法............................................................... 1<br />
1.2.1 研究目的 .................................................................. 1<br />
1.2.2 研究方法 .................................................................. 2<br />
1.3 基本概念与主要研究问题....................................................... 2<br />
1.3.1 现代私塾定义 .............................................................. 2<br />
1.3.2 现代私塾存在的必要性 ...................................................... 2<br />
1.3.2 主要研究内容 .............................................................. 2<br />
1.3.3 国内外的研究 .............................................................. 2<br />
2.现代私塾的背景及概述 .......................................................... 4<br />
2.1 现代私塾复苏的背景........................................................... 4<br />
2.2 现代私塾复苏的原因........................................................... 4<br />
2.3 现代私塾的教学方式与内容..................................................... 5<br />
2.3.1 教学方式更加丰富 .......................................................... 5<br />
2.3.2 教学内容范围更广 .......................................................... 6<br />
3.现代私塾的发展历史与现状 ...................................................... 7<br />
3.1 私塾的发展历程............................................................... 7<br />
3.1.1 私塾的由来 ................................................................ 7<br />
3.1.2 私塾的历史发展 ............................................................ 7<br />
3.1.3 现代私塾的复苏 ............................................................ 8<br />
3.2 现代私塾的发展现状.......................................................... 10<br />
3.2.1 兴奋期的快速发展 ......................................................... 10<br />
3.2.2 变革期的热度降低 ......................................................... 10<br />
4.现代私塾存在的问题 ........................................................... 12<br />
4.1 办学理念存在偏差............................................................ 12<br />
4.2 教学内容略显片面............................................................ 12<br />
4.3 教学方法不够开明............................................................ 13<br />
4.4 家长期望过于急切............................................................ 14<br />
5.现代私塾的未来发展之道 ....................................................... 16<br />
5.1 树立终身教育的办学理念...................................................... 16<br />
5.2 完善德智均衡的教学内容...................................................... 17<br />
5.3 采取自主思考的教学方式...................................................... 18<br />
5.4 引导家长树立长远的目光...................................................... 18<br />
结 论 ......................................................................... 20<br />
致 谢 ......................................................................... 21<br />
参考文献 ....................................................................... 22</p>
<p>##1.前 言
###1.1 选题原因与意义
####1.1.1 选题原因
本篇论文以现代私塾的发展研究为题，主要原因有三：首先，经常在报纸期刊中阅
读到关于现代私塾的报道，并对此有不同的观点，引起了自身的关注；其次，在大学四
年中，广泛接受中国传统文化的熏陶，时刻关注着中国传统文化的继承与发展，而现代
私塾的目的之一就有继承传统文化；最后，在课题选择时，发现学院允许写关于传统文
化方面的论题，因此在与导师的商榷之后，定下了论文选题。
####1.1.2 选题意义
此研究不仅是为了说明现代私塾发展过程中的问题，更是想借此探索一种新的教育
模式，构造一种以中式私塾教育为主的中西结合的教育模式，以期解决国民在精神与文
化素质方面的欠缺，同时，希望将这种教育模式推广到全世界，为实现全人类的美好而
和平的未来打下道德与精神基础。
罗素说过：“天性的幸福与生活的快乐，是我们在工业革命与生活坏境的重压下丢
失的最重要而又最平常的东西之一”。现代私塾作为新时代变革下的产物，其产生与发
展必有一定的道理，这不仅对于现代教育的改良，甚至是教育变革都有很大的参考意义，
中国传统的教育方式之所以能够持续几千年之久，与中国人的生活方方面面都有很大的
关联，中国人精神的继承与发展都离不开私塾的帮助，可以说，从私塾教育中，可见中
国人精神一斑。现代私塾，作为构造精神世界与传承传统文化受到了社会关注，而对于
现代私塾的研究，大部分都停留于报纸期刊，没有关于此的详细而具体的研究，并且最
重要的是，在阅读相关的资料后，笔者分析并提出了自己对此的一套看法，总结出了一
种教育改革模式。因此笔者希望将其研究下去，不仅是对为了更好的说明这个新兴事物，
更是希望对未来社会教育有所帮助。
###1.2 研究目的与方法
####1.2.1 研究目的
研究现代私塾的目的有三：首先，介绍现代私塾的发展、教学内容、教学形式等方
方面面，并向社会推广；其次，现在私塾发展过程中遇到的各种问题，需要加以修正，
对此提出了自己的一套看法与意见，并对此进行解释。本文是从传统文化与普通大众的
角度，看待现代私塾发展中遇到的问题与未来趋势。
####1.2.2 研究方法
研究的方法有三，首先文献查询法，通过将各种资料整合，与中国的国学大师，与
东西方哲学思想进行交融，得出自己的理论依据与意见看法。再者理论联系实践法，对
现行的教育模式与现代私塾的教育模式进行考究，弥补互相之间的不足。最后案例分析
法，通过对现实中案例进行观察，查询网络报刊上的真人真事，为写作提供参考依据。
###1.3 基本概念与主要研究问题
####1.3.1 现代私塾定义
现代私塾是指发起于 20 世纪 90 年代末，创建于 21 世纪初，以读经诵典为主要学
习内容，通过言传身随的教育方式，融合了现代自由式教育的特点而形成的一种新的教
育模式。
####1.3.2 现代私塾存在的必要性
现代私塾存在有两点必要性。一是在现代教育背景下，教育偏向于数理化的智育，
偏向于以金钱与利益为目的。现代人因此没有了思想根基，遇到问题无法寻找到行为判
断的准则。通过读经诵典，可以给人以精神寄托，平时的一言一行均可以找到来源，不
会盲目而不知所措。经典有着自己的一套理论认知与精神解说，与宗教有着异曲同工之
妙。二是时代的要求，21 世纪是中国传统文化的世纪，全世界都在兴起学习中国传统文
化的热潮，而中国作为发源地，能够将中国传统文化传承千年而不断，靠的就是私塾教
育，因此通过现代私塾教育，可以更近一步融入 21 世纪，先人一步了解到传统文化的
魅力。
####1.3.2 主要研究内容
在本次的论文写作中，主要针对现代私塾的办学理念的偏差、教学内容失衡、教学
方式不够开明、家长急于求成四个方面作探讨，并对此提出自己的一套看法与原因分析。
####1.3.3 国内外的研究
对于中国传统的教育模式的研究颇多，而对于现代私塾的研究所涉及甚少，主要集
中在报纸期刊上，因此本篇论文针对现代私塾的所有观点均为笔者原创。国外对于现代
私塾的研究，只是在于东南亚国家在法律上肯定了在家教育的合法性。台湾地区的现代
私塾研究，与中国大陆差异较大，而且资料甚少，不作具体比较分析。</p>
<p>##2.现代私塾的背景及概述
私塾，无疑是历史上中华文化传承与精神文明建设的最重要的贡献者，作为封建时
代的产物，私塾教育在建国后慢慢消失在人们的视野中，但是就在近十几年时间里，私
塾借助现代的人文与科学方法得以重生，现代私塾走向了历史的舞台。现代私塾即是以
现代儿童教育理论为基石，传统私塾的教育内容与方法为核心而形成的一种教育体系。
###2.1 现代私塾复苏的背景
从上世纪九十年代开始，一批专门从事于国学研究的学者，开始在台湾地区兴起读
经运动，读经运动主要是鼓励青少年，特别是处于幼儿时期的孩子，参与到对中国传统
经典的背诵中。其中的代表人物是王财贵，他是牟宗三先生的弟子，他推广的这项读经
运动，受到了南怀瑾先生的大力支持，与南怀瑾先生的教育观念不谋而合，因此，在台
湾造成了很大的影响。到 2000 年的时候，在台湾地区，读经的青少年已经达到几百万，
并且在东南亚国家的华人社区快速传播。
在 2000 年的时候，王财贵来到了北京师范大学演讲，诸多有识之士称之为“一场
演讲，百年震撼”。在此之后，大陆的诸多有识之士开始了探索读经诵典的路途，也因此
一些现代私塾开始陆续出现。在 21 世纪的今天，国家大力提倡弘扬传统文化，特别是
习近平总书记对于传统文化在中国的传承寄予了很大的期望，因而各种各样的现代私塾
借着改革的春风开始陆续出现，引起了社会中上层的广泛关注。接着社会名人郑渊洁与
韩寒等都公开表示，孩子将会由他们自己进行教育，引起了更多的社会民众关注现代私
塾。
###2.2 现代私塾复苏的原因
现代私塾的复苏，源于人们对于现代生活方式与心理健康的担忧，通过对家长采访
与相关的报道，总结出了以下三点原因。首先，现代教育体制对于儿童的身心发展不利。
引用南怀瑾先生的话“现代教育就是在摧残孩子”，这句话虽然说的偏激，但是有一定
的道理。现代的教育方式与教学过程不符合孩子正常的身心发展的需要，是对孩子心智
的破坏，使得孩子厌恶学习。但是通过背诵经典这种最经济的投入，有益于开发孩童的
智力与记忆力，通过婴儿时期的音乐与美术，及其他教育，可以使孩子在很小的时候，
就开始开发大脑对于艺术的感觉。其次，读经有助于对中国传统文化的继承。现代诸如
文化侏儒症的新式名词，均在强调中国人在文化传承上的断层，通过读经，可以在内心
留下很多的经典知识与语言，对于以后的写作说话，都能起到一个很好的帮助。最后，
读经诵典有助于培养健全的人格与积极的思想。现代教育成长出来的孩子，在思想上往
往都是跟随西方的玩乐主义，西方文化也有优良的地方，比如科学探索精神，但对此孩
子并没有学到多少，也因而犯了东施效颦的毛病。也是因为现代教育下的儿童没有自己
的独立的人格与思想体会，造成了社会上众多青少年的奇葩现象，人们开始认识到思想
教育的重要性。经典之作是开阔人的，是为了给人树立高远的胸怀的，而不是为了顽固
人。因此，受到了诸多人的追捧。
许多的民众在思考之后，便将自己的孩子送去读经，因此，很多的现代私塾性质的
教育班开始出现，发展到今天，不仅有各种教育培训班，还有全日制的现代私塾也逐渐
增多。现代私塾的主要教育对象是创办者自己的孩子，以及亲属朋友间的孩子。
###2.3 现代私塾的教学方式与内容
现代私塾通过对教学内容与教学方式的创新，赢得了很多家长的认同，与古代私塾
相比，其在教学方式上变化很大，与现代教育相比，其在教学内容上也有很大的创新之
处。下文将从比较中阐述现代私塾的教育方式与内容。
####2.3.1 教学方式更加丰富
相对于过去，它的形式发生了一些变化，笔者搜集到一份关于清朝私塾的教学内容，
如下：每天早起温习读书，背诵。上生书时，老师讲解完毕后，“命学生复述一遍，乃就
位念一百遍”。午后，主要是写字与温书，然后背诵。晚上练习作对，灯下读古诗。隔日
学写诗，逢三、八日作文，每逢初一、十五作史论诗赋。
在此份私塾课表中，我们可以发现，此时的学业主要集中在书本上，不管是对经典
的背诵，还是对于诗词歌赋的练习，均是在一个学堂中完成的，并没有开辟更多的空间
的进行其他的学习，但是现代的私塾，学习地点与时间发生了很大的变化。不再是过去
严厉环境下的刻板教学，而是多了许多的自由空间，孩子们每天放学之后，并没有手机
电脑的干扰，而是一起爬山或者互相娱乐。同时教学地点也不仅仅是课堂上，而是很随
意性的，席地而坐，行走中，都可以进行教授。采用的课堂教学方式，主要是王财贵的
六字真言“小朋友，跟我念”，通过言传身随的方式，让孩子们背诵经典。这与古代私
塾并不二话。在此，也略提古代私塾，并没有那些不懂得人们认识的那样，充满古老腐
朽的气味，其在听说读写方面都有很大的重视。对理性与才艺的关注更为重视，与现代
教育只关注理智，即科学技术水平是有很大差别的。</p>
<p>####2.3.2 教学内容范围更广
现代私塾在教学内容上与现代教育有着很大区别。现代私塾教学的课本主要是四书
五经之类的传统典籍，而且主要学习是背诵，没有很多对于文字的讲解工作，除了背诵
经典，现代私塾还开设了与传统艺术相关的课程，注重学生的精神世界。在画家张中和
开办的私塾中，除了背诵经典的课程外，还有武术，美术，音乐等兴趣课程，也有艺术
的必须课程，大部分私塾每天也会花 20 到 30 分钟给孩子讲讲数学，使他们能与体制内
学校的学生水平相当。据采访资料显示，私塾的学生，在琴棋书画上的造诣相比于体制
内学生要高出很大的一筹。要说艺术是否能与科学技术有一比，当然仁者见仁，智者见
智，但是无可厚非，艺术造诣的提高乃文化的一大进步。再者，现代私塾不仅教授学生
中国的经典作品，还教授国外的经典，比如莎士比亚的十四行诗，美国的《独立宣言》
等，都是学生必背的文章，这也是与体制内英文教学内容相去甚远的地方。</p>
<p>##3.现代私塾的发展历史与现状
现代私塾的起源是古代的私塾教育，私塾教育源远流长，为了彻底了解现代私塾的
特色，对古代私塾发展研究是十分必要的，并且相比于古代私塾，现代私塾在教育形式
与内容上也产生了诸多变化。
###3.1 私塾的发展历程
####3.1.1 私塾的由来
《礼记·学记》载：“古之教者，家有塾。”郑玄注：“古云仕焉而已者，归教于闾里，
朝夕坐于门，门侧之堂谓之塾。”孔颖达疏：“周礼百里之内二十五家为闾，共同一巷，
巷首有门，门边有塾。民在家之时，朝夕出入，恒就教于塾。”据裘锡圭先生考证，在殷
墟出土的卜辞中，有多处提到了塾。塾在卜辞中作“孰”，两个字旁为上下结构。不过，
商代的塾不是教育儿童的场所，而是宫门侧之堂。说文解字中，亦将塾子作该解，清人
顾震福的解释是：“臣朝君至门外，当就舍更详熟所应对之事。塾之言熟也，是塾本以熟
思得名。”（《隶经杂箸》甲编卷下）。综合上面的考证之后，我们大致可以将私塾的出现
定义在西周时期。塾，即是西周乡试中的一种形式，是教学的地址，而私塾则是指私人
开办的塾，与之相应的还有家塾，指富裕家庭或家族开办的塾。在此论文中，我所指的
私塾指广义的私塾，是包括狭义的私塾与家塾。现代历史学家，普遍同意：孔子所开办
的私学，即是私塾的一种，因此，孔子乃最有名的塾师。
####3.1.2 私塾的历史发展
私塾从春秋战国之后开始大量出现，特别是孔子的私学形式的教学方式，在各个流
派和国家中开始兴起。在秦朝统一六国之后，私塾的发展进入波动期，原因是秦朝的焚
书坑儒，对私塾推广最盛的儒家造成致命打击。到了汉武帝时期，汉儒的出现使得儒家
性质的私塾开始站住了脚，特别是董仲舒宣扬的“天人感应”、“大一统”，受到了统治者
汉武帝的赞许，在其的大力推广下，开始了浩大的“罢黜百家，独尊儒术”的运动。从
此之后的几千年时光，儒家性质的私塾，成为了封建教育的正统。但是也顺便提一下，
自汉儒之后，儒学的性质开始了转变，从孔子的仁爱，追求人性的美好初衷，开始沦为
封建统治者治理国家的伦理手段。
在汉朝之后，进入了魏晋南北朝时期，这个时候的选举人才的制度，变成了九品中
正制，选官任官主要是士族大夫的事情。对于贫穷的中下层人民，耕种养殖成为了世代
相传的事情，因此，在农村与贫苦地区的私塾，此时教授的内容也变成了基本的蒙学。
所谓蒙学，则是指识文断句，以最基本的伦理与简单的识字为主体，对于高深的儒家思
想或者百家思想都没有了解，论语能学半部尚属困难，何谈诸子百家。这时候的私塾的
发展受到了冲击，很多人都无需上私塾，或者上不起私塾。
在此之后，战乱少了，五胡乱中原也结束了，隋朝开始成为大一统的王朝。在隋文
帝杨广的政策下，一个延续千年，直到清末的科举制正式确立。不管是士族大夫，还是
穷苦小民，都可以通过学习，来改变自己的生命轨迹，社会上下层的流动开始出现。在
此的利益驱动下，各种乡间私塾成片兴起，不管再如何清苦，也要将孩子送进私塾读书，
读书改变命运的时代来临，自此“书中自有黄金屋，书中自有颜如玉”成为了每一个少
年、青年的人生准则。正是因为私塾的出现，文化也进入了兴盛的时期，从前文化名人
主要是世家大族中的人，现在贫苦自学、“偷学”的人开始走向历史舞台，促成了唐代诗
歌的巅峰表现。此后的宋朝，人民物质极大丰富，家家能用金银，家家更能够上的起私
塾，更甚者家塾。此现象到了宋朝朱熹之后，统治者为了加强统治，将朱子的四书集注
等强行纳入科举考试的范本，开始了八股文的强力统治时期，此多为后人所诟病。
到了清朝末年，国门打开，西方的先进科学技术接踵而来，洋务运动、明治维新，
在一大批改革家的推动下，科举结束了。私塾慢慢转变成现代学堂，特别是五四运动，
新文化、新思想的注入下，新的教学形式与内容开始取代私塾。民国时期，私塾与现代
学堂的斗争进入了针锋相对的时期，二者半斤八两。到了解放以后，在新中国的土地改
革与教育变迁之下，私塾逐渐消失在了历史长河中。
####3.1.3 现代私塾的复苏
本来在新中国已经消失的私塾，近年来，随着读经运动的推广，人们对于精神生活
的追求，对于传统文化的传承，对于现代体制内教育的诟病，在诸多的因素作用下，私
塾开始了复苏趋势，我们将其名为现代私塾。此阶段状况下文做详细探讨。在此，提出
一个本文重要思想基础：中国传统文化的复兴是时代的要求，不随人的意志为转移。
为了说明读经运动对于儿童教育的意义，现代私塾支持者举例了很多的中外大家在
年少的时候读经诵典的实例，甚至于搬出了新文化运动的“始作俑者”胡适之先生。胡
先生一生中，对古文化的态度提出两种截然不同的观点。年青的时候，在新文化运动时
期，他是打倒孔家店的先锋，他是提倡新文化代替旧文化的最有力量的人物。而在其垂
暮之年，则一改以前坚信的新文化，提倡中国应该继承传统文化，复兴中国的文化。胡
适之先生的弟子在其传记中批注，希望能够重新开始私塾教育，并表达自己对于中国文
化断层的担忧。对此，笔者也有一些观点，在新文化运动时期，之所以传统文化受到了
很大的冲击，主要是因为其乃国民革命时期，中国需要的是奋起反抗的斗争精神，而中
国传统文化所宣扬的则是一种散漫的态度，散漫即是和平，越和平则越散漫。所以在这
种精神状态下，想要取得与外国列强斗争的胜利，文化需要变革，人民的精神世界需要
重铸。现代很多提倡古文化的专家学者，总是喜欢将新文化运动批评为中国文化断层的
罪魁祸首，其实不然，虽然新文化运动对中国文化形成了强有力的打击，甚至全盘否定，
但是这是历史发展的无奈，也是中国人能够取得后来成功，新中国能够成立的基石。而
后来胡适之先生的态度发生转折，也不难看出。毕竟胡适之先生是对中国文化有深刻研
究的学者，虽说他是一个革命党人，在国民党中举足轻重，但是说到底，他还是一个文
人，只要是文人，特别是从小就接受中国传统教育的文人，骨子里有一种悲天悯人的气
息，对于国家与人民有相当强的担当精神，这即是儒家的修身、齐家、治国、平天下。
在胡适之先生的晚年时期，台湾地区的经济已经得到了相当快的发展，而新生在台湾的
一辈人，因为他们接受的都是西方的新式教育，这时候的台湾几乎已经全盘西化了。这
时候胡适之先生发现台湾人民的生活与人际关系出现了不和谐，出现了斗争冲突，出现
了靡靡之音，出现了西方的享乐主义与自我中心主义，因而他又将目光转向了中国传统
文化，从中发现了诸多可以治理现代怪乱的精神指引。这正是他晚年的思想改变的缘由。
详细解说了胡适之先生的思想变迁，主要是为了说明：中国文化的复兴与传承是时
代的要求，不会因为某些专家学者的大力反对而改变，也不会因为古文化提倡者的大力
吹捧而改变。时代的客观需要，不会因为个人的意志而转移的。当普通的人民大众发现
自己需要这种文化来完善人格或者和谐相处的话，他自己就会从心底去寻找这种精神的
寄托。这也就解释了为什么了现代私塾与读经运动一兴起，就有很多的社会中上层的精
英开始关注，并将自己的孩子送入其中，因为他们是最先体会到社会的变迁的，最先感
受到需要改变的人。而普通的大众还在为生活奔跑的时候，哪里有时间来想那么多精神
与思想上的事情，只有当物质世界足够发达，人们开始关注周围的人与物的时候，人们
就会主动去寻找，而中国传统的文化，特别是先秦时期的诸子百家，无疑是为了这个时
代而创造的，因而梁漱溟先生说，中国文化是早熟的文化，跨越了千年之久才能够得以
繁荣昌茂。</p>
<p>###3.2 现代私塾的发展现状
据网络上、期刊上的统计数据，现代私塾的发展可以分为兴奋期与转变期。兴奋期
指的是，在本世纪初几年到 2013 年。之所以将其在 2013 年分割，主要是因为在读经推
广的时间里面，完成了诸多私塾所认可的十三岁教育的理论，该理论详情，此乃后话。
经过十来年的发展，很多家长从开始的疯狂热衷，开始转入了冷静思考，并且随着很多
儿童的毕业，一些问题也随之出现，变革期也即将到来。
####3.2.1 兴奋期的快速发展
严格来说，现代私塾发起于上世纪 90 年代末，主要是因为台湾的读经运动是从那
时候开始的。此时台湾开始出现诸多私塾教育，而大陆并没有出现其复苏迹象，大陆地
区的私塾，真正应该考究到 2000 年以后，第一个出现的私塾出现在深圳地区，名为儒
愿学堂，2001 年创办，并于此后 2005 年开始招收外来学生。从此刻起，深圳的梧桐山
开始逐渐成为现代私塾的集中地。于此同时，上海的“孟母堂”、北京的“国学馆”、广
州的“六艺私塾”、深圳的“鹿鸣学堂”、苏州的“菊斋私塾”、武汉的“今日学堂”和沈
阳的“九雯学堂”等相继在此后的几年内成立起来。到了 2013 年的时候，全国将近有
3000 所现代私塾成立起来，其中学生人数不一定，人数最多的鹿鸣学堂有 100 人左右，
而一些小的私塾就只有 3 到 4 人而已。因为现代私塾都是没有经过政府教育部门审批
的，因此在数量上很难完全准确的统计。这些私塾刚开始主要分布于深圳、上海、北京
等一线大城市，而后开始向二线城市苏州、武汉、成都、重庆、沈阳等开始蔓延。
现在全国私塾分布已经基本达到了各省会城市均有的地步，宏观形势是：南多北少，
东多西少，大城市多、小城市少，规模小的多、规模大的少。私塾的教学所在地，也不
尽相同，深圳梧桐山的读经村，是在风景秀丽的山脚下，而全国其他的私塾主要位于城
市的住宅区，不谈风景如何，但是相对安静一些。随着国学热的继续汹涌与越来越多民
众的关注了解，相信现代私塾增多的情况还会继续下去。
####3.2.2 变革期的热度降低
在 2013 年之后的变革期，对于已经读了几年的私塾学生，他们以后的学习教育生
涯受到了各方关注。有些家长发现孩子读了几年之后，并没有表现出有什么特别显而易
见的文化积淀，因此开始将孩子送到现代教育体制下。也有家长觉得只是经过读经，并
不能满足孩子以后的日常生活，特别是数理化方面的能力，也因此将孩子领出私塾。也
有很多的孩子虽然以前能够背诵，但是一段时间之后便会忘记，使得家长很不满意，甚
至于有的家长发现孩子学了几年，竟然在认字上还有一定的问题的时候，便领着孩子开
始逃离私塾。相对于兴奋期来说，这个时候的家长，开始慢慢理性认识现代私塾与现代
教育体制，发现了诸多的问题。
在此现实下，诸多现代私塾也开始了相应的变革。比如，很多的私塾以前只教授读
经，而现在也开始进行数理化的教授。但是，也有很多的私塾下定决心，绝不会在十三
岁之前接触数理化。与此同时，为了解决孩子在完成十三岁教学以后的教育问题，王先
生在北京创办了文礼书院。该学院只接受读经出来的孩子，成为了读经孩子的清华北大，
但是招生要求只有一个，即是能够背诵三十万字（中文二十万，外文十万）的经典。这
渐渐使得一些私塾的创办者将背诵提高到了相当的程度，这又造成了另类的应试教育，
起到了极其恶劣的影响。全国很多地区的现代私塾，人数开始了减少。还是拿梧桐山的
读经村为例，张中和先生创办的得谦学堂，人数最多的时候有几十人，而现在人数下降
了一半。因此，现代私塾的教育慢慢走到了变革的地步。</p>
<p>##4.现代私塾存在的问题
现代私塾与古代私塾不尽相同，又与现代的教育体制有很大的区别，可以说这是一
个既老又新的事物。在其发展过程中不免出现很多的问题，亟待解决，马克思曾经也说
过：新事物的出现于成长总是充满波折与艰难的。因而，现代私塾想要在社会上占有一
席可容之地，还需要更多的变革与改进，下文从理念、教学内容、教学方式、家长认知
四个方面阐述出现的问题与原因。
###4.1 办学理念存在偏差
现代私塾诸多创办者所认可的是王财贵的关于儿童读经运动的理念，认为读经只能
从很小的时候开始，或者说必须在十三岁之前完成，而如果超过了这个时间，则人生都
已经成为了定局，不必再费周章教授。对此，笔者认为该理念不可取，人的认知与道德
思想的塑造，并不局限于少儿时期，只要教授的好，改变一个人亦非难事。
诸多的家长，在孩童很小的时候便急于送去私塾学习，无可厚非，但是任何时期，
只要想学想要改变，均未尝不可。国学大师梁漱溟先生，小儿时期上的是学堂(现代教育
的小学雏形)，根据其个人的传记，美国教授艾凯所著的《最后一位儒者》以及个人的访
谈记录，用他自己的话说：我从小没读过什么古书，对古文学的研究也不多，比不得文
学研究的大家，我只是在一些书本中学习，我只是爱思考，说我是哲学家的话，则更为
贴切。无论说梁漱溟先生是不是一个另类的存在，但是据其思想的挖掘，我们可以很容
易的发现，他对儒家、佛家的思想的理解，已经到了一个十分高深的程度，而就是这样
一个新派儒学的三大圣人之一的人物，则承认自己并没有背过所谓的经典。于此，我们
可以发现诸多人称颂的所谓：想要传承传统文化，想要有一个完整的人格，必须通过十
三岁前完成对经典的背诵这一理论基石，出现了与现实的偏差。
只此一例，即可直接指出现代私塾在教育对象的年龄上严格要求有所偏差，虽说，
十三岁之前是教育的黄金阶段，但是人的性格与道德的培养，还有文化的积淀，并不能
因为年龄而有所限制。
###4.2 教学内容略显片面
教学内容方面的主要问题反应在儿童结束私塾学习之后，表现出比其他同龄儿童数
理化成绩方面的差异，与现代的教育所提倡的自由全面发展之间的冲突。
在此问题上，现代私塾采用的是德的培养，是理性优先的培养。对于理智方面的知
识，在他们看来，完全可以放到十三岁以后，因为十三岁时人类心理与生理上的一个转
折点。现代的教育理论普遍认为十三岁之后，孩子会开始有自己判断世界的标准，对世
间的问题，开始有了自己的看法，由完全模仿的儿童期成长到自己认知的少年期。而这
个时候，儿童的大脑发育也就达到了一个水平，能够理解一些抽象的思维，比如数学物
理等。因此现代私塾倡导的教学内容也不难理解，他们想通过在十三岁之前，让孩子背
诵完经典，将未来的为人做事的准则率先注入到孩子的思想中。
这种内容教学还是欠妥的，首先，在其教育德与智的选择上，笔者还是很同意的，
因为在儿童的模仿期间学到的思想，会直接影响未来一辈子的行为与道德水平，通过后
期的强行教导改变是十分困难的，新闻媒体经过有如下报道：夫妻有一孩子，在其很小
的时候，由夫妻的父母带大，但是父母的教育方式着实不可取，是一种溺爱性质的教育，
因而在孩子长大后，回到父母身边，其性格已经变得格外的调皮。虽说调皮是孩子的天
性，但是任由孩子调皮而置之不理，到最后，培养出来的肯定是一个疯狂原始人，极限
放养的结果即是原始人。虽然花了很大的力气来改正孩子的性格，想让其起码学会一些
道德标准与行为适宜程度，结果收效甚微。想必今天的孩子，凡是通过老一辈带大的，
均可能出现生活方面惹人心烦的事情。所以，笔者支持，在婴幼儿期就对其进行正确的
伦理思想与道德的塑造，这并不是所谓的压制儿童的成长，更不是对儿童心灵的虐待，
这是正常社会人的起码的基础。但是对于其教育内容上，还可以适当添加一些理智教学，
后文的建议中将详细叙述。
###4.3 教学方法不够开明
教学方法上存在的问题，在于只通过“小朋友，跟我念”，来完成教学的工作，并不
考虑儿童理解与否。对此很多家长反映，儿童在上完之后，有许多汉字，他会写，但是
不懂什么意思，更谈不上如何使用，这也就导致了很多家长对此的不满。
对此，儿童不理解、不会用的原因显然是因为儿童没学过。儿童是否需要学习，每
一个字的意思，甚至是否需要理解其背诵的文章的意思呢？对此，笔者的理解是不需要
完全懂得。之所以要读经典，背诵经典，主要的目的，还是从经典中学习其做人做事的
道理，寻找到未来心灵的一种寄托，该寄托于西方的宗教寄托有异曲同工之效，只不过
根源方法上却又天壤之别。西方的宗教是为了用神的意志来强加到人的身上，用神的审
判来使人恐惧，进而来达到教化人民的目的，而中国的儒学，传统文化中，没有宗教色
彩，虽然现代有儒教这一说法，但其也只是形式上有宗教感觉，而且这还是封建统治者
意志的强加，与儒学有很大的区别，孔子说：“未竟人，何竟鬼”、“子不语怪力乱神”，
意思是人自己都没有明白之所以为人，还去谈论牛鬼蛇神，因此可以看出，孔子思想中，
是不相信神鬼之说的，因而他倡导的儒家思想，是不可能有神鬼祭祀的，这只是后来儒
者强加的。因此，也可以发现，儒家，传统文化的核心，是教导人之所以为人的。对儿
童塑造其一生的性格与道德水平的促进作用是显而易见的。回到刚才之所以说，不需要
完成理解，还因为，既然选择了读经诵典，那么在经典中徜徉的久了，就可以用自己的
思维去读一些古文了，而不是要将其翻译成现代白话文来理解，这才是传统文化传承的
核心要求，能够读懂古文，甚至能够模仿古文作文章。笔者觉得，对于文言文的翻译是
对中国人的最大侮辱。自己祖先的文章都看不懂，而且用的还是从魏晋时期就已经基本
定型的汉字。孔子有言：好读书，不求甚解。就是这个意思，并不是要懂得字面的意思，
而是懂得其中蕴含的道理即可。
###4.4 家长期望过于急切
现在摆在私塾面前最大的问题，想必是儿童与家长对于现实与期望没有符合的冲突。
上文写到，有的家长发现，如果按照私塾老师的计划，孩子可以在十三岁之前，起码能
够背诵三十万字的经典，而现在过去几年之后，孩子虽然反复在背诵，但是背完了又会
忘记，并不能达到理想的期望。对于这个问题，需要分析以下二点：背诵经典的目的与
背诵经典是否值得。
首先，背诵经典的目的。按照诸多先生的考究，背诵经典，是为了孩子的一辈子打
下坚实的基础，这是一种隐形的变化，不能因为一时的不明显而感到失败或者放弃。其
次是背诵经典是否值得。在此，章太炎先生在一篇《论读经有利而无益》中提到：读经
在于修己治人，夫读史之效，在于发扬祖德，巩固国本，只为西方学的话，只能终为奴
掳而已矣。现代的很多国人均认可了，读经是对儿童有益的。那么此刻的问题，是背诵
经典是否值得的问题，经典是否需要背诵，是否只有通过背诵才能够达到修己利人的程
度，个人觉得不必，经典之所以为经典，并不是因为它的语言文学的水准有多高，而是
其中富含的经典解释与人生的哲理，才是经典最大的特色，而只通过背诵经典，囫囵吞
枣地话，那么收获到的只是词句罢了，但是，这与推广读经的儿童之见出现的最大的问
题之处是儿童并不能理解其中的道理，甚至于，给予他解释，他可能也并不了解成人世
界中的各种准则。对此，在读经推广们看来，只有强行背诵，以后慢慢回味即可。在笔
者看来，此乃下下之策，上上之策为何，是让儿童自己领悟，这与现阶段的儿童心理的
成长理论是完成符合的，也与现阶段人性的解放，追求个性发展，追求创新相符合的。
但是需要老师把握住教授解释时的原则。</p>
<p>##5.现代私塾的未来发展之道
对于现代私塾的发展，结局只有两条路，而且都是与现代教育相结合的。其一是以
现代私塾为主体，通过将现代的一些观点与理论加入到其中，发展出的一种中式教育。
二是以现代教育为主的教育方式，其在体制内进行改革，将传统文化与经典融入到日常
的学习中去，该方式与现在的教育一样，依旧参考的是西式教育模式。对于我对人类未
来文化融合的看法来说，笔者坚信第一种，中式教育更能成为时代的需要，也是复兴中
国传统文化的最强有力的教育模式。这并不是说是中国人的自豪，或者说是为了争一口
气，而是时代的文化将是以东方文化为主，融合西方文化，这样的条件下，以东方教育
为主也就不难理解了。对于以现代私塾为主体的中式教育，主要有四个方面的改良建议。
###5.1 树立终身教育的办学理念
任何人在任何时候，均可接受传统经典的教授，现代私塾理应开办面向儿童的全日
制教育与面向成人的文化修养兴趣班。
这就涉及到该教育是否定义为完全的婴幼儿教育和儿童教育。正如上文所分析那样，
对于成人的思想改造与文化传承，通过经典的学习，也还是能起到很大的效果的，除非
放任不管，不采用中式教育，否则将同新闻报道的孩子一样，变得难以教导，难以改变。
因此，建议将现代私塾扩展到适应所有的年龄层。可以将现代的私塾打造成一个立体全
方面的经典教育基地，包括儿童的教育，成人的教育以及对于那些选择其他教育模式的
儿童的辅导性教育，但是那些教育必然是儿童教育的副产品，主要的作用还是全日制的
儿童教育，相信在中国发展愈演愈烈的时候，中国的立法部门与政府部门肯定会将现代
私塾纳入到合法的范围中去，这不仅是对传统文化的继承，更是这个时代对于中国传统
文化的需要。而对于一些现代私塾未来出现的各种不良情况，只要在立法与政府部门肯
定之后，那么也将进入监管的范围。
一般在大城市的私塾的收费均在每年 2万元左右，这与众多的高质幼儿园价格接近，
由新加坡倡导的爱儿坊幼儿园，每年的花费也在 2 万多左右，但是与现阶段的幼儿园最
大的差别之处在于，现代私塾都不是在所谓的学区房中，可以省下一大笔开支。当然，
现阶段私塾的价格，对于普通家庭来说，还是很高的，难以接受，原因就在于现代私塾
在很大程度上沿袭了古代私塾的特点，就是因材施教，都是小班形式的，导致了价格的
高昂，对此，未来的私塾模式教育，想要成为中国普通类教育来说，要解决的是两个问
题:一个是数量，一个是价格。在笔者看来这都不是最要紧的，可以通过市场的调节机制
与现代的租赁形式加以解决设施设备的问题，而最要紧的上文已经言明，在于教学内容
与方式上。
###5.2 完善德智均衡的教学内容
德以中为主，智以西为主。中国传统经典在于塑造人的精神与道德，开阔人心理与
认知；西方现代科学在于开发智力，丰富民众的物质生活。德智均衡，是以德为主，以
智为辅，再经过艺术与美的熏陶，来达到一个人的全面发展。
教学内容的多样化， 将中西结合的结果用来培育现代社会人，这是未来的趋势，有
很多的私塾创办者坚称：我们只教授背诵经典，不会去教授数学之类的。这种心理很奇
怪，难道在他们的心目中，经典所带来的理性与科学赋予的理智是完全不可兼容的东西
么？你学经典的同时，就不能去学习数理化，就不能参与科学教育中？这种想法是极其
错误，德与智是相辅相成的，这也反映了中国文化的一大特色，那即是融合能力。纵观
历史，多次的外来文化的入侵，最终的结果都是被传统文化所同化了，不管是印度的佛
学，还是西方的基督教。佛学传来已久，早已形成了中国本土的佛教与佛学，而基督教
因为传入时间不长，特别是清末民初的动荡时期，为了侵蚀中国人的信仰，而流传也很
广，但是至今的作用已然甚微，就算中国的建筑、服装、饮食，甚至行为都受到西方的
强烈影响，但是西方的根基宗教思想还未对中国形成普遍的威胁。对此，可见一斑，中
国的同化能力是不可阻挡的，因此，将东西方的教育相结合，想必是一种趋势，特别是
国外的教育改革，国外的很多教育学家，针对西方的教育的弊端开始寻找改变的时候，
都不约而同的将目光放到中国来。现在的西方学者，很多也同意：中国传统文化将成为
下一世界的指导思想。对此，中国传统文化如何继承与发展受到西方的关注，私塾亦走
入西方人的视野中。对此，我们国家比任何的地区与国家都更能深刻理解，与更加容易
尝试将两者相结合。结合的方式，主要是教学内容上的融合，背诵经典的同时，拿出时
间来传授现代的数理化等科学知识，西方的数理化系统是最完善的，这点毋庸置疑，所
以不必刻意学习中国的传统数学，诸如《九章算术》之类。
现代的大部分私塾，开设了很多德智体美劳全面发展的课程，特别是艺术的培养，
这些都是在儿童教育中尤为重要的，儿童需要美学的熏陶。同时，开设基本的计算机学
习也是必不可少的，但是不能花太多时间用于计算机课程，这对儿童的身心发展都是不
利的。</p>
<p>###5.3 采取自主思考的教学方式
现代私塾教育不谈对错，只谈善恶。自主思考，方能解放人。
教学方式的自主化，这也是东西方文明的结晶，西方过度强调自由和个性的发展，
中国过于强调规范与行为准则，因而结合二者，能够得到的效果，无疑是最好的。在教
授经典的时候，需要儿童的自我思考，加上老师的稍加引导，老师不评对错，只评善恶。
启发学生的独立思考与乐于思考的习惯，为其自主学习，热爱学习打下思想基础。老师
的教授过程中对于学生的指引，需要老师有较好的文学水准与道德基础，能够在儿童的
理解出现重大恶劣倾向的时候给予纠正。甚至于私塾的老师也不能自以为是的了解其语
句的正确答案，便随意强加给学生，特别是翻译文言文，翻译文言文都是字面的解释，
无法将其意思与意境完全表达出来，如同外文一般，翻译即是一种破坏，需要的是领悟，
而古今的领悟数不胜数，谁的领悟更深一层，谁的领悟出现偏差，都需要儿童自己思考。
有一教学实例是成都明德书院的教学场景，其做法很是优良，摘录如下：
“朝闻道夕可死矣。什么意思？请说说你们自己的理解。”年轻的盛老师领过早读
后，赵钦任老师给孩子们讲解国学经典。
堂上七至八岁的学生，共坐了三排，个个都很踊跃，全部举手抢着要回答问题。
振宇第一个站起来说：“昨天晚上道理都死了，我今天早上才听说。”
孩子们笑得拍桌子，同学一凡称他是“搞笑大王”。
赵老师也笑：“是这个意思吗？请坐。”
珊珊的答案很简洁：“要珍惜时间。”
赵婉云则认为：“如果早上听说道理，晚上就死了，好是好，但是多活几天会更好。”
###5.4 引导家长树立长远的目光
文化在于积淀，思想在于自省。高瞻远瞩方能成就人生，且圣人非一日之功。
家长想要立马发现自己孩子的思想深度与文化底蕴，显然是不可能的，因为中式的
私塾教育强调的是思想与道德的塑造，而不像科学那样，可以计算，通过分数来衡量的。
因此，要求孩子的父母相信这种教育，并且关注孩子的心理教育与全面发展，关注孩子
未来的道德水平与文化水平，而不是只关注与孩子的考试，这样的话，才能解决很多现
实中的冲突问题。儿童在学习了一段时间的现代私塾之后，家长与老师可以根据儿童是
否乐于其中，是否希望更深入学习，来判断儿童是否应该继续在现代私塾中学习，如果
儿童抵制这种教育模式的话，则可以为其选择更适合的教学模式，因为人是生而不同的，
资料显示，在现代私塾上过学的孩子，在琴棋书画中展示出来的能力十分超群。因
此支持与鼓励私塾学生参与艺术类比赛于表扬，向别人展示自身独特的地方。在自身的
一个实例中，可以发现现代中国人遗失传统文化的可悲，特别是汉族人。在一次旅游中，
导游是一位白族的少数民族，她是她们寨子的第一个大学生，她曾向我们挑战说：你们
汉族人丢失了太多的传统文化，在座的各位有谁敢与我一比书法，不比打字速度。结果，
一车有二十多位年轻的俊杰们，没有一人敢吭声，这是对自己的无奈，也是现实的无奈，
要说书法有什么用，对一般人确实没有什么用，但是这是中国传统的东西，并不能用现
代人的是否有用的观念来看待的。现代人就是多了那么多，有没有用，而忘了自己之所
以为人，为何不问，作为一个人有什么用呢？</p>
<p>##结 论
现代私塾的发展愈演愈烈，欧美国家十几年前便已经以立法的形式，肯定了在家教
育的合法性，台湾地区以及东南亚国家，都在近几年也以法律的形式肯定了现代私塾的
教育地位。但是在大陆地区，并没有在法律上与政策上给予这种教育模式合法地位。随
着改革的深入，教育改革也势在必行，多样化教育模式也会陆续出现，不管是欧美国家
传过来的西式自由式教育，还是本土产生的现代私塾教育都将成为未来民众的选择。
此研究，不仅详细阐明了现代私塾的教育方式与内容，更说明了现代私塾变革的方
向。注重全民教育，终身教育，将教育普及到人生的每一阶段，没有不能教育的对象，
也不应该有排斥现象。现代私塾的教育内容上必须是德智均衡，特别是德智体美劳的全
面发展，完善的人格和优良的道德品质需要身心的全面发展。现代教育讲究自由民主教
育，现代私塾也应该如此，教育方式的多种多样，利用人类的身心发展理论完善每一教
育阶段的方式方法。现代私塾教育需要全民的正确理解，需要民众的积极参与，需要从
上层精英推广到中下层普通民众。新事物的发展总是曲折前进的，通过实践的反复检验，
必能成长壮大。中国传统文化将是二十一世纪的主流文化，现代私塾教育也必将大放异
彩。</p>
<p>##致 谢
在论文的写作过程中遇到了诸多问题，感谢指导老师黄建军老师的耐心讲解与建议，
特别是标题与文章段落结构的意见，对于写作的帮助无疑甚大，同时感谢诸多同学对于
我语言错误的指正，也感谢全体宿舍给了我充满学术气息的写作坏境，最后感谢给予自
己思想源泉的梁漱溟、章太炎、熊十力、胡适、罗素、季羡林、南怀瑾、王财贵等大师
们的精彩论著，以及孔孟诸子的言论均对文章起到了重要帮助。希望阅读到此的读者，
均能秉持一颗开放的心态看待现代私塾的发展，并开始关注现代的道德与精神危机。当
无法找到精神寄托的时候，可以学习一下孔孟经典与诸子百家，以期收获精神慰藉。</p>
<p>###参考文献
[1] 梁漱溟. 这个世界会好吗. 天津：天津教育出版社，2011，309～357<br />
[2] 黑格尔，康德，韦伯等.中国印象（下）. 广西：广西师范大学出版社，2001，81～108<br />
[3] 章太炎. 章太炎讲国学. 北京: 华文出版社，2009，237～242<br />
[4] 南怀瑾. 南怀瑾著作珍藏本 第六卷：历史的经验 亦新亦旧的一代 中国文化泛言. 上海: 复
旦大学出版社，2000，237～336<br />
[5] 熊十力. 原儒. 北京：中国人民出版社，2011，81～140<br />
[6] 梁漱溟. 人心与人生. 上海：学林出版社，2005，14～95<br />
[7] 季羡林. 季羡林说国学. 北京：中国书店出版社，2007，13～75<br />
[8] 涂芳莹. 浅议现代私塾教育. 教育科学，2014（12）：212～213<br />
[9] 邓婷. 现代私塾：体制外的教育. 新华网重庆频道，2013（0325）<br />
[10] 卞文超. 现代私塾,教育的另一种可能? 大众网特稿，2014（1124）<br />
[11] 刘晓东. “儿童读经运动”质疑. 南京师大学报(社会科学版)，2004.5（3），63～70<br />
[12] 王兆璟，苏尧. “在家上学”的教育逻辑与反思. 当代教育与文化，2015.3（7.2），11～15<br />
[13] 秦红梅. “现代私塾”缘何兴起. 合作经济与科技，2010.11（405），108～109<br />
[14] 熊贤君. 私塾教学方法的现代价值. 课程教材教法，1999（9），60～62<br />
[15] 张步峰，蒋卫君. 现代私塾“孟母堂”能否见容于法治. 法学，2006（9），6～11<br />
[16] 佚名. 语感训练太少了. 文汇报，1992.5.1（7）</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
